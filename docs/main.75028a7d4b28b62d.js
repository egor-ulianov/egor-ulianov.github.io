(self.webpackChunkangular_snow=self.webpackChunkangular_snow||[]).push([[179],{3866:function(){(function(){"use strict";var gt;function Xe(_){var V=0;return function(){return V<_.length?{done:!1,value:_[V++]}:{done:!0}}}var M="function"==typeof Object.defineProperties?Object.defineProperty:function(_,V,U){return _==Array.prototype||_==Object.prototype||(_[V]=U.value),_},we=function _e(_){_=["object"==typeof globalThis&&globalThis,_,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var V=0;V<_.length;++V){var U=_[V];if(U&&U.Math==Math)return U}throw Error("Cannot find global object")}(this);function te(_,V){if(V)e:{var U=we;_=_.split(".");for(var he=0;he<_.length-1;he++){var qe=_[he];if(!(qe in U))break e;U=U[qe]}(V=V(he=U[_=_[_.length-1]]))!=he&&null!=V&&M(U,_,{configurable:!0,writable:!0,value:V})}}function Q(_){return(_={next:_})[Symbol.iterator]=function(){return this},_}function F(_){var V=typeof Symbol<"u"&&Symbol.iterator&&_[Symbol.iterator];return V?V.call(_):{next:Xe(_)}}function j(_){if(!(_ instanceof Array)){_=F(_);for(var V,U=[];!(V=_.next()).done;)U.push(V.value);_=U}return _}te("Symbol",function(_){function U(ct,je){this.g=ct,M(this,"description",{configurable:!0,writable:!0,value:je})}if(_)return _;U.prototype.toString=function(){return this.g};var he="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",qe=0;return function V(ct){if(this instanceof V)throw new TypeError("Symbol is not a constructor");return new U(he+(ct||"")+"_"+qe++,ct)}}),te("Symbol.iterator",function(_){if(_)return _;_=Symbol("Symbol.iterator");for(var V="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),U=0;U<V.length;U++){var he=we[V[U]];"function"==typeof he&&"function"!=typeof he.prototype[_]&&M(he.prototype,_,{configurable:!0,writable:!0,value:function(){return Q(Xe(this))}})}return _});var me,Ie="function"==typeof Object.create?Object.create:function(_){function V(){}return V.prototype=_,new V};if("function"==typeof Object.setPrototypeOf)me=Object.setPrototypeOf;else{var Y;e:{var ee={};try{ee.__proto__={a:!0},Y=ee.a;break e}catch{}Y=!1}me=Y?function(_,V){if(_.__proto__=V,_.__proto__!==V)throw new TypeError(_+" is not extensible");return _}:null}var A=me;function de(_,V){if(_.prototype=Ie(V.prototype),_.prototype.constructor=_,A)A(_,V);else for(var U in V)if("prototype"!=U)if(Object.defineProperties){var he=Object.getOwnPropertyDescriptor(V,U);he&&Object.defineProperty(_,U,he)}else _[U]=V[U];_.ea=V.prototype}function Pe(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function xe(_){if(_.l)throw new TypeError("Generator is already running");_.l=!0}function Ze(_,V){_.j={U:V,V:!0},_.g=_.m||_.s}function ot(_,V,U){return _.g=U,{value:V}}function St(_){this.g=new Pe,this.h=_}function ke(_,V,U,he){try{var qe=V.call(_.g.i,U);if(!(qe instanceof Object))throw new TypeError("Iterator result "+qe+" is not an object");if(!qe.done)return _.g.l=!1,qe;var ct=qe.value}catch(je){return _.g.i=null,Ze(_.g,je),Oe(_)}return _.g.i=null,he.call(_.g,ct),Oe(_)}function Oe(_){for(;_.g.g;)try{var V=_.h(_.g);if(V)return _.g.l=!1,{value:V.value,done:!1}}catch(U){_.g.h=void 0,Ze(_.g,U)}if(_.g.l=!1,_.g.j){if(V=_.g.j,_.g.j=null,V.V)throw V.U;return{value:V.return,done:!0}}return{value:void 0,done:!0}}function It(_){this.next=function(V){return xe(_.g),_.g.i?V=ke(_,_.g.i.next,V,_.g.o):(_.g.o(V),V=Oe(_)),V},this.throw=function(V){return xe(_.g),_.g.i?V=ke(_,_.g.i.throw,V,_.g.o):(Ze(_.g,V),V=Oe(_)),V},this.return=function(V){return function Vt(_,V){xe(_.g);var U=_.g.i;return U?ke(_,"return"in U?U.return:function(he){return{value:he,done:!0}},V,_.g.return):(_.g.return(V),Oe(_))}(_,V)},this[Symbol.iterator]=function(){return this}}function $e(_,V){return V=new It(new St(V)),A&&_.prototype&&A(V,_.prototype),V}Pe.prototype.o=function(_){this.h=_},Pe.prototype.return=function(_){this.j={return:_},this.g=this.s};var ye="function"==typeof Object.assign?Object.assign:function(_,V){for(var U=1;U<arguments.length;U++){var he=arguments[U];if(he)for(var qe in he)Object.prototype.hasOwnProperty.call(he,qe)&&(_[qe]=he[qe])}return _};te("Object.assign",function(_){return _||ye}),te("Promise",function(_){function V(je){this.h=0,this.i=void 0,this.g=[],this.o=!1;var at=this.j();try{je(at.resolve,at.reject)}catch(ge){at.reject(ge)}}function U(){this.g=null}function he(je){return je instanceof V?je:new V(function(at){at(je)})}if(_)return _;U.prototype.h=function(je){if(null==this.g){this.g=[];var at=this;this.i(function(){at.l()})}this.g.push(je)};var qe=we.setTimeout;U.prototype.i=function(je){qe(je,0)},U.prototype.l=function(){for(;this.g&&this.g.length;){var je=this.g;this.g=[];for(var at=0;at<je.length;++at){var ge=je[at];je[at]=null;try{ge()}catch(Lt){this.j(Lt)}}}this.g=null},U.prototype.j=function(je){this.i(function(){throw je})},V.prototype.j=function(){function je(Lt){return function(kt){ge||(ge=!0,Lt.call(at,kt))}}var at=this,ge=!1;return{resolve:je(this.C),reject:je(this.l)}},V.prototype.C=function(je){if(je===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(je instanceof V)this.F(je);else{e:switch(typeof je){case"object":var at=null!=je;break e;case"function":at=!0;break e;default:at=!1}at?this.u(je):this.m(je)}},V.prototype.u=function(je){var at=void 0;try{at=je.then}catch(ge){return void this.l(ge)}"function"==typeof at?this.G(at,je):this.m(je)},V.prototype.l=function(je){this.s(2,je)},V.prototype.m=function(je){this.s(1,je)},V.prototype.s=function(je,at){if(0!=this.h)throw Error("Cannot settle("+je+", "+at+"): Promise already settled in state"+this.h);this.h=je,this.i=at,2===this.h&&this.D(),this.A()},V.prototype.D=function(){var je=this;qe(function(){if(je.B()){var at=we.console;typeof at<"u"&&at.error(je.i)}},1)},V.prototype.B=function(){if(this.o)return!1;var je=we.CustomEvent,at=we.Event,ge=we.dispatchEvent;return typeof ge>"u"||("function"==typeof je?je=new je("unhandledrejection",{cancelable:!0}):"function"==typeof at?je=new at("unhandledrejection",{cancelable:!0}):(je=we.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,je),je.promise=this,je.reason=this.i,ge(je))},V.prototype.A=function(){if(null!=this.g){for(var je=0;je<this.g.length;++je)ct.h(this.g[je]);this.g=null}};var ct=new U;return V.prototype.F=function(je){var at=this.j();je.J(at.resolve,at.reject)},V.prototype.G=function(je,at){var ge=this.j();try{je.call(at,ge.resolve,ge.reject)}catch(Lt){ge.reject(Lt)}},V.prototype.then=function(je,at){function ge(v,p){return"function"==typeof v?function(g){try{Lt(v(g))}catch(C){kt(C)}}:p}var Lt,kt,Un=new V(function(v,p){Lt=v,kt=p});return this.J(ge(je,Lt),ge(at,kt)),Un},V.prototype.catch=function(je){return this.then(void 0,je)},V.prototype.J=function(je,at){function ge(){switch(Lt.h){case 1:je(Lt.i);break;case 2:at(Lt.i);break;default:throw Error("Unexpected state: "+Lt.h)}}var Lt=this;null==this.g?ct.h(ge):this.g.push(ge),this.o=!0},V.resolve=he,V.reject=function(je){return new V(function(at,ge){ge(je)})},V.race=function(je){return new V(function(at,ge){for(var Lt=F(je),kt=Lt.next();!kt.done;kt=Lt.next())he(kt.value).J(at,ge)})},V.all=function(je){var at=F(je),ge=at.next();return ge.done?he([]):new V(function(Lt,kt){function Un(g){return function(C){v[g]=C,0==--p&&Lt(v)}}var v=[],p=0;do{v.push(void 0),p++,he(ge.value).J(Un(v.length-1),kt),ge=at.next()}while(!ge.done)})},V}),te("Object.is",function(_){return _||function(V,U){return V===U?0!==V||1/V==1/U:V!=V&&U!=U}}),te("Array.prototype.includes",function(_){return _||function(V,U){var he=this;he instanceof String&&(he=String(he));var qe=he.length;for(0>(U=U||0)&&(U=Math.max(U+qe,0));U<qe;U++){var ct=he[U];if(ct===V||Object.is(ct,V))return!0}return!1}}),te("String.prototype.includes",function(_){return _||function(V,U){if(null==this)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(V instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return-1!==this.indexOf(V,U||0)}}),te("Array.prototype.keys",function(_){return _||function(){return function Ce(_,V){_ instanceof String&&(_+="");var U=0,he=!1,qe={next:function(){if(!he&&U<_.length){var ct=U++;return{value:V(ct,_[ct]),done:!1}}return he=!0,{done:!0,value:void 0}}};return qe[Symbol.iterator]=function(){return qe},qe}(this,function(V){return V})}});var $=this||self;function se(_,V){_=_.split(".");var he,U=$;_[0]in U||typeof U.execScript>"u"||U.execScript("var "+_[0]);for(;_.length&&(he=_.shift());)_.length||void 0===V?U=U[he]&&U[he]!==Object.prototype[he]?U[he]:U[he]={}:U[he]=V}function be(_,V){return V=String.fromCharCode.apply(null,V),null==_?V:_+V}var ce,He,x=typeof TextDecoder<"u",Me=typeof TextEncoder<"u";function We(_){if(Me)_=(He||(He=new TextEncoder)).encode(_);else{var V=void 0;V=void 0!==V&&V;for(var U=0,he=new Uint8Array(3*_.length),qe=0;qe<_.length;qe++){var ct=_.charCodeAt(qe);if(128>ct)he[U++]=ct;else{if(2048>ct)he[U++]=ct>>6|192;else{if(55296<=ct&&57343>=ct){if(56319>=ct&&qe<_.length){var je=_.charCodeAt(++qe);if(56320<=je&&57343>=je){he[U++]=(ct=1024*(ct-55296)+je-56320+65536)>>18|240,he[U++]=ct>>12&63|128,he[U++]=ct>>6&63|128,he[U++]=63&ct|128;continue}qe--}if(V)throw Error("Found an unpaired surrogate");ct=65533}he[U++]=ct>>12|224,he[U++]=ct>>6&63|128}he[U++]=63&ct|128}}_=he.subarray(0,U)}return _}var nt={},et=null;function Ve(_,V){void 0===V&&(V=0),Zt(),V=nt[V];for(var U=Array(Math.floor(_.length/3)),he=V[64]||"",qe=0,ct=0;qe<_.length-2;qe+=3){var je=_[qe],at=_[qe+1],ge=_[qe+2],Lt=V[je>>2];U[ct++]=Lt+(je=V[(3&je)<<4|at>>4])+(at=V[(15&at)<<2|ge>>6])+(ge=V[63&ge])}switch(Lt=0,ge=he,_.length-qe){case 2:ge=V[(15&(Lt=_[qe+1]))<<2]||he;case 1:U[ct]=V[(_=_[qe])>>2]+V[(3&_)<<4|Lt>>4]+ge+he}return U.join("")}function Zt(){if(!et){et={};for(var _="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),V=["+/=","+/","-_=","-_.","-_"],U=0;5>U;U++){var he=_.concat(V[U].split(""));nt[U]=he;for(var qe=0;qe<he.length;qe++){var ct=he[qe];void 0===et[ct]&&(et[ct]=qe)}}}}var Mn,yn="function"==typeof Uint8Array.prototype.slice;function cr(_,V,U){return V===U?Mn||(Mn=new Uint8Array(0)):yn?_.slice(V,U):new Uint8Array(_.subarray(V,U))}var kn=0;function un(_,V){V=void 0!==(V=void 0===V?{}:V).v&&V.v,this.h=null,this.g=this.j=this.l=0,this.m=!1,this.v=V,_&&Fn(this,_)}function Fn(_,V){V=V.constructor===Uint8Array?V:V.constructor===ArrayBuffer||V.constructor===Array?new Uint8Array(V):V.constructor===String?function Ft(_){var V=_.length,U=3*V/4;U%3?U=Math.floor(U):-1!="=.".indexOf(_[V-1])&&(U=-1!="=.".indexOf(_[V-2])?U-2:U-1);var he=new Uint8Array(U),qe=0;return function Yt(_,V){function U(ge){for(;he<_.length;){var Lt=_.charAt(he++),kt=et[Lt];if(null!=kt)return kt;if(!/^[\s\xa0]*$/.test(Lt))throw Error("Unknown base64 encoding at char: "+Lt)}return ge}Zt();for(var he=0;;){var qe=U(-1),ct=U(0),je=U(64),at=U(64);if(64===at&&-1===qe)break;V(qe<<2|ct>>4),64!=je&&(V(ct<<4&240|je>>2),64!=at&&V(je<<6&192|at))}}(_,function(ct){he[qe++]=ct}),he.subarray(0,qe)}(V):V instanceof Uint8Array?new Uint8Array(V.buffer,V.byteOffset,V.byteLength):new Uint8Array(0),_.h=V,_.l=0,_.j=_.h.length,_.g=_.l}function ds(_){for(var V=128,U=0,he=0,qe=0;4>qe&&128<=V;qe++)U|=(127&(V=_.h[_.g++]))<<7*qe;if(128<=V&&(U|=(127&(V=_.h[_.g++]))<<28,he|=(127&V)>>4),128<=V)for(qe=0;5>qe&&128<=V;qe++)he|=(127&(V=_.h[_.g++]))<<7*qe+3;if(128>V)return _=U>>>0,(he=2147483648&(V=he>>>0))&&(V=~V>>>0,0==(_=1+~_>>>0)&&(V=V+1>>>0)),_=4294967296*V+(_>>>0),he?-_:_;_.m=!0}un.prototype.reset=function(){this.g=this.l},un.prototype.i=function(){var _=this.h,V=_[this.g],U=127&V;return 128>V?(this.g+=1,U):(U|=(127&(V=_[this.g+1]))<<7,128>V?(this.g+=2,U):(U|=(127&(V=_[this.g+2]))<<14,128>V?(this.g+=3,U):(U|=(127&(V=_[this.g+3]))<<21,128>V?(this.g+=4,U):(U|=(15&(V=_[this.g+4]))<<28,128>V?(this.g+=5,U>>>0):(this.g+=5,128<=_[this.g++]&&128<=_[this.g++]&&128<=_[this.g++]&&128<=_[this.g++]&&this.g++,U)))))},un.prototype.o=function(){var _=this.h[this.g],V=this.h[this.g+1],U=this.h[this.g+2],he=this.h[this.g+3];return this.g+=4,_=2*((U=(_<<0|V<<8|U<<16|he<<24)>>>0)>>31)+1,V=U>>>23&255,U&=8388607,255==V?U?NaN:1/0*_:0==V?_*Math.pow(2,-149)*U:_*Math.pow(2,V-150)*(U+Math.pow(2,23))};var Zn=[];function Ne(){this.g=new Uint8Array(64),this.h=0}function rt(_,V){for(;127<V;)_.push(127&V|128),V>>>=7;_.push(V)}function lt(_){var V={},U=void 0!==V.N&&V.N;this.o={v:void 0!==V.v&&V.v},this.N=U,V=this.o,Zn.length?(U=Zn.pop(),V&&(U.v=V.v),_&&Fn(U,_),_=U):_=new un(_,V),this.g=_,this.m=this.g.g,this.h=this.i=this.l=-1,this.j=!1}function Nt(_){var V=_.g;if((V=V.g==V.j)||(V=_.j)||(V=(V=_.g).m||0>V.g||V.g>V.j),V)return!1;_.m=_.g.g;var U=7&(V=_.g.i());return 0!=U&&5!=U&&1!=U&&2!=U&&3!=U&&4!=U?(_.j=!0,!1):(_.i=V,_.l=V>>>3,_.h=U,!0)}function wn(_){switch(_.h){case 0:if(0!=_.h)wn(_);else{for(_=_.g;128&_.h[_.g];)_.g++;_.g++}break;case 1:1!=_.h?wn(_):(_=_.g).g+=8;break;case 2:if(2!=_.h)wn(_);else{var V=_.g.i();(_=_.g).g+=V}break;case 5:5!=_.h?wn(_):(_=_.g).g+=4;break;case 3:for(V=_.l;;){if(!Nt(_)){_.j=!0;break}if(4==_.h){_.l!=V&&(_.j=!0);break}wn(_)}break;default:_.j=!0}}function zn(_,V,U){var he=_.g.j,qe=_.g.i(),ct=_.g.g+qe;if(_.g.j=ct,U(V,_),0!=(U=ct-_.g.g))throw Error("Message parsing ended unexpectedly. Expected to read "+qe+" bytes, instead read "+(qe-U)+" bytes, either the data ended unexpectedly or the message misreported its own length");return _.g.g=ct,_.g.j=he,V}function Jn(_){return _.g.o()}function wr(_){var he,V=_.g.i(),U=(_=_.g).g;if(_.g+=V,_=_.h,x)(he=ce)||(he=ce=new TextDecoder("utf-8",{fatal:!1})),he=he.decode(_.subarray(U,U+V));else{V=U+V;for(var je,at,ge,qe=[],ct=null;U<V;)128>(je=_[U++])?qe.push(je):224>je?U>=V?qe.push(65533):(at=_[U++],194>je||128!=(192&at)?(U--,qe.push(65533)):qe.push((31&je)<<6|63&at)):240>je?U>=V-1?qe.push(65533):128!=(192&(at=_[U++]))||224===je&&160>at||237===je&&160<=at||128!=(192&(he=_[U++]))?(U--,qe.push(65533)):qe.push((15&je)<<12|(63&at)<<6|63&he):244>=je?U>=V-2?qe.push(65533):128!=(192&(at=_[U++]))||at-144+(je<<28)>>30||128!=(192&(he=_[U++]))||128!=(192&(ge=_[U++]))?(U--,qe.push(65533)):(je=(7&je)<<18|(63&at)<<12|(63&he)<<6|63&ge,qe.push(55296+((je-=65536)>>10&1023),56320+(1023&je))):qe.push(65533),8192<=qe.length&&(ct=be(ct,qe),qe.length=0);he=be(ct,qe)}return he}function $r(_,V,U){var he=_.g.i();for(he=_.g.g+he;_.g.g<he;)U.push(V.call(_.g))}function _r(_,V){2==_.h?$r(_,un.prototype.o,V):V.push(Jn(_))}function qs(){this.h=[],this.i=0,this.g=new Ne}function Ys(_,V){0!==V.length&&(_.h.push(V),_.i+=V.length)}function Yo(_){var V=_.i+_.g.length();if(0===V)return new Uint8Array(0);V=new Uint8Array(V);for(var U=_.h,he=U.length,qe=0,ct=0;ct<he;ct++){var je=U[ct];0!==je.length&&(V.set(je,qe),qe+=je.length)}return 0!==(he=(U=_.g).h)&&(V.set(U.g.subarray(0,he),qe),U.h=0),_.h=[V],V}function Fr(_,V,U){if(null!=U){rt(_.g,8*V+5),_=_.g;var he=U;0===(he=(U=0>he?1:0)?-he:he)?kn=0<1/he?0:2147483648:isNaN(he)?kn=2147483647:34028234663852886e22<he?kn=(U<<31|2139095040)>>>0:11754943508222875e-54>he?(he=Math.round(he/Math.pow(2,-149)),kn=(U<<31|he)>>>0):(V=Math.floor(Math.log(he)/Math.LN2),he*=Math.pow(2,-V),16777216<=(he=Math.round(8388608*he))&&++V,kn=(U<<31|V+127<<23|8388607&he)>>>0),_.push((U=kn)>>>0&255),_.push(U>>>8&255),_.push(U>>>16&255),_.push(U>>>24&255)}}Ne.prototype.push=function(_){if(!(this.h+1<this.g.length)){var V=this.g;this.g=new Uint8Array(Math.ceil(1+2*this.g.length)),this.g.set(V)}this.g[this.h++]=_},Ne.prototype.length=function(){return this.h},Ne.prototype.end=function(){var _=this.g,V=this.h;return this.h=0,cr(_,0,V)},lt.prototype.reset=function(){this.g.reset(),this.h=this.l=-1};var go="function"==typeof Uint8Array;function os(_,V,U){if(null!=_)return"object"==typeof _?go&&_ instanceof Uint8Array?U(_):is(_,V,U):V(_)}function is(_,V,U){if(Array.isArray(_)){for(var he=Array(_.length),qe=0;qe<_.length;qe++)he[qe]=os(_[qe],V,U);return Array.isArray(_)&&_.W&&Zs(he),he}for(qe in he={},_)he[qe]=os(_[qe],V,U);return he}function Zo(_){return"number"==typeof _?isFinite(_)?_:String(_):_}var oo,bi={W:{value:!0,configurable:!0}};function Zs(_){return Array.isArray(_)&&!Object.isFrozen(_)&&Object.defineProperties(_,bi),_}function mr(_,V,U){var he=oo;if(oo=null,_||(_=he),he=this.constructor.ca,_||(_=he?[he]:[]),this.j=he?0:-1,this.m=this.g=null,this.h=_,_=(he=this.h.length)-1,!he||null===(he=this.h[_])||"object"!=typeof he||Array.isArray(he)||go&&he instanceof Uint8Array?void 0!==V&&-1<V?(this.l=Math.max(V,_+1-this.j),this.i=null):this.l=Number.MAX_VALUE:(this.l=_-this.j,this.i=he),U)for(V=0;V<U.length;V++)(_=U[V])<this.l?(he=this.h[_+=this.j])?Zs(he):this.h[_]=Qo:(Ao(this),(he=this.i[_])?Zs(he):this.i[_]=Qo)}var Qo=Object.freeze(Zs([]));function Ao(_){var V=_.l+_.j;_.h[V]||(_.i=_.h[V]={})}function nr(_,V,U){return-1===V?null:void 0!==U&&U||V>=_.l?_.i?_.i[V]:void 0:_.h[V+_.j]}function Ro(_,V){var U=void 0!==U&&U,he=nr(_,V,U);return null==he&&(he=Qo),he===Qo&&Bn(_,V,he=Zs([]),U),he}function Re(_){var V=Ro(_,3);if(_.m||(_.m={}),!_.m[3]){for(var U=0;U<V.length;U++)V[U]=+V[U];_.m[3]=!0}return V}function Ur(_,V,U){return(_=nr(_,V))??U}function Hn(_,V,U){return(_=null==(_=nr(_,V))?_:+_)??(void 0===U?0:U)}function Bn(_,V,U,he){void 0!==he&&he||V>=_.l?(Ao(_),_.i[V]=U):_.h[V+_.j]=U}function hr(_,V,U){if(-1===U)return null;if(_.g||(_.g={}),!_.g[U]){var he=nr(_,U,!1);he&&(_.g[U]=new V(he))}return _.g[U]}function Ir(_,V){_.g||(_.g={});var U=_.g[1];if(!U){var he=Ro(_,1);U=[];for(var qe=0;qe<he.length;qe++)U[qe]=new V(he[qe]);_.g[1]=U}return U}function Pr(_,V,U){var he=void 0!==he&&he;_.g||(_.g={});var qe=U&&sn(U,!1);_.g[V]=U,Bn(_,V,qe,he)}function ws(_,V,U,he){var qe=Ir(_,U);V=V||new U,_=Ro(_,1),null!=he?(qe.splice(he,0,V),_.splice(he,0,sn(V,!1))):(qe.push(V),_.push(sn(V,!1)))}function sn(_,V){if(_.g)for(var U in _.g){var he=_.g[U];if(Array.isArray(he))for(var qe=0;qe<he.length;qe++)he[qe]&&sn(he[qe],V);else he&&sn(he,V)}return _.h}function io(_,V){if(_=_.o){Ys(V,V.g.end());for(var U=0;U<_.length;U++)Ys(V,_[U])}}function Gr(_,V){if(4==V.h)return!1;var U=V.m;return wn(V),V.N||(V=cr(V.g.h,U,V.g.g),(U=_.o)?U.push(V):_.o=[V]),!0}function Cs(_){mr.call(this,_,-1,Pt)}function Vi(_,V){for(;Nt(V);)switch(V.i){case 8:var U=V.g.i();Bn(_,1,U);break;case 16:Bn(_,2,U=V.g.i());break;case 29:case 26:_r(V,_.getPackedDataList());break;case 32:Bn(_,4,U=ds(V.g));break;default:if(!Gr(_,V))return _}return _}mr.prototype.toJSON=function(){return is(sn(this,!1),Zo,Ve)},mr.prototype.toString=function(){return sn(this,!1).toString()},de(Cs,mr),Cs.prototype.getRows=function(){return nr(this,1)},Cs.prototype.getCols=function(){return nr(this,2)},Cs.prototype.getPackedDataList=function(){return Re(this)},Cs.prototype.getLayout=function(){return Ur(this,4,0)};var Pt=[3];function Lr(_,V){var U=void 0;return new(U||(U=Promise))(function(he,qe){function ct(ge){try{at(V.next(ge))}catch(Lt){qe(Lt)}}function je(ge){try{at(V.throw(ge))}catch(Lt){qe(Lt)}}function at(ge){ge.done?he(ge.value):new U(function(Lt){Lt(ge.value)}).then(ct,je)}at((V=V.apply(_,void 0)).next())})}function pn(_){mr.call(this,_)}function rr(_,V){for(;Nt(V);)switch(V.i){case 8:var U=V.g.i();Bn(_,1,U);break;case 21:Bn(_,2,U=Jn(V));break;case 26:Bn(_,3,U=wr(V));break;case 34:Bn(_,4,U=wr(V));break;default:if(!Gr(_,V))return _}return _}function yo(_){mr.call(this,_,-1,$a)}de(pn,mr),de(yo,mr),yo.prototype.addClassification=function(_,V){return ws(this,_,pn,V),this};var $a=[1];function Oo(_){mr.call(this,_)}function Us(_,V){for(;Nt(V);)switch(V.i){case 13:var U=Jn(V);Bn(_,1,U);break;case 21:Bn(_,2,U=Jn(V));break;case 29:Bn(_,3,U=Jn(V));break;case 37:Bn(_,4,U=Jn(V));break;case 45:Bn(_,5,U=Jn(V));break;default:if(!Gr(_,V))return _}return _}function hs(_){mr.call(this,_,-1,Fa)}function Ui(_){e:{var V=new hs;for(_=new lt(_);Nt(_);)if(10===_.i)ws(V,zn(_,new Oo,Us),Oo,void 0);else if(!Gr(V,_))break e}return V}de(Oo,mr),de(hs,mr);var Fa=[1];function ha(_){mr.call(this,_)}function ts(_){mr.call(this,_,-1,Pa)}function wi(_,V){for(;Nt(V);)switch(V.i){case 8:var U=ds(V.g);Bn(_,1,U);break;case 16:Bn(_,2,U=ds(V.g));break;case 29:case 26:_r(V,_.getVertexBufferList());break;case 32:case 34:U=V;var he=_.getIndexBufferList();2==U.h?$r(U,un.prototype.i,he):he.push(U.g.i());break;default:if(!Gr(_,V))return _}return _}de(ha,mr),de(ts,mr),ts.prototype.getVertexType=function(){return Ur(this,1,0)},ts.prototype.getPrimitiveType=function(){return Ur(this,2,0)},ts.prototype.getVertexBufferList=function(){return Re(this)},ts.prototype.getIndexBufferList=function(){return Ro(this,4)};var Pa=[3,4];function Wi(_){mr.call(this,_)}function zi(_,V,U){if(U=_.createShader(0===U?_.VERTEX_SHADER:_.FRAGMENT_SHADER),_.shaderSource(U,V),_.compileShader(U),!_.getShaderParameter(U,_.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+_.getShaderInfoLog(U));return U}function La(_){return Ir(_,pn).map(function(V){return{index:Ur(V,1,0),Y:Hn(V,2),label:null!=nr(V,3)?Ur(V,3,""):void 0,displayName:null!=nr(V,4)?Ur(V,4,""):void 0}})}function fa(_){return{x:Hn(_,1),y:Hn(_,2),z:Hn(_,3),visibility:null!=nr(_,4)?Hn(_,4):void 0}}function Hi(_,V){this.h=_,this.g=V,this.l=0}function as(_,V,U){return function Qn(_,V){var U=_.g;if(void 0===_.m){var he=zi(U,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),qe=zi(U,"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),ct=U.createProgram();if(U.attachShader(ct,he),U.attachShader(ct,qe),U.linkProgram(ct),!U.getProgramParameter(ct,U.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+U.getProgramInfoLog(ct));he=_.m=ct,U.useProgram(he),qe=U.getUniformLocation(he,"sampler0"),_.j={I:U.getAttribLocation(he,"aVertex"),H:U.getAttribLocation(he,"aTex"),da:qe},_.s=U.createBuffer(),U.bindBuffer(U.ARRAY_BUFFER,_.s),U.enableVertexAttribArray(_.j.I),U.vertexAttribPointer(_.j.I,2,U.FLOAT,!1,0,0),U.bufferData(U.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),U.STATIC_DRAW),U.bindBuffer(U.ARRAY_BUFFER,null),_.o=U.createBuffer(),U.bindBuffer(U.ARRAY_BUFFER,_.o),U.enableVertexAttribArray(_.j.H),U.vertexAttribPointer(_.j.H,2,U.FLOAT,!1,0,0),U.bufferData(U.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),U.STATIC_DRAW),U.bindBuffer(U.ARRAY_BUFFER,null),U.uniform1i(qe,0)}he=_.j,U.useProgram(_.m),U.canvas.width=V.width,U.canvas.height=V.height,U.viewport(0,0,V.width,V.height),U.activeTexture(U.TEXTURE0),_.h.bindTexture2d(V.glName),U.enableVertexAttribArray(he.I),U.bindBuffer(U.ARRAY_BUFFER,_.s),U.vertexAttribPointer(he.I,2,U.FLOAT,!1,0,0),U.enableVertexAttribArray(he.H),U.bindBuffer(U.ARRAY_BUFFER,_.o),U.vertexAttribPointer(he.H,2,U.FLOAT,!1,0,0),U.bindFramebuffer(U.DRAW_FRAMEBUFFER?U.DRAW_FRAMEBUFFER:U.FRAMEBUFFER,null),U.clearColor(0,0,0,0),U.clear(U.COLOR_BUFFER_BIT),U.colorMask(!0,!0,!0,!0),U.drawArrays(U.TRIANGLE_FAN,0,4),U.disableVertexAttribArray(he.I),U.disableVertexAttribArray(he.H),U.bindBuffer(U.ARRAY_BUFFER,null),_.h.bindTexture2d(0)}(_,V),"function"==typeof _.g.canvas.transferToImageBitmap?Promise.resolve(_.g.canvas.transferToImageBitmap()):U?Promise.resolve(_.g.canvas):"function"==typeof createImageBitmap?createImageBitmap(_.g.canvas):(void 0===_.i&&(_.i=document.createElement("canvas")),new Promise(function(he){_.i.height=_.g.canvas.height,_.i.width=_.g.canvas.width,_.i.getContext("2d",{}).drawImage(_.g.canvas,0,0,_.g.canvas.width,_.g.canvas.height),he(_.i)}))}function hu(_){this.g=_}de(Wi,mr),Wi.prototype.getMesh=function(){return hr(this,ts,1)},Wi.prototype.getPoseTransformMatrix=function(){return hr(this,Cs,2)};var ji=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function fu(_,V){return V+_}function vn(_,V){window[_]=V}function Dr(_){if(this.g=_,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=_&&_.locateFile||fu,"object"==typeof window)var V=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if(!(typeof location<"u"))throw Error("solutions can only be loaded on a web page or in a web worker");V=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.S=V,_.options)for(var U=(V=F(Object.keys(_.options))).next();!U.done;U=V.next()){var he=_.options[U=U.value].default;void 0!==he&&(this.j[U]="function"==typeof he?he():he)}}function Ss(_,V){return Lr(_,function U(){var qe,ct,he=this;return $e(U,function(je){return V in he.F?je.return(he.F[V]):(qe=he.locateFile(V,""),ct=fetch(qe).then(function(at){return at.arrayBuffer()}),he.F[V]=ct,je.return(ct))})})}function Ki(_,V){for(var U=V.name||"$",he=[].concat(j(V.wants)),qe=new _.h.StringList,ct=F(V.wants),je=ct.next();!je.done;je=ct.next())qe.push_back(je.value);ct=_.h.PacketListener.implement({onResults:function(at){for(var ge={},Lt=0;Lt<V.wants.length;++Lt)ge[he[Lt]]=at.get(Lt);var kt=_.listeners[U];kt&&(_.C=function Mo(_,V,U){return Lr(_,function he(){var qe,ct,je,at,Lt,Un,v,p,g,C,K,ae,kt=this;return $e(he,function(oe){switch(oe.g){case 1:if(!U)return oe.return(V);for(qe={},ct=0,je=F(Object.keys(U)),at=je.next();!at.done;at=je.next())"string"!=typeof(Lt=U[at.value])&&"texture"===Lt.type&&void 0!==V[Lt.stream]&&++ct;1<ct&&(kt.G=!1),Un=F(Object.keys(U)),at=Un.next();case 2:if(at.done){oe.g=4;break}if("string"==typeof(p=U[v=at.value]))return K=qe,ae=v,ot(oe,function Gi(_,V,U){return Lr(_,function he(){var ct,qe=this;return $e(he,function(je){return"number"==typeof U||U instanceof Uint8Array||U instanceof qe.h.Uint8BlobList?je.return(U):U instanceof qe.h.Texture2dDataOut?((ct=qe.s[V])||(ct=new Hi(qe.h,qe.D),qe.s[V]=ct),je.return(as(ct,U,qe.G))):je.return(void 0)})})}(kt,v,V[p]),14);if(g=V[p.stream],"detection_list"===p.type){if(g){for(var Ue=g.getRectList(),ut=g.getLandmarksList(),tt=g.getClassificationsList(),Je=[],bt=0;bt<Ue.size();++bt){var Wt=Ue.get(bt);e:{var Gt=new ha;for(Wt=new lt(Wt);Nt(Wt);)switch(Wt.i){case 13:var Ht=Jn(Wt);Bn(Gt,1,Ht);break;case 21:Bn(Gt,2,Ht=Jn(Wt));break;case 29:Bn(Gt,3,Ht=Jn(Wt));break;case 37:Bn(Gt,4,Ht=Jn(Wt));break;case 45:Bn(Gt,5,Ht=Jn(Wt));break;case 48:Bn(Gt,6,Ht=ds(Wt.g));break;default:if(!Gr(Gt,Wt))break e}}Gt={Z:Hn(Gt,1),$:Hn(Gt,2),height:Hn(Gt,3),width:Hn(Gt,4),rotation:Hn(Gt,5,0),X:Ur(Gt,6,0)},Wt=Ir(Ui(ut.get(bt)),Oo).map(fa);var ln=tt.get(bt);e:for(Ht=new yo,ln=new lt(ln);Nt(ln);)if(10===ln.i)Ht.addClassification(zn(ln,new pn,rr));else if(!Gr(Ht,ln))break e;Gt={T:Gt,O:Wt,M:La(Ht)},Je.push(Gt)}Ue=Je}else Ue=[];qe[v]=Ue,oe.g=7;break}if("proto_list"===p.type){if(g){for(Ue=Array(g.size()),ut=0;ut<g.size();ut++)Ue[ut]=g.get(ut);g.delete()}else Ue=[];qe[v]=Ue,oe.g=7;break}if(void 0===g){oe.g=3;break}if("float_list"===p.type){qe[v]=g,oe.g=7;break}if("proto"===p.type){qe[v]=g,oe.g=7;break}if("texture"!==p.type)throw Error("Unknown output config type: '"+p.type+"'");return(C=kt.s[v])||(C=new Hi(kt.h,kt.D),kt.s[v]=C),ot(oe,as(C,g,kt.G),13);case 13:qe[v]=oe.h;case 7:p.transform&&qe[v]&&(qe[v]=p.transform(qe[v])),oe.g=3;break;case 14:K[ae]=oe.h;case 3:at=Un.next(),oe.g=2;break;case 4:return oe.return(qe)}})})}(_,ge,V.outs).then(function(Un){Un=kt(Un);for(var v=0;v<V.wants.length;++v){var p=ge[he[v]];"object"==typeof p&&p.hasOwnProperty&&p.hasOwnProperty("delete")&&p.delete()}Un&&(_.C=Un)}))}}),_.i.attachMultiListener(qe,ct),qe.delete()}function mn(_){_=function Jo(_){e:{var V=new Wi;for(_=new lt(_);Nt(_);)switch(_.i){case 10:var U=zn(_,new ts,wi);Pr(V,1,U);break;case 18:Pr(V,2,U=zn(_,new Cs,Vi));break;default:if(!Gr(V,_))break e}}return V}(_);var V=_.getMesh();if(!V)return _;var U=new Float32Array(V.getVertexBufferList());V.getVertexBufferList=function(){return U};var he=new Uint32Array(V.getIndexBufferList());return V.getIndexBufferList=function(){return he},_}(gt=Dr.prototype).close=function(){return this.i&&this.i.delete(),Promise.resolve()},gt.reset=function(){return Lr(this,function _(){var V=this;return $e(_,function(U){V.i&&(V.i.reset(),V.m={},V.s={}),U.g=0})})},gt.setOptions=function(_,V){var U=this;if(V=V||this.g.options){for(var he=[],qe=[],ct={},je=F(Object.keys(_)),at=je.next();!at.done;ct={K:ct.K,L:ct.L},at=je.next()){var ge=at.value;ge in this.j&&this.j[ge]===_[ge]||(this.j[ge]=_[ge],void 0!==(at=V[ge])&&(at.onChange&&(ct.K=at.onChange,ct.L=_[ge],he.push(function(Lt){return function(){return Lr(U,function kt(){var v=this;return $e(kt,function(p){if(1==p.g)return ot(p,Lt.K(Lt.L),2);!0===p.h&&(v.o=!0),p.g=0})})}}(ct))),at.graphOptionXref&&(ge={valueNumber:1===at.type?_[ge]:0,valueBoolean:0===at.type&&_[ge],valueString:2===at.type?_[ge]:""},at=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),at.graphOptionXref),ge),qe.push(at))))}(0!==he.length||0!==qe.length)&&(this.o=!0,this.A=(void 0===this.A?[]:this.A).concat(qe),this.u=(void 0===this.u?[]:this.u).concat(he))}},gt.initialize=function(){return Lr(this,function _(){var V=this;return $e(_,function(U){return 1==U.g?ot(U,function Ci(_){return Lr(_,function V(){var he,qe,ct,je,at,ge,Lt,kt,Un,v,p,U=this;return $e(V,function(g){switch(g.g){case 1:return he=U,U.R?(qe=function Br(_,V){return void 0===_.g.files?[]:"function"==typeof _.g.files?_.g.files(V):_.g.files}(U,U.j),ot(g,function Ws(){return Lr(this,function _(){return $e(_,function(V){switch(V.g){case 1:return V.m=2,ot(V,WebAssembly.instantiate(ji),4);case 4:V.g=3,V.m=0;break;case 2:return V.m=0,V.j=null,V.return(!1);case 3:return V.return(!0)}})})}(),2)):g.return();case 2:if(ct=g.h,"object"==typeof window)return vn("createMediapipeSolutionsWasm",{locateFile:U.locateFile}),vn("createMediapipeSolutionsPackedAssets",{locateFile:U.locateFile}),ge=qe.filter(function(C){return void 0!==C.data}),Lt=qe.filter(function(C){return void 0===C.data}),kt=Promise.all(ge.map(function(C){var G=Ss(he,C.url);if(void 0!==C.path){var K=C.path;G=G.then(function(ae){return he.overrideFile(K,ae),Promise.resolve(ae)})}return G})),Un=Promise.all(Lt.map(function(C){return void 0===C.simd||C.simd&&ct||!C.simd&&!ct?function Ba(_){var V=document.createElement("script");return V.setAttribute("src",_),V.setAttribute("crossorigin","anonymous"),new Promise(function(U){V.addEventListener("load",function(){U()},!1),V.addEventListener("error",function(){U()},!1),document.body.appendChild(V)})}(he.locateFile(C.url,he.S)):Promise.resolve()})).then(function(){return Lr(he,function C(){var G,K,ae=this;return $e(C,function(oe){if(1==oe.g)return G=window.createMediapipeSolutionsWasm,K=window.createMediapipeSolutionsPackedAssets,ot(oe,G(K),2);ae.h=oe.h,oe.g=0})})}),v=Lr(he,function C(){var G=this;return $e(C,function(K){return G.g.graph&&G.g.graph.url?K=ot(K,Ss(G,G.g.graph.url),0):(K.g=0,K=void 0),K})}),ot(g,Promise.all([Un,kt,v]),7);if("function"!=typeof importScripts)throw Error("solutions can only be loaded on a web page or in a web worker");return je=qe.filter(function(C){return void 0===C.simd||C.simd&&ct||!C.simd&&!ct}).map(function(C){return he.locateFile(C.url,he.S)}),importScripts.apply(null,j(je)),ot(g,createMediapipeSolutionsWasm(Module),6);case 6:U.h=g.h,U.l=new OffscreenCanvas(1,1),U.h.canvas=U.l,at=U.h.GL.createContext(U.l,{antialias:!1,alpha:!1,ba:typeof WebGL2RenderingContext<"u"?2:1}),U.h.GL.makeContextCurrent(at),g.g=4;break;case 7:if(U.l=document.createElement("canvas"),!(p=U.l.getContext("webgl2",{}))&&!(p=U.l.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),g.return();U.D=p,U.h.canvas=U.l,U.h.createContext(U.l,!0,!0,{});case 4:U.i=new U.h.SolutionWasm,U.R=!1,g.g=0}})})}(V),2):3!=U.g?ot(U,function Si(_){return Lr(_,function V(){var qe,ct,je,at,ge,kt,U=this;return $e(V,function(Un){if(1==Un.g)return U.g.graph&&U.g.graph.url&&U.P===U.g.graph.url?Un.return():(U.o=!0,U.g.graph&&U.g.graph.url?(U.P=U.g.graph.url,ot(Un,Ss(U,U.g.graph.url),3)):void(Un.g=2));for(2!=Un.g&&U.i.loadGraph(Un.h),qe=F(Object.keys(U.B)),ct=qe.next();!ct.done;ct=qe.next())U.i.overrideFile(je=ct.value,U.B[je]);if(U.B={},U.g.listeners)for(at=F(U.g.listeners),ge=at.next();!ge.done;ge=at.next())Ki(U,ge.value);kt=U.j,U.j={},U.setOptions(kt),Un.g=0})})}(V),3):ot(U,function pa(_){return Lr(_,function V(){var he,qe,je,at,ge,U=this;return $e(V,function(kt){switch(kt.g){case 1:if(!U.o)return kt.return();if(!U.u){kt.g=2;break}he=F(U.u),qe=he.next();case 3:if(qe.done){kt.g=5;break}return ot(kt,(0,qe.value)(),4);case 4:qe=he.next(),kt.g=3;break;case 5:U.u=void 0;case 2:if(U.A){for(je=new U.h.GraphOptionChangeRequestList,at=F(U.A),ge=at.next();!ge.done;ge=at.next())je.push_back(ge.value);U.i.changeOptions(je),je.delete(),U.A=void 0}U.o=!1,kt.g=0}})})}(V),0)})})},gt.overrideFile=function(_,V){this.i?this.i.overrideFile(_,V):this.B[_]=V},gt.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},gt.send=function(_,V){return Lr(this,function U(){var qe,ct,je,at,ge,Lt,kt,Un,v,he=this;return $e(U,function(p){switch(p.g){case 1:return he.g.inputs?(qe=1e3*(V??performance.now()),ot(p,he.C,2)):p.return();case 2:return ot(p,he.initialize(),3);case 3:for(ct=new he.h.PacketDataList,je=F(Object.keys(_)),at=je.next();!at.done;at=je.next())if(Lt=he.g.inputs[ge=at.value]){e:{var g=he,C=_[ge];switch(Lt.type){case"video":var G=g.m[Lt.stream];if(G||(G=new Hi(g.h,g.D),g.m[Lt.stream]=G),0===(g=G).l&&(g.l=g.h.createTexture()),typeof HTMLVideoElement<"u"&&C instanceof HTMLVideoElement){var K=C.videoWidth;G=C.videoHeight}else typeof HTMLImageElement<"u"&&C instanceof HTMLImageElement?(K=C.naturalWidth,G=C.naturalHeight):(K=C.width,G=C.height);G={glName:g.l,width:K,height:G},(K=g.g).canvas.width=G.width,K.canvas.height=G.height,K.activeTexture(K.TEXTURE0),g.h.bindTexture2d(g.l),K.texImage2D(K.TEXTURE_2D,0,K.RGBA,K.RGBA,K.UNSIGNED_BYTE,C),g.h.bindTexture2d(0),g=G;break e;case"detections":for((G=g.m[Lt.stream])||(G=new hu(g.h),g.m[Lt.stream]=G),(g=G).data||(g.data=new g.g.DetectionListData),g.data.reset(C.length),G=0;G<C.length;++G){var ae=g.data,oe=ae.setBoundingBox,Ue=G,ut=(K=C[G]).T,tt=new ha;Bn(tt,1,ut.Z),Bn(tt,2,ut.$),Bn(tt,3,ut.height),Bn(tt,4,ut.width),Bn(tt,5,ut.rotation),Bn(tt,6,ut.X);var Je=ut=new qs;Fr(Je,1,nr(tt,1)),Fr(Je,2,nr(tt,2)),Fr(Je,3,nr(tt,3)),Fr(Je,4,nr(tt,4)),Fr(Je,5,nr(tt,5));var bt=nr(tt,6);if(null!=bt&&null!=bt){rt(Je.g,48);var Wt=Je.g,Gt=bt;bt=0>Gt;var Ht=(Gt=Math.abs(Gt))>>>0;for(Gt=Math.floor((Gt-Ht)/4294967296),Gt>>>=0,bt&&(Gt=~Gt>>>0,4294967295<(Ht=1+(~Ht>>>0))&&(Ht=0,4294967295<++Gt&&(Gt=0))),bt=kn=Ht,Ht=Gt;0<Ht||127<bt;)Wt.push(127&bt|128),bt=(bt>>>7|Ht<<25)>>>0,Ht>>>=7;Wt.push(bt)}if(io(tt,Je),ut=Yo(ut),oe.call(ae,Ue,ut),K.O)for(ae=0;ae<K.O.length;++ae)Je=!!(tt=K.O[ae]).visibility,Ue=(oe=g.data).addNormalizedLandmark,ut=G,tt=Object.assign(Object.assign({},tt),{visibility:Je?tt.visibility:0}),Bn(Je=new Oo,1,tt.x),Bn(Je,2,tt.y),Bn(Je,3,tt.z),tt.visibility&&Bn(Je,4,tt.visibility),Fr(Wt=tt=new qs,1,nr(Je,1)),Fr(Wt,2,nr(Je,2)),Fr(Wt,3,nr(Je,3)),Fr(Wt,4,nr(Je,4)),Fr(Wt,5,nr(Je,5)),io(Je,Wt),tt=Yo(tt),Ue.call(oe,ut,tt);if(K.M)for(ae=0;ae<K.M.length;++ae){if(Ue=(oe=g.data).addClassification,ut=G,tt=K.M[ae],Bn(Je=new pn,2,tt.Y),tt.index&&Bn(Je,1,tt.index),tt.label&&Bn(Je,3,tt.label),tt.displayName&&Bn(Je,4,tt.displayName),Wt=tt=new qs,null!=(Ht=nr(Je,1))&&null!=Ht)if(rt(Wt.g,8),bt=Wt.g,0<=Ht)rt(bt,Ht);else{for(Gt=0;9>Gt;Gt++)bt.push(127&Ht|128),Ht>>=7;bt.push(1)}Fr(Wt,2,nr(Je,2)),null!=(bt=nr(Je,3))&&(bt=We(bt),rt(Wt.g,26),rt(Wt.g,bt.length),Ys(Wt,Wt.g.end()),Ys(Wt,bt)),null!=(bt=nr(Je,4))&&(bt=We(bt),rt(Wt.g,34),rt(Wt.g,bt.length),Ys(Wt,Wt.g.end()),Ys(Wt,bt)),io(Je,Wt),tt=Yo(tt),Ue.call(oe,ut,tt)}}g=g.data;break e;default:g={}}}switch(kt=g,Un=Lt.stream,Lt.type){case"video":ct.pushTexture2d(Object.assign(Object.assign({},kt),{stream:Un,timestamp:qe}));break;case"detections":(v=kt).stream=Un,v.timestamp=qe,ct.pushDetectionList(v);break;default:throw Error("Unknown input config type: '"+Lt.type+"'")}}return he.i.send(ct),ot(p,he.C,4);case 4:ct.delete(),p.g=0}})})},gt.onResults=function(_,V){this.listeners[V||"$"]=_},se("Solution",Dr),se("OptionType",{BOOL:0,NUMBER:1,aa:2,0:"BOOL",1:"NUMBER",2:"STRING"});var ei={files:[{url:"face_mesh_solution_packed_assets_loader.js"},{simd:!0,url:"face_mesh_solution_simd_wasm_bin.js"},{simd:!1,url:"face_mesh_solution_wasm_bin.js"}],graph:{url:"face_mesh.binarypb"},listeners:[{wants:["multi_face_geometry","image_transformed","multi_face_landmarks"],outs:{image:"image_transformed",multiFaceGeometry:{type:"proto_list",stream:"multi_face_geometry",transform:function(_){return _.map(mn)}},multiFaceLandmarks:{type:"proto_list",stream:"multi_face_landmarks",transform:function(_){return _.map(function(V){return Ir(Ui(V),Oo).map(fa)})}}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},enableFaceGeometry:{type:0,graphOptionXref:{calculatorName:"EnableFaceGeometryConstant",calculatorType:"ConstantSidePacketCalculator",fieldName:"bool_value"}},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},maxNumFaces:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorNumFaces",fieldName:"int_value"}},refineLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorRefineLandmarks",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"facelandmarkfrontgpu__facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"facelandmarkfrontgpu__facelandmarkgpu__ThresholdingCalculator",fieldName:"threshold"}},cameraNear:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"near"}},cameraFar:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"far"}},cameraVerticalFovDegrees:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"vertical_fov_degrees"}}}},Ei=[[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]],Kr=[[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]],$o=[[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]],ma=[[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]],fr=[[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]],Fo=[[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]],Va=[].concat(j(Ei),j(Kr),j($o),j(ma),j(fr),j(Fo));function ao(_){_=_||{},_=Object.assign(Object.assign({},ei),_),this.g=new Dr(_)}(gt=ao.prototype).close=function(){return this.g.close(),Promise.resolve()},gt.onResults=function(_){this.g.onResults(_)},gt.initialize=function(){return Lr(this,function _(){var V=this;return $e(_,function(U){return ot(U,V.g.initialize(),0)})})},gt.reset=function(){this.g.reset()},gt.send=function(_){return Lr(this,function V(){var U=this;return $e(V,function(he){return ot(he,U.g.send(_),0)})})},gt.setOptions=function(_){this.g.setOptions(_)},se("FACE_GEOMETRY",{Layout:{COLUMN_MAJOR:0,ROW_MAJOR:1,0:"COLUMN_MAJOR",1:"ROW_MAJOR"},PrimitiveType:{TRIANGLE:0,0:"TRIANGLE"},VertexType:{VERTEX_PT:0,0:"VERTEX_PT"},DEFAULT_CAMERA_PARAMS:{verticalFovDegrees:63,near:1,far:1e4}}),se("FaceMesh",ao),se("FACEMESH_LIPS",Ei),se("FACEMESH_LEFT_EYE",Kr),se("FACEMESH_LEFT_EYEBROW",$o),se("FACEMESH_LEFT_IRIS",[[474,475],[475,476],[476,477],[477,474]]),se("FACEMESH_RIGHT_EYE",ma),se("FACEMESH_RIGHT_EYEBROW",fr),se("FACEMESH_RIGHT_IRIS",[[469,470],[470,471],[471,472],[472,469]]),se("FACEMESH_FACE_OVAL",Fo),se("FACEMESH_CONTOURS",Va),se("FACEMESH_TESSELATION",[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]]),se("matrixDataToMatrix",function(_){for(var V=_.getCols(),U=_.getRows(),he=_.getPackedDataList(),qe=[],ct=0;ct<U;ct++)qe.push(Array(V));for(ct=0;ct<U;ct++)for(var je=0;je<V;je++){var at=1===_.getLayout()?ct*V+je:je*U+ct;qe[ct][je]=he[at]}return qe}),se("VERSION","0.4.1633559619")}).call(this)},303:(gt,Xe,M)=>{"use strict";var _e={};function we(t){return"function"==typeof t}M.r(_e),M.d(_e,{addImpl:()=>lS,bincountImpl:()=>C3,bincountReduceImpl:()=>gS,castImpl:()=>cS,ceilImpl:()=>yS,concatImpl:()=>vS,equalImpl:()=>wS,expImpl:()=>SS,expm1Impl:()=>_S,floorImpl:()=>TS,gatherNdImpl:()=>NS,gatherV2Impl:()=>kS,greaterEqualImpl:()=>RS,greaterImpl:()=>AS,lessEqualImpl:()=>MS,lessImpl:()=>OS,linSpaceImpl:()=>$S,logImpl:()=>FS,maxImpl:()=>PS,maximumImpl:()=>BS,minimumImpl:()=>VS,multiplyImpl:()=>S3,negImpl:()=>WS,notEqualImpl:()=>zS,prodImpl:()=>KS,raggedGatherImpl:()=>qS,raggedTensorToTensorImpl:()=>QS,rangeImpl:()=>JS,rsqrtImpl:()=>eE,scatterImpl:()=>Ad,sigmoidImpl:()=>E$,simpleAbsImpl:()=>hS,sliceImpl:()=>mS,sparseFillEmptyRowsImpl:()=>nE,sparseReshapeImpl:()=>rE,sparseSegmentReductionImpl:()=>N3,sqrtImpl:()=>XB,squaredDifferenceImpl:()=>sE,stridedSliceImpl:()=>oE,stringNGramsImpl:()=>iE,stringSplitImpl:()=>aE,stringToHashBucketFastImpl:()=>uE,subImpl:()=>IS,tileImpl:()=>cE,topKImpl:()=>dE,transposeImpl:()=>b3,uniqueImpl:()=>fE});let te=!1;const Q={Promise:void 0,set useDeprecatedSynchronousErrorHandling(t){if(t){const n=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+n.stack)}else te&&console.log("RxJS: Back to a better error behavior. Thank you. <3");te=t},get useDeprecatedSynchronousErrorHandling(){return te}};function F(t){setTimeout(()=>{throw t},0)}const j={closed:!0,next(t){},error(t){if(Q.useDeprecatedSynchronousErrorHandling)throw t;F(t)},complete(){}},Ie=Array.isArray||(t=>t&&"number"==typeof t.length);function me(t){return null!==t&&"object"==typeof t}const le=(()=>{function t(n){return Error.call(this),this.message=n?`${n.length} errors occurred during unsubscription:\n${n.map((e,r)=>`${r+1}) ${e.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=n,this}return t.prototype=Object.create(Error.prototype),t})();class ee{constructor(n){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,n&&(this._ctorUnsubscribe=!0,this._unsubscribe=n)}unsubscribe(){let n;if(this.closed)return;let{_parentOrParents:e,_ctorUnsubscribe:r,_unsubscribe:s,_subscriptions:o}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,e instanceof ee)e.remove(this);else if(null!==e)for(let i=0;i<e.length;++i)e[i].remove(this);if(we(s)){r&&(this._unsubscribe=void 0);try{s.call(this)}catch(i){n=i instanceof le?A(i.errors):[i]}}if(Ie(o)){let i=-1,a=o.length;for(;++i<a;){const u=o[i];if(me(u))try{u.unsubscribe()}catch(c){n=n||[],c instanceof le?n=n.concat(A(c.errors)):n.push(c)}}}if(n)throw new le(n)}add(n){let e=n;if(!n)return ee.EMPTY;switch(typeof n){case"function":e=new ee(n);case"object":if(e===this||e.closed||"function"!=typeof e.unsubscribe)return e;if(this.closed)return e.unsubscribe(),e;if(!(e instanceof ee)){const o=e;e=new ee,e._subscriptions=[o]}break;default:throw new Error("unrecognized teardown "+n+" added to Subscription.")}let{_parentOrParents:r}=e;if(null===r)e._parentOrParents=this;else if(r instanceof ee){if(r===this)return e;e._parentOrParents=[r,this]}else{if(-1!==r.indexOf(this))return e;r.push(this)}const s=this._subscriptions;return null===s?this._subscriptions=[e]:s.push(e),e}remove(n){const e=this._subscriptions;if(e){const r=e.indexOf(n);-1!==r&&e.splice(r,1)}}}var t;function A(t){return t.reduce((n,e)=>n.concat(e instanceof le?e.errors:e),[])}ee.EMPTY=((t=new ee).closed=!0,t);const de="function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random();class xe extends ee{constructor(n,e,r){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=j;break;case 1:if(!n){this.destination=j;break}if("object"==typeof n){n instanceof xe?(this.syncErrorThrowable=n.syncErrorThrowable,this.destination=n,n.add(this)):(this.syncErrorThrowable=!0,this.destination=new Ze(this,n));break}default:this.syncErrorThrowable=!0,this.destination=new Ze(this,n,e,r)}}[de](){return this}static create(n,e,r){const s=new xe(n,e,r);return s.syncErrorThrowable=!1,s}next(n){this.isStopped||this._next(n)}error(n){this.isStopped||(this.isStopped=!0,this._error(n))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(n){this.destination.next(n)}_error(n){this.destination.error(n),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:n}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=n,this}}class Ze extends xe{constructor(n,e,r,s){super(),this._parentSubscriber=n;let o,i=this;we(e)?o=e:e&&(o=e.next,r=e.error,s=e.complete,e!==j&&(i=Object.create(e),we(i.unsubscribe)&&this.add(i.unsubscribe.bind(i)),i.unsubscribe=this.unsubscribe.bind(this))),this._context=i,this._next=o,this._error=r,this._complete=s}next(n){if(!this.isStopped&&this._next){const{_parentSubscriber:e}=this;Q.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?this.__tryOrSetError(e,this._next,n)&&this.unsubscribe():this.__tryOrUnsub(this._next,n)}}error(n){if(!this.isStopped){const{_parentSubscriber:e}=this,{useDeprecatedSynchronousErrorHandling:r}=Q;if(this._error)r&&e.syncErrorThrowable?(this.__tryOrSetError(e,this._error,n),this.unsubscribe()):(this.__tryOrUnsub(this._error,n),this.unsubscribe());else if(e.syncErrorThrowable)r?(e.syncErrorValue=n,e.syncErrorThrown=!0):F(n),this.unsubscribe();else{if(this.unsubscribe(),r)throw n;F(n)}}}complete(){if(!this.isStopped){const{_parentSubscriber:n}=this;if(this._complete){const e=()=>this._complete.call(this._context);Q.useDeprecatedSynchronousErrorHandling&&n.syncErrorThrowable?(this.__tryOrSetError(n,e),this.unsubscribe()):(this.__tryOrUnsub(e),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(n,e){try{n.call(this._context,e)}catch(r){if(this.unsubscribe(),Q.useDeprecatedSynchronousErrorHandling)throw r;F(r)}}__tryOrSetError(n,e,r){if(!Q.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{e.call(this._context,r)}catch(s){return Q.useDeprecatedSynchronousErrorHandling?(n.syncErrorValue=s,n.syncErrorThrown=!0,!0):(F(s),!0)}return!1}_unsubscribe(){const{_parentSubscriber:n}=this;this._context=null,this._parentSubscriber=null,n.unsubscribe()}}const Vt="function"==typeof Symbol&&Symbol.observable||"@@observable";function ke(t){return t}function It(t){return 0===t.length?ke:1===t.length?t[0]:function(e){return t.reduce((r,s)=>s(r),e)}}let $e=(()=>{class t{constructor(e){this._isScalar=!1,e&&(this._subscribe=e)}lift(e){const r=new t;return r.source=this,r.operator=e,r}subscribe(e,r,s){const{operator:o}=this,i=function St(t,n,e){if(t){if(t instanceof xe)return t;if(t[de])return t[de]()}return t||n||e?new xe(t,n,e):new xe(j)}(e,r,s);if(i.add(o?o.call(i,this.source):this.source||Q.useDeprecatedSynchronousErrorHandling&&!i.syncErrorThrowable?this._subscribe(i):this._trySubscribe(i)),Q.useDeprecatedSynchronousErrorHandling&&i.syncErrorThrowable&&(i.syncErrorThrowable=!1,i.syncErrorThrown))throw i.syncErrorValue;return i}_trySubscribe(e){try{return this._subscribe(e)}catch(r){Q.useDeprecatedSynchronousErrorHandling&&(e.syncErrorThrown=!0,e.syncErrorValue=r),function ot(t){for(;t;){const{closed:n,destination:e,isStopped:r}=t;if(n||r)return!1;t=e&&e instanceof xe?e:null}return!0}(e)?e.error(r):console.warn(r)}}forEach(e,r){return new(r=Ce(r))((s,o)=>{let i;i=this.subscribe(a=>{try{e(a)}catch(u){o(u),i&&i.unsubscribe()}},o,s)})}_subscribe(e){const{source:r}=this;return r&&r.subscribe(e)}[Vt](){return this}pipe(...e){return 0===e.length?this:It(e)(this)}toPromise(e){return new(e=Ce(e))((r,s)=>{let o;this.subscribe(i=>o=i,i=>s(i),()=>r(o))})}}return t.create=n=>new t(n),t})();function Ce(t){if(t||(t=Q.Promise||Promise),!t)throw new Error("no Promise impl found");return t}const $=(()=>{function t(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return t.prototype=Object.create(Error.prototype),t})();class se extends ee{constructor(n,e){super(),this.subject=n,this.subscriber=e,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const n=this.subject,e=n.observers;if(this.subject=null,!e||0===e.length||n.isStopped||n.closed)return;const r=e.indexOf(this.subscriber);-1!==r&&e.splice(r,1)}}class be extends xe{constructor(n){super(n),this.destination=n}}let ce=(()=>{class t extends $e{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[de](){return new be(this)}lift(e){const r=new x(this,this);return r.operator=e,r}next(e){if(this.closed)throw new $;if(!this.isStopped){const{observers:r}=this,s=r.length,o=r.slice();for(let i=0;i<s;i++)o[i].next(e)}}error(e){if(this.closed)throw new $;this.hasError=!0,this.thrownError=e,this.isStopped=!0;const{observers:r}=this,s=r.length,o=r.slice();for(let i=0;i<s;i++)o[i].error(e);this.observers.length=0}complete(){if(this.closed)throw new $;this.isStopped=!0;const{observers:e}=this,r=e.length,s=e.slice();for(let o=0;o<r;o++)s[o].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(e){if(this.closed)throw new $;return super._trySubscribe(e)}_subscribe(e){if(this.closed)throw new $;return this.hasError?(e.error(this.thrownError),ee.EMPTY):this.isStopped?(e.complete(),ee.EMPTY):(this.observers.push(e),new se(this,e))}asObservable(){const e=new $e;return e.source=this,e}}return t.create=(n,e)=>new x(n,e),t})();class x extends ce{constructor(n,e){super(),this.destination=n,this.source=e}next(n){const{destination:e}=this;e&&e.next&&e.next(n)}error(n){const{destination:e}=this;e&&e.error&&this.destination.error(n)}complete(){const{destination:n}=this;n&&n.complete&&this.destination.complete()}_subscribe(n){const{source:e}=this;return e?this.source.subscribe(n):ee.EMPTY}}function He(t){return t&&"function"==typeof t.schedule}function Me(t,n){return function(r){if("function"!=typeof t)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return r.lift(new We(t,n))}}class We{constructor(n,e){this.project=n,this.thisArg=e}call(n,e){return e.subscribe(new nt(n,this.project,this.thisArg))}}class nt extends xe{constructor(n,e,r){super(n),this.project=e,this.count=0,this.thisArg=r||this}_next(n){let e;try{e=this.project.call(this.thisArg,n,this.count++)}catch(r){return void this.destination.error(r)}this.destination.next(e)}}const et=t=>n=>{for(let e=0,r=t.length;e<r&&!n.closed;e++)n.next(t[e]);n.complete()},Yt=function Ft(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}(),cr=t=>t&&"number"==typeof t.length&&"function"!=typeof t;function kn(t){return!!t&&"function"!=typeof t.subscribe&&"function"==typeof t.then}const dn=t=>{if(t&&"function"==typeof t[Vt])return(t=>n=>{const e=t[Vt]();if("function"!=typeof e.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return e.subscribe(n)})(t);if(cr(t))return et(t);if(kn(t))return(t=>n=>(t.then(e=>{n.closed||(n.next(e),n.complete())},e=>n.error(e)).then(null,F),n))(t);if(t&&"function"==typeof t[Yt])return(t=>n=>{const e=t[Yt]();for(;;){let r;try{r=e.next()}catch(s){return n.error(s),n}if(r.done){n.complete();break}if(n.next(r.value),n.closed)break}return"function"==typeof e.return&&n.add(()=>{e.return&&e.return()}),n})(t);{const e=`You provided ${me(t)?"an invalid object":`'${t}'`} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`;throw new TypeError(e)}};function ds(t,n){return new $e(e=>{const r=new ee;let s=0;return r.add(n.schedule(function(){s!==t.length?(e.next(t[s++]),e.closed||r.add(this.schedule())):e.complete()})),r})}function Nt(t,n){return n?function lt(t,n){if(null!=t){if(function Ne(t){return t&&"function"==typeof t[Vt]}(t))return function un(t,n){return new $e(e=>{const r=new ee;return r.add(n.schedule(()=>{const s=t[Vt]();r.add(s.subscribe({next(o){r.add(n.schedule(()=>e.next(o)))},error(o){r.add(n.schedule(()=>e.error(o)))},complete(){r.add(n.schedule(()=>e.complete()))}}))})),r})}(t,n);if(kn(t))return function Fn(t,n){return new $e(e=>{const r=new ee;return r.add(n.schedule(()=>t.then(s=>{r.add(n.schedule(()=>{e.next(s),r.add(n.schedule(()=>e.complete()))}))},s=>{r.add(n.schedule(()=>e.error(s)))}))),r})}(t,n);if(cr(t))return ds(t,n);if(function rt(t){return t&&"function"==typeof t[Yt]}(t)||"string"==typeof t)return function Zn(t,n){if(!t)throw new Error("Iterable cannot be null");return new $e(e=>{const r=new ee;let s;return r.add(()=>{s&&"function"==typeof s.return&&s.return()}),r.add(n.schedule(()=>{s=t[Yt](),r.add(n.schedule(function(){if(e.closed)return;let o,i;try{const a=s.next();o=a.value,i=a.done}catch(a){return void e.error(a)}i?e.complete():(e.next(o),this.schedule())}))})),r})}(t,n)}throw new TypeError((null!==t&&typeof t||t)+" is not observable")}(t,n):t instanceof $e?t:new $e(dn(t))}class wn extends xe{constructor(n){super(),this.parent=n}_next(n){this.parent.notifyNext(n)}_error(n){this.parent.notifyError(n),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class Jn extends xe{notifyNext(n){this.destination.next(n)}notifyError(n){this.destination.error(n)}notifyComplete(){this.destination.complete()}}function $r(t,n){if(n.closed)return;if(t instanceof $e)return t.subscribe(n);let e;try{e=dn(t)(n)}catch(r){n.error(r)}return e}function _r(t,n,e=Number.POSITIVE_INFINITY){return"function"==typeof n?r=>r.pipe(_r((s,o)=>Nt(t(s,o)).pipe(Me((i,a)=>n(s,i,o,a))),e)):("number"==typeof n&&(e=n),r=>r.lift(new qs(t,e)))}class qs{constructor(n,e=Number.POSITIVE_INFINITY){this.project=n,this.concurrent=e}call(n,e){return e.subscribe(new Ys(n,this.project,this.concurrent))}}class Ys extends Jn{constructor(n,e,r=Number.POSITIVE_INFINITY){super(n),this.project=e,this.concurrent=r,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(n){this.active<this.concurrent?this._tryNext(n):this.buffer.push(n)}_tryNext(n){let e;const r=this.index++;try{e=this.project(n,r)}catch(s){return void this.destination.error(s)}this.active++,this._innerSub(e)}_innerSub(n){const e=new wn(this),r=this.destination;r.add(e);const s=$r(n,e);s!==e&&r.add(s)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(n){this.destination.next(n)}notifyComplete(){const n=this.buffer;this.active--,n.length>0?this._next(n.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}function Fr(t=Number.POSITIVE_INFINITY){return _r(ke,t)}function go(t,n){return n?ds(t,n):new $e(et(t))}function is(){return function(n){return n.lift(new Zo(n))}}class Zo{constructor(n){this.connectable=n}call(n,e){const{connectable:r}=this;r._refCount++;const s=new bi(n,r),o=e.subscribe(s);return s.closed||(s.connection=r.connect()),o}}class bi extends xe{constructor(n,e){super(n),this.connectable=e}_unsubscribe(){const{connectable:n}=this;if(!n)return void(this.connection=null);this.connectable=null;const e=n._refCount;if(e<=0)return void(this.connection=null);if(n._refCount=e-1,e>1)return void(this.connection=null);const{connection:r}=this,s=n._connection;this.connection=null,s&&(!r||s===r)&&s.unsubscribe()}}class Zs extends $e{constructor(n,e){super(),this.source=n,this.subjectFactory=e,this._refCount=0,this._isComplete=!1}_subscribe(n){return this.getSubject().subscribe(n)}getSubject(){const n=this._subject;return(!n||n.isStopped)&&(this._subject=this.subjectFactory()),this._subject}connect(){let n=this._connection;return n||(this._isComplete=!1,n=this._connection=new ee,n.add(this.source.subscribe(new mr(this.getSubject(),this))),n.closed&&(this._connection=null,n=ee.EMPTY)),n}refCount(){return is()(this)}}const oo=(()=>{const t=Zs.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:t._subscribe},_isComplete:{value:t._isComplete,writable:!0},getSubject:{value:t.getSubject},connect:{value:t.connect},refCount:{value:t.refCount}}})();class mr extends be{constructor(n,e){super(n),this.connectable=e}_error(n){this._unsubscribe(),super._error(n)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const n=this.connectable;if(n){this.connectable=null;const e=n._connection;n._refCount=0,n._subject=null,n._connection=null,e&&e.unsubscribe()}}}class Ro{constructor(n,e){this.subjectFactory=n,this.selector=e}call(n,e){const{selector:r}=this,s=this.subjectFactory(),o=r(s).subscribe(n);return o.add(e.subscribe(s)),o}}function Re(){return new ce}function Hn(t){for(let n in t)if(t[n]===Hn)return n;throw Error("Could not find renamed property on target object.")}function hr(t){if("string"==typeof t)return t;if(Array.isArray(t))return"["+t.map(hr).join(", ")+"]";if(null==t)return""+t;if(t.overriddenName)return`${t.overriddenName}`;if(t.name)return`${t.name}`;const n=t.toString();if(null==n)return""+n;const e=n.indexOf("\n");return-1===e?n:n.substring(0,e)}function Ir(t,n){return null==t||""===t?null===n?"":n:null==n||""===n?t:t+" "+n}const Pr=Hn({__forward_ref__:Hn});function ws(t){return t.__forward_ref__=ws,t.toString=function(){return hr(this())},t}function sn(t){return io(t)?t():t}function io(t){return"function"==typeof t&&t.hasOwnProperty(Pr)&&t.__forward_ref__===ws}function Gr(t){return t&&!!t.\u0275providers}const Vi="https://g.co/ng/security#xss";class Pt extends Error{constructor(n,e){super(Lr(n,e)),this.code=n}}function Lr(t,n){return`NG0${Math.abs(t)}${n?": "+n.trim():""}`}function pn(t){return"string"==typeof t?t:null==t?"":String(t)}function Us(t,n){throw new Pt(-201,!1)}function as(t,n){null==t&&function Qn(t,n,e,r){throw new Error(`ASSERTION ERROR: ${t}`+(null==r?"":` [Expected=> ${e} ${r} ${n} <=Actual]`))}(n,t,null,"!=")}function vn(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function Ws(t){return{providers:t.providers||[],imports:t.imports||[]}}function Dr(t){return Ci(t,Ss)||Ci(t,Gi)}function Ci(t,n){return t.hasOwnProperty(n)?t[n]:null}function pa(t){return t&&(t.hasOwnProperty(Mo)||t.hasOwnProperty(Ki))?t[Mo]:null}const Ss=Hn({\u0275prov:Hn}),Mo=Hn({\u0275inj:Hn}),Gi=Hn({ngInjectableDef:Hn}),Ki=Hn({ngInjectorDef:Hn});var mn=(()=>((mn=mn||{})[mn.Default=0]="Default",mn[mn.Host=1]="Host",mn[mn.Self=2]="Self",mn[mn.SkipSelf=4]="SkipSelf",mn[mn.Optional=8]="Optional",mn))();let ei;function Kr(t){const n=ei;return ei=t,n}function $o(t,n,e){const r=Dr(t);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&mn.Optional?null:void 0!==n?n:void Us(hr(t))}const fr=(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)(),_={},V="__NG_DI_FLAG__",U="ngTempTokenPath",he="ngTokenPath",qe=/\n/gm,ct="\u0275",je="__source";let at;function ge(t){const n=at;return at=t,n}function Lt(t,n=mn.Default){if(void 0===at)throw new Pt(-203,!1);return null===at?$o(t,void 0,n):at.get(t,n&mn.Optional?null:void 0,n)}function kt(t,n=mn.Default){return(function Ei(){return ei}()||Lt)(sn(t),n)}function v(t,n=mn.Default){return kt(t,p(n))}function p(t){return typeof t>"u"||"number"==typeof t?t:0|(t.optional&&8)|(t.host&&1)|(t.self&&2)|(t.skipSelf&&4)}function g(t){const n=[];for(let e=0;e<t.length;e++){const r=sn(t[e]);if(Array.isArray(r)){if(0===r.length)throw new Pt(900,!1);let s,o=mn.Default;for(let i=0;i<r.length;i++){const a=r[i],u=G(a);"number"==typeof u?-1===u?s=a.token:o|=u:s=a}n.push(kt(s,o))}else n.push(kt(r))}return n}function C(t,n){return t[V]=n,t.prototype[V]=n,t}function G(t){return t[V]}function oe(t){return{toString:t}.toString()}var Ue=(()=>((Ue=Ue||{})[Ue.OnPush=0]="OnPush",Ue[Ue.Default=1]="Default",Ue))(),ut=(()=>(function(t){t[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom"}(ut||(ut={})),ut))();const tt={},Je=[],bt=Hn({\u0275cmp:Hn}),Wt=Hn({\u0275dir:Hn}),Gt=Hn({\u0275pipe:Hn}),Ht=Hn({\u0275mod:Hn}),ln=Hn({\u0275fac:Hn}),xr=Hn({__NG_ELEMENT_ID__:Hn});let zs=0;function ns(t){return oe(()=>{const n=Ii(t),e={...n,decls:t.decls,vars:t.vars,template:t.template,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,onPush:t.changeDetection===Ue.OnPush,directiveDefs:null,pipeDefs:null,dependencies:n.standalone&&t.dependencies||null,getStandaloneInjector:null,data:t.data||{},encapsulation:t.encapsulation||ut.Emulated,id:"c"+zs++,styles:t.styles||Je,_:null,schemas:t.schemas||null,tView:null};Di(e);const r=t.dependencies;return e.directiveDefs=Xi(r,!1),e.pipeDefs=Xi(r,!0),e})}function Po(t){return br(t)||Os(t)}function _i(t){return null!==t}function Hs(t){return oe(()=>({type:t.type,bootstrap:t.bootstrap||Je,declarations:t.declarations||Je,imports:t.imports||Je,exports:t.exports||Je,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null}))}function pu(t,n){if(null==t)return tt;const e={};for(const r in t)if(t.hasOwnProperty(r)){let s=t[r],o=s;Array.isArray(s)&&(o=s[1],s=s[0]),e[s]=r,n&&(n[s]=o)}return e}function Es(t){return oe(()=>{const n=Ii(t);return Di(n),n})}function br(t){return t[bt]||null}function Os(t){return t[Wt]||null}function Ms(t){return t[Gt]||null}function Js(t,n){const e=t[Ht]||null;if(!e&&!0===n)throw new Error(`Type ${hr(t)} does not have '\u0275mod' property.`);return e}function Ii(t){const n={};return{type:t.type,providersResolver:null,factory:null,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:n,exportAs:t.exportAs||null,standalone:!0===t.standalone,selectors:t.selectors||Je,viewQuery:t.viewQuery||null,features:t.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:pu(t.inputs,n),outputs:pu(t.outputs)}}function Di(t){t.features?.forEach(n=>n(t))}function Xi(t,n){if(!t)return null;const e=n?Ms:Po;return()=>("function"==typeof t?t():t).map(r=>e(r)).filter(_i)}const vo=0,Jt=1,_n=2,Cr=3,uo=4,ti=5,$s=6,Ua=7,Cn=8,Wa=9,ju=10,Kn=11,mu=12,gu=13,yu=14,qi=15,_s=16,fn=17,sr=18,us=19,qn=20,ni=21,gr=22,Ti=1,Yi=2,xo=7,ya=8,za=9,fs=10;function ps(t){return Array.isArray(t)&&"object"==typeof t[Ti]}function eo(t){return Array.isArray(t)&&!0===t[Ti]}function Ha(t){return 0!=(4&t.flags)}function ri(t){return t.componentOffset>-1}function co(t){return 1==(1&t.flags)}function cs(t){return!!t.template}function Gu(t){return 0!=(256&t[_n])}function Vo(t,n){return t.hasOwnProperty(ln)?t[ln]:null}class Yd{constructor(n,e,r){this.previousValue=n,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function xa(){return pl}function pl(t){return t.type.prototype.ngOnChanges&&(t.setInput=Qd),Zd}function Zd(){const t=gl(this),n=t?.current;if(n){const e=t.previous;if(e===tt)t.previous=n;else for(let r in n)e[r]=n[r];t.current=null,this.ngOnChanges(n)}}function Qd(t,n,e,r){const s=this.declaredInputs[e],o=gl(t)||function Jd(t,n){return t[ml]=n}(t,{previous:tt,current:null}),i=o.current||(o.current={}),a=o.previous,u=a[s];i[s]=new Yd(u&&u.currentValue,n,a===tt),t[r]=n}xa.ngInherit=!0;const ml="__ngSimpleChanges__";function gl(t){return t[ml]||null}const bo=function(t,n,e){};function ms(t){for(;Array.isArray(t);)t=t[vo];return t}function Xu(t,n){return ms(n[t])}function lo(t,n){return ms(n[t.index])}function bl(t,n){return t.data[n]}function to(t,n){const e=n[t];return ps(e)?e:e[vo]}function Ga(t){return 64==(64&t[_n])}function Uo(t,n){return null==n?null:t[n]}function vu(t){t[sr]=0}function Ec(t,n){t[ti]+=n;let e=t,r=t[Cr];for(;null!==r&&(1===n&&1===e[ti]||-1===n&&0===e[ti]);)r[ti]+=n,e=r,r=r[Cr]}const Vn={lFrame:Mt(null),bindingsEnabled:!0};function wl(){return Vn.bindingsEnabled}function Dt(){return Vn.lFrame.lView}function or(){return Vn.lFrame.tView}function Zi(t){return Vn.lFrame.contextLView=t,t[Cn]}function Qi(t){return Vn.lFrame.contextLView=null,t}function Is(){let t=Ic();for(;null!==t&&64===t.type;)t=t.parent;return t}function Ic(){return Vn.lFrame.currentTNode}function ho(t,n){const e=Vn.lFrame;e.currentTNode=t,e.isParent=n}function Dc(){return Vn.lFrame.isParent}function Jr(){const t=Vn.lFrame;let n=t.bindingRootIndex;return-1===n&&(n=t.bindingRootIndex=t.tView.bindingStartIndex),n}function ba(){return Vn.lFrame.bindingIndex++}function k(t){const n=Vn.lFrame,e=n.bindingIndex;return n.bindingIndex=n.bindingIndex+t,e}function B(t,n){const e=Vn.lFrame;e.bindingIndex=e.bindingRootIndex=t,ue(n)}function ue(t){Vn.lFrame.currentDirectiveIndex=t}function Le(){return Vn.lFrame.currentQueryIndex}function st(t){Vn.lFrame.currentQueryIndex=t}function it(t){const n=t[Jt];return 2===n.type?n.declTNode:1===n.type?t[$s]:null}function Tt(t,n,e){if(e&mn.SkipSelf){let s=n,o=t;for(;!(s=s.parent,null!==s||e&mn.Host||(s=it(o),null===s||(o=o[qi],10&s.type))););if(null===s)return!1;n=s,t=o}const r=Vn.lFrame=ht();return r.currentTNode=n,r.lView=t,!0}function dt(t){const n=ht(),e=t[Jt];Vn.lFrame=n,n.currentTNode=e.firstChild,n.lView=t,n.tView=e,n.contextLView=t,n.bindingIndex=e.bindingStartIndex,n.inI18n=!1}function ht(){const t=Vn.lFrame,n=null===t?null:t.child;return null===n?Mt(t):n}function Mt(t){const n={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return null!==t&&(t.child=n),n}function on(){const t=Vn.lFrame;return Vn.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}const Sn=on;function Pn(){const t=on();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function Xt(){return Vn.lFrame.selectedIndex}function rs(t){Vn.lFrame.selectedIndex=t}function Tn(){const t=Vn.lFrame;return bl(t.tView,t.selectedIndex)}function qa(t,n){for(let e=n.directiveStart,r=n.directiveEnd;e<r;e++){const o=t.data[e].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:u,ngAfterViewChecked:c,ngOnDestroy:l}=o;i&&(t.contentHooks??(t.contentHooks=[])).push(-e,i),a&&((t.contentHooks??(t.contentHooks=[])).push(e,a),(t.contentCheckHooks??(t.contentCheckHooks=[])).push(e,a)),u&&(t.viewHooks??(t.viewHooks=[])).push(-e,u),c&&((t.viewHooks??(t.viewHooks=[])).push(e,c),(t.viewCheckHooks??(t.viewCheckHooks=[])).push(e,c)),null!=l&&(t.destroyHooks??(t.destroyHooks=[])).push(e,l)}}function El(t,n,e){Kf(t,n,3,e)}function _l(t,n,e,r){(3&t[_n])===e&&Kf(t,n,e,r)}function ch(t,n){let e=t[_n];(3&e)===n&&(e&=2047,e+=1,t[_n]=e)}function Kf(t,n,e,r){const o=r??-1,i=n.length-1;let a=0;for(let u=void 0!==r?65535&t[sr]:0;u<i;u++)if("number"==typeof n[u+1]){if(a=n[u],null!=r&&a>=r)break}else n[u]<0&&(t[sr]+=65536),(a<o||-1==o)&&(Rg(t,e,n,u),t[sr]=(4294901760&t[sr])+u+2),u++}function Rg(t,n,e,r){const s=e[r]<0,o=e[r+1],a=t[s?-e[r]:e[r]];if(s){if(t[_n]>>11<t[sr]>>16&&(3&t[_n])===n){t[_n]+=2048,bo(4,a,o);try{o.call(a)}finally{bo(5,a,o)}}}else{bo(4,a,o);try{o.call(a)}finally{bo(5,a,o)}}}const Ya=-1;class kc{constructor(n,e,r){this.factory=n,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function Tl(t,n,e){let r=0;for(;r<e.length;){const s=e[r];if("number"==typeof s){if(0!==s)break;r++;const o=e[r++],i=e[r++],a=e[r++];t.setAttribute(n,i,a,o)}else{const o=s,i=e[++r];Nl(o)?t.setProperty(n,o,i):t.setAttribute(n,o,i),r++}}return r}function qf(t){return 3===t||4===t||6===t}function Nl(t){return 64===t.charCodeAt(0)}function Rc(t,n){if(null!==n&&0!==n.length)if(null===t||0===t.length)t=n.slice();else{let e=-1;for(let r=0;r<n.length;r++){const s=n[r];"number"==typeof s?e=s:0===e||Yu(t,e,s,null,-1===e||2===e?n[++r]:null)}}return t}function Yu(t,n,e,r,s){let o=0,i=t.length;if(-1===n)i=-1;else for(;o<t.length;){const a=t[o++];if("number"==typeof a){if(a===n){i=-1;break}if(a>n){i=o-1;break}}}for(;o<t.length;){const a=t[o];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==s&&(t[o+1]=s));if(r===t[o+1])return void(t[o+2]=s)}o++,null!==r&&o++,null!==s&&o++}-1!==i&&(t.splice(i,0,n),o=i+1),t.splice(o++,0,e),null!==r&&t.splice(o++,0,r),null!==s&&t.splice(o++,0,s)}function Yf(t){return t!==Ya}function kl(t){return 32767&t}function Al(t,n){let e=function Mg(t){return t>>16}(t),r=n;for(;e>0;)r=r[qi],e--;return r}let lh=!0;function Zu(t){const n=lh;return lh=t,n}const oi=255,Qu=5;let $g=0;const ea={};function Ol(t,n){const e=Zf(t,n);if(-1!==e)return e;const r=n[Jt];r.firstCreatePass&&(t.injectorIndex=n.length,dh(r.data,t),dh(n,null),dh(r.blueprint,null));const s=hh(t,n),o=t.injectorIndex;if(Yf(s)){const i=kl(s),a=Al(s,n),u=a[Jt].data;for(let c=0;c<8;c++)n[o+c]=a[i+c]|u[i+c]}return n[o+8]=s,o}function dh(t,n){t.push(0,0,0,0,0,0,0,0,n)}function Zf(t,n){return-1===t.injectorIndex||t.parent&&t.parent.injectorIndex===t.injectorIndex||null===n[t.injectorIndex+8]?-1:t.injectorIndex}function hh(t,n){if(t.parent&&-1!==t.parent.injectorIndex)return t.parent.injectorIndex;let e=0,r=null,s=n;for(;null!==s;){if(r=rp(s),null===r)return Ya;if(e++,s=s[qi],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return Ya}function fh(t,n,e){!function Fg(t,n,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(xr)&&(r=e[xr]),null==r&&(r=e[xr]=$g++);const s=r&oi;n.data[t+(s>>Qu)]|=1<<s}(t,n,e)}function Qf(t,n,e){if(e&mn.Optional||void 0!==t)return t;Us()}function Jf(t,n,e,r){if(e&mn.Optional&&void 0===r&&(r=null),!(e&(mn.Self|mn.Host))){const s=t[Wa],o=Kr(void 0);try{return s?s.get(n,r,e&mn.Optional):$o(n,r,e&mn.Optional)}finally{Kr(o)}}return Qf(r,0,e)}function ep(t,n,e,r=mn.Default,s){if(null!==t){if(1024&n[_n]){const i=function gh(t,n,e,r,s){let o=t,i=n;for(;null!==o&&null!==i&&1024&i[_n]&&!(256&i[_n]);){const a=tp(o,i,e,r|mn.Self,ea);if(a!==ea)return a;let u=o.parent;if(!u){const c=i[ni];if(c){const l=c.get(e,ea,r);if(l!==ea)return l}u=rp(i),i=i[qi]}o=u}return s}(t,n,e,r,ea);if(i!==ea)return i}const o=tp(t,n,e,r,ea);if(o!==ea)return o}return Jf(n,e,r,s)}function tp(t,n,e,r,s){const o=function Lg(t){if("string"==typeof t)return t.charCodeAt(0)||0;const n=t.hasOwnProperty(xr)?t[xr]:void 0;return"number"==typeof n?n>=0?n&oi:Bg:n}(e);if("function"==typeof o){if(!Tt(n,t,r))return r&mn.Host?Qf(s,0,r):Jf(n,e,r,s);try{const i=o(r);if(null!=i||r&mn.Optional)return i;Us()}finally{Sn()}}else if("number"==typeof o){let i=null,a=Zf(t,n),u=Ya,c=r&mn.Host?n[_s][$s]:null;for((-1===a||r&mn.SkipSelf)&&(u=-1===a?hh(t,n):n[a+8],u!==Ya&&$l(r,!1)?(i=n[Jt],a=kl(u),n=Al(u,n)):a=-1);-1!==a;){const l=n[Jt];if(np(o,a,l.data)){const h=ph(a,n,e,i,r,c);if(h!==ea)return h}u=n[a+8],u!==Ya&&$l(r,n[Jt].data[a+8]===c)&&np(o,a,n)?(i=l,a=kl(u),n=Al(u,n)):a=-1}}return s}function ph(t,n,e,r,s,o){const i=n[Jt],a=i.data[t+8],l=Ml(a,i,e,null==r?ri(a)&&lh:r!=i&&0!=(3&a.type),s&mn.Host&&o===a);return null!==l?bu(n,i,l,a):ea}function Ml(t,n,e,r,s){const o=t.providerIndexes,i=n.data,a=1048575&o,u=t.directiveStart,l=o>>20,f=s?a+l:t.directiveEnd;for(let m=r?a:a+l;m<f;m++){const y=i[m];if(m<u&&e===y||m>=u&&y.type===e)return m}if(s){const m=i[u];if(m&&cs(m)&&m.type===e)return u}return null}function bu(t,n,e,r){let s=t[e];const o=n.data;if(function Il(t){return t instanceof kc}(s)){const i=s;i.resolving&&function yo(t,n){const e=n?`. Dependency path: ${n.join(" > ")} > ${t}`:"";throw new Pt(-200,`Circular dependency in DI detected for ${t}${e}`)}(function rr(t){return"function"==typeof t?t.name||t.toString():"object"==typeof t&&null!=t&&"function"==typeof t.type?t.type.name||t.type.toString():pn(t)}(o[e]));const a=Zu(i.canSeeViewProviders);i.resolving=!0;const u=i.injectImpl?Kr(i.injectImpl):null;Tt(t,r,mn.Default);try{s=t[e]=i.factory(void 0,o,t,r),n.firstCreatePass&&e>=r.directiveStart&&function Xa(t,n,e){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:o}=n.type.prototype;if(r){const i=pl(n);(e.preOrderHooks??(e.preOrderHooks=[])).push(t,i),(e.preOrderCheckHooks??(e.preOrderCheckHooks=[])).push(t,i)}s&&(e.preOrderHooks??(e.preOrderHooks=[])).push(0-t,s),o&&((e.preOrderHooks??(e.preOrderHooks=[])).push(t,o),(e.preOrderCheckHooks??(e.preOrderCheckHooks=[])).push(t,o))}(e,o[e],n)}finally{null!==u&&Kr(u),Zu(a),i.resolving=!1,Sn()}}return s}function np(t,n,e){return!!(e[n+(t>>Qu)]&1<<t)}function $l(t,n){return!(t&mn.Self||t&mn.Host&&n)}class wu{constructor(n,e){this._tNode=n,this._lView=e}get(n,e,r){return ep(this._tNode,this._lView,n,p(r),e)}}function Bg(){return new wu(Is(),Dt())}function mh(t){return io(t)?()=>{const n=mh(sn(t));return n&&n()}:Vo(t)}function rp(t){const n=t[Jt],e=n.type;return 2===e?n.declTNode:1===e?t[$s]:null}const ec="__parameters__";function nc(t,n,e){return oe(()=>{const r=function yh(t){return function(...e){if(t){const r=t(...e);for(const s in r)this[s]=r[s]}}}(n);function s(...o){if(this instanceof s)return r.apply(this,o),this;const i=new s(...o);return a.annotation=i,a;function a(u,c,l){const h=u.hasOwnProperty(ec)?u[ec]:Object.defineProperty(u,ec,{value:[]})[ec];for(;h.length<=l;)h.push(null);return(h[l]=h[l]||[]).push(i),u}}return e&&(s.prototype=Object.create(e.prototype)),s.prototype.ngMetadataName=t,s.annotationCls=s,s})}class An{constructor(n,e){this._desc=n,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=vn({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}function Cu(t,n){t.forEach(e=>Array.isArray(e)?Cu(e,n):n(e))}function ap(t,n,e){n>=t.length?t.push(e):t.splice(n,0,e)}function Ll(t,n){return n>=t.length-1?t.pop():t.splice(n,1)[0]}function wo(t,n,e){let r=Su(t,n);return r>=0?t[1|r]=e:(r=~r,function Hg(t,n,e,r){let s=t.length;if(s==n)t.push(e,r);else if(1===s)t.push(r,t[0]),t[0]=e;else{for(s--,t.push(t[s-1],t[s]);s>n;)t[s]=t[s-2],s--;t[n]=e,t[n+1]=r}}(t,r,n,e)),r}function xh(t,n){const e=Su(t,n);if(e>=0)return t[1|e]}function Su(t,n){return function up(t,n,e){let r=0,s=t.length>>e;for(;s!==r;){const o=r+(s-r>>1),i=t[o<<e];if(n===i)return o<<e;i>n?s=o:r=o+1}return~(s<<e)}(t,n,1)}const Fc=C(nc("Optional"),8),Eu=C(nc("SkipSelf"),4);var Co=(()=>((Co=Co||{})[Co.Important=1]="Important",Co[Co.DashCase=2]="DashCase",Co))();const _h=new Map;let h1=0;const Dh="__ngContext__";function no(t,n){ps(n)?(t[Dh]=n[qn],function p1(t){_h.set(t[qn],t)}(n)):t[Dh]=n}let Th;function Nh(t,n){return Th(t,n)}function N(t){const n=t[Cr];return eo(n)?n[Cr]:n}function R(t){return H(t[gu])}function L(t){return H(t[uo])}function H(t){for(;null!==t&&!eo(t);)t=t[uo];return t}function Z(t,n,e,r,s){if(null!=r){let o,i=!1;eo(r)?o=r:ps(r)&&(i=!0,r=r[vo]);const a=ms(r);0===t&&null!==e?null==s?Wr(n,e,a):Sr(n,e,a,s||null,!0):1===t&&null!==e?Sr(n,e,a,s||null,!0):2===t?function E1(t,n,e){const r=fo(t,n);r&&function ui(t,n,e,r){t.removeChild(n,e,r)}(t,r,n,e)}(n,a,i):3===t&&n.destroyNode(a),null!=o&&function xI(t,n,e,r,s){const o=e[xo];o!==ms(e)&&Z(n,t,r,o,s);for(let a=fs;a<e.length;a++){const u=e[a];kh(u[Jt],u,t,n,r,o)}}(n,t,o,e,s)}}function ze(t,n,e){return t.createElement(n,e)}function ir(t,n){const e=t[za],r=e.indexOf(n),s=n[Cr];512&n[_n]&&(n[_n]&=-513,Ec(s,-1)),e.splice(r,1)}function gs(t,n){if(t.length<=fs)return;const e=fs+n,r=t[e];if(r){const s=r[fn];null!==s&&s!==t&&ir(s,r),n>0&&(t[e-1][uo]=r[uo]);const o=Ll(t,fs+n);!function Ye(t,n){kh(t,n,n[Kn],2,null,null),n[vo]=null,n[$s]=null}(r[Jt],r);const i=o[us];null!==i&&i.detachView(o[Jt]),r[Cr]=null,r[uo]=null,r[_n]&=-65}return r}function ys(t,n){if(!(128&n[_n])){const e=n[Kn];e.destroyNode&&kh(t,n,e,3,null,null),function nn(t){let n=t[gu];if(!n)return Xr(t[Jt],t);for(;n;){let e=null;if(ps(n))e=n[gu];else{const r=n[fs];r&&(e=r)}if(!e){for(;n&&!n[uo]&&n!==t;)ps(n)&&Xr(n[Jt],n),n=n[Cr];null===n&&(n=t),ps(n)&&Xr(n[Jt],n),e=n&&n[uo]}n=e}}(n)}}function Xr(t,n){if(!(128&n[_n])){n[_n]&=-65,n[_n]|=128,function ar(t,n){let e;if(null!=t&&null!=(e=t.destroyHooks))for(let r=0;r<e.length;r+=2){const s=n[e[r]];if(!(s instanceof kc)){const o=e[r+1];if(Array.isArray(o))for(let i=0;i<o.length;i+=2){const a=s[o[i]],u=o[i+1];bo(4,a,u);try{u.call(a)}finally{bo(5,a,u)}}else{bo(4,s,o);try{o.call(s)}finally{bo(5,s,o)}}}}}(t,n),function vs(t,n){const e=t.cleanup,r=n[Ua];let s=-1;if(null!==e)for(let o=0;o<e.length-1;o+=2)if("string"==typeof e[o]){const i=e[o+3];i>=0?r[s=i]():r[s=-i].unsubscribe(),o+=2}else{const i=r[s=e[o+1]];e[o].call(i)}if(null!==r){for(let o=s+1;o<r.length;o++)(0,r[o])();n[Ua]=null}}(t,n),1===n[Jt].type&&n[Kn].destroy();const e=n[fn];if(null!==e&&eo(n[Cr])){e!==n[Cr]&&ir(e,n);const r=n[us];null!==r&&r.detachView(t)}!function m1(t){_h.delete(t[qn])}(n)}}function ss(t,n,e){return function qr(t,n,e){let r=n;for(;null!==r&&40&r.type;)r=(n=r).parent;if(null===r)return e[vo];{const{componentOffset:s}=r;if(s>-1){const{encapsulation:o}=t.data[r.directiveStart+s];if(o===ut.None||o===ut.Emulated)return null}return lo(r,e)}}(t,n.parent,e)}function Sr(t,n,e,r,s){t.insertBefore(n,e,r,s)}function Wr(t,n,e){t.appendChild(n,e)}function es(t,n,e,r,s){null!==r?Sr(t,n,e,r,s):Wr(t,n,e)}function fo(t,n){return t.parentNode(n)}let Ja,D1,kp,Iu=function na(t,n,e){return 40&t.type?lo(t,e):null};function Dp(t,n,e,r){const s=ss(t,r,n),o=n[Kn],a=function _u(t,n,e){return Iu(t,n,e)}(r.parent||n[$s],r,n);if(null!=s)if(Array.isArray(e))for(let u=0;u<e.length;u++)es(o,s,e[u],a,!1);else es(o,s,e,a,!1);void 0!==Ja&&Ja(o,r,n,e,s)}function Tp(t,n){if(null!==n){const e=n.type;if(3&e)return lo(n,t);if(4&e)return S1(-1,t[n.index]);if(8&e){const r=n.child;if(null!==r)return Tp(t,r);{const s=t[n.index];return eo(s)?S1(-1,s):ms(s)}}if(32&e)return Nh(n,t)()||ms(t[n.index]);{const r=by(t,n);return null!==r?Array.isArray(r)?r[0]:Tp(N(t[_s]),r):Tp(t,n.next)}}return null}function by(t,n){return null!==n?t[_s][$s].projection[n.projection]:null}function S1(t,n){const e=fs+t+1;if(e<n.length){const r=n[e],s=r[Jt].firstChild;if(null!==s)return Tp(r,s)}return n[xo]}function _1(t,n,e,r,s,o,i){for(;null!=e;){const a=r[e.index],u=e.type;if(i&&0===n&&(a&&no(ms(a),r),e.flags|=2),32!=(32&e.flags))if(8&u)_1(t,n,e.child,r,s,o,!1),Z(n,t,s,a,o);else if(32&u){const c=Nh(e,r);let l;for(;l=c();)Z(n,t,s,l,o);Z(n,t,s,a,o)}else 16&u?wy(t,n,r,e,s,o):Z(n,t,s,a,o);e=i?e.projectionNext:e.next}}function kh(t,n,e,r,s,o){_1(e,r,t.firstChild,n,s,o,!1)}function wy(t,n,e,r,s,o){const i=e[_s],u=i[$s].projection[r.projection];if(Array.isArray(u))for(let c=0;c<u.length;c++)Z(n,t,s,u[c],o);else _1(t,n,u,i[Cr],s,o,!0)}function Cy(t,n,e){""===e?t.removeAttribute(n,"class"):t.setAttribute(n,"class",e)}function Sy(t,n,e){const{mergedAttrs:r,classes:s,styles:o}=e;null!==r&&Tl(t,n,r),null!==s&&Cy(t,n,s),null!==o&&function wI(t,n,e){t.setAttribute(n,"style",e)}(t,n,o)}function Dy(t){return function T1(){if(void 0===kp&&(kp=null,fr.trustedTypes))try{kp=fr.trustedTypes.createPolicy("angular#unsafe-bypass",{createHTML:t=>t,createScript:t=>t,createScriptURL:t=>t})}catch{}return kp}()?.createScriptURL(t)||t}class Ty{constructor(n){this.changingThisBreaksApplicationSecurity=n}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Vi})`}}function sc(t){return t instanceof Ty?t.changingThisBreaksApplicationSecurity:t}function Ah(t,n){const e=function AI(t){return t instanceof Ty&&t.getTypeName()||null}(t);if(null!=e&&e!==n){if("ResourceURL"===e&&"URL"===n)return!0;throw new Error(`Required a safe ${n}, got a ${e} (see ${Vi})`)}return e===n}const $I=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;var Fs=(()=>((Fs=Fs||{})[Fs.NONE=0]="NONE",Fs[Fs.HTML=1]="HTML",Fs[Fs.STYLE=2]="STYLE",Fs[Fs.SCRIPT=3]="SCRIPT",Fs[Fs.URL=4]="URL",Fs[Fs.RESOURCE_URL=5]="RESOURCE_URL",Fs))();function $y(t){const n=Oh();return n?n.sanitize(Fs.URL,t)||"":Ah(t,"URL")?sc(t):function N1(t){return(t=String(t)).match($I)?t:"unsafe:"+t}(pn(t))}function Fy(t){const n=Oh();if(n)return Dy(n.sanitize(Fs.RESOURCE_URL,t)||"");if(Ah(t,"ResourceURL"))return Dy(sc(t));throw new Pt(904,!1)}function Oh(){const t=Dt();return t&&t[mu]}const Rp=new An("ENVIRONMENT_INITIALIZER"),Ly=new An("INJECTOR",-1),By=new An("INJECTOR_DEF_TYPES");class Vy{get(n,e=_){if(e===_){const r=new Error(`NullInjectorError: No provider for ${hr(n)}!`);throw r.name="NullInjectorError",r}return e}}function XI(...t){return{\u0275providers:Uy(0,t),\u0275fromNgModule:!0}}function Uy(t,...n){const e=[],r=new Set;let s;return Cu(n,o=>{const i=o;O1(i,e,[],r)&&(s||(s=[]),s.push(i))}),void 0!==s&&Wy(s,e),e}function Wy(t,n){for(let e=0;e<t.length;e++){const{providers:s}=t[e];M1(s,o=>{n.push(o)})}}function O1(t,n,e,r){if(!(t=sn(t)))return!1;let s=null,o=pa(t);const i=!o&&br(t);if(o||i){if(i&&!i.standalone)return!1;s=t}else{const u=t.ngModule;if(o=pa(u),!o)return!1;s=u}const a=r.has(s);if(i){if(a)return!1;if(r.add(s),i.dependencies){const u="function"==typeof i.dependencies?i.dependencies():i.dependencies;for(const c of u)O1(c,n,e,r)}}else{if(!o)return!1;{if(null!=o.imports&&!a){let c;r.add(s);try{Cu(o.imports,l=>{O1(l,n,e,r)&&(c||(c=[]),c.push(l))})}finally{}void 0!==c&&Wy(c,n)}if(!a){const c=Vo(s)||(()=>new s);n.push({provide:s,useFactory:c,deps:Je},{provide:By,useValue:s,multi:!0},{provide:Rp,useValue:()=>kt(s),multi:!0})}const u=o.providers;null==u||a||M1(u,l=>{n.push(l)})}}return s!==t&&void 0!==t.providers}function M1(t,n){for(let e of t)Gr(e)&&(e=e.\u0275providers),Array.isArray(e)?M1(e,n):n(e)}const qI=Hn({provide:String,useValue:Hn});function $1(t){return null!==t&&"object"==typeof t&&qI in t}function Vc(t){return"function"==typeof t}const F1=new An("Set Injector scope."),Op={},ZI={};let P1;function Mp(){return void 0===P1&&(P1=new Vy),P1}class Tu{}class jy extends Tu{get destroyed(){return this._destroyed}constructor(n,e,r,s){super(),this.parent=e,this.source=r,this.scopes=s,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,B1(n,i=>this.processProvider(i)),this.records.set(Ly,jl(void 0,this)),s.has("environment")&&this.records.set(Tu,jl(void 0,this));const o=this.records.get(F1);null!=o&&"string"==typeof o.value&&this.scopes.add(o.value),this.injectorDefTypes=new Set(this.get(By.multi,Je,mn.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const n of this._ngOnDestroyHooks)n.ngOnDestroy();for(const n of this._onDestroyHooks)n()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(n){this._onDestroyHooks.push(n)}runInContext(n){this.assertNotDestroyed();const e=ge(this),r=Kr(void 0);try{return n()}finally{ge(e),Kr(r)}}get(n,e=_,r=mn.Default){this.assertNotDestroyed(),r=p(r);const s=ge(this),o=Kr(void 0);try{if(!(r&mn.SkipSelf)){let a=this.records.get(n);if(void 0===a){const u=function nD(t){return"function"==typeof t||"object"==typeof t&&t instanceof An}(n)&&Dr(n);a=u&&this.injectableDefInScope(u)?jl(L1(n),Op):null,this.records.set(n,a)}if(null!=a)return this.hydrate(n,a)}return(r&mn.Self?Mp():this.parent).get(n,e=r&mn.Optional&&e===_?null:e)}catch(i){if("NullInjectorError"===i.name){if((i[U]=i[U]||[]).unshift(hr(n)),s)throw i;return function K(t,n,e,r){const s=t[U];throw n[je]&&s.unshift(n[je]),t.message=function ae(t,n,e,r=null){t=t&&"\n"===t.charAt(0)&&t.charAt(1)==ct?t.slice(2):t;let s=hr(n);if(Array.isArray(n))s=n.map(hr).join(" -> ");else if("object"==typeof n){let o=[];for(let i in n)if(n.hasOwnProperty(i)){let a=n[i];o.push(i+":"+("string"==typeof a?JSON.stringify(a):hr(a)))}s=`{${o.join(", ")}}`}return`${e}${r?"("+r+")":""}[${s}]: ${t.replace(qe,"\n  ")}`}("\n"+t.message,s,e,r),t[he]=s,t[U]=null,t}(i,n,"R3InjectorError",this.source)}throw i}finally{Kr(o),ge(s)}}resolveInjectorInitializers(){const n=ge(this),e=Kr(void 0);try{const r=this.get(Rp.multi,Je,mn.Self);for(const s of r)s()}finally{ge(n),Kr(e)}}toString(){const n=[],e=this.records;for(const r of e.keys())n.push(hr(r));return`R3Injector[${n.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Pt(205,!1)}processProvider(n){let e=Vc(n=sn(n))?n:sn(n&&n.provide);const r=function JI(t){return $1(t)?jl(void 0,t.useValue):jl(function Gy(t,n,e){let r;if(Vc(t)){const s=sn(t);return Vo(s)||L1(s)}if($1(t))r=()=>sn(t.useValue);else if(function Hy(t){return!(!t||!t.useFactory)}(t))r=()=>t.useFactory(...g(t.deps||[]));else if(function zy(t){return!(!t||!t.useExisting)}(t))r=()=>kt(sn(t.useExisting));else{const s=sn(t&&(t.useClass||t.provide));if(!function eD(t){return!!t.deps}(t))return Vo(s)||L1(s);r=()=>new s(...g(t.deps))}return r}(t),Op)}(n);if(Vc(n)||!0!==n.multi)this.records.get(e);else{let s=this.records.get(e);s||(s=jl(void 0,Op,!0),s.factory=()=>g(s.multi),this.records.set(e,s)),e=n,s.multi.push(n)}this.records.set(e,r)}hydrate(n,e){return e.value===Op&&(e.value=ZI,e.value=e.factory()),"object"==typeof e.value&&e.value&&function tD(t){return null!==t&&"object"==typeof t&&"function"==typeof t.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(n){if(!n.providedIn)return!1;const e=sn(n.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}}function L1(t){const n=Dr(t),e=null!==n?n.factory:Vo(t);if(null!==e)return e;if(t instanceof An)throw new Pt(204,!1);if(t instanceof Function)return function QI(t){const n=t.length;if(n>0)throw function $c(t,n){const e=[];for(let r=0;r<t;r++)e.push(n);return e}(n,"?"),new Pt(204,!1);const e=function Si(t){return t&&(t[Ss]||t[Gi])||null}(t);return null!==e?()=>e.factory(t):()=>new t}(t);throw new Pt(204,!1)}function jl(t,n,e=!1){return{factory:t,value:n,multi:e?[]:void 0}}function B1(t,n){for(const e of t)Array.isArray(e)?B1(e,n):e&&Gr(e)?B1(e.\u0275providers,n):n(e)}class rD{}class Ky{}class oD{resolveComponentFactory(n){throw function sD(t){const n=Error(`No component factory found for ${hr(t)}. Did you add it to @NgModule.entryComponents?`);return n.ngComponent=t,n}(n)}}let Mh=(()=>{class t{}return t.NULL=new oD,t})();function iD(){return Gl(Is(),Dt())}function Gl(t,n){return new eu(lo(t,n))}let eu=(()=>{class t{constructor(e){this.nativeElement=e}}return t.__NG_ELEMENT_ID__=iD,t})();function aD(t){return t instanceof eu?t.nativeElement:t}class qy{}let $p=(()=>{class t{}return t.__NG_ELEMENT_ID__=()=>function uD(){const t=Dt(),e=to(Is().index,t);return(ps(e)?e:t)[Kn]}(),t})(),cD=(()=>{class t{}return t.\u0275prov=vn({token:t,providedIn:"root",factory:()=>null}),t})();class Fp{constructor(n){this.full=n,this.major=n.split(".")[0],this.minor=n.split(".")[1],this.patch=n.split(".").slice(2).join(".")}}const lD=new Fp("15.2.9"),V1={},U1="ngOriginalError";function W1(t){return t[U1]}class Kl{constructor(){this._console=console}handleError(n){const e=this._findOriginalError(n);this._console.error("ERROR",n),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(n){let e=n&&W1(n);for(;e&&W1(e);)e=W1(e);return e||null}}function Nu(t){return t instanceof Function?t():t}function Zy(t,n,e){let r=t.length;for(;;){const s=t.indexOf(n,e);if(-1===s)return s;if(0===s||t.charCodeAt(s-1)<=32){const o=n.length;if(s+o===r||t.charCodeAt(s+o)<=32)return s}e=s+1}}const Qy="ng-template";function wD(t,n,e){let r=0,s=!0;for(;r<t.length;){let o=t[r++];if("string"==typeof o&&s){const i=t[r++];if(e&&"class"===o&&-1!==Zy(i.toLowerCase(),n,0))return!0}else{if(1===o){for(;r<t.length&&"string"==typeof(o=t[r++]);)if(o.toLowerCase()===n)return!0;return!1}"number"==typeof o&&(s=!1)}}return!1}function Jy(t){return 4===t.type&&t.value!==Qy}function CD(t,n,e){return n===(4!==t.type||e?t.value:Qy)}function SD(t,n,e){let r=4;const s=t.attrs||[],o=function ID(t){for(let n=0;n<t.length;n++)if(qf(t[n]))return n;return t.length}(s);let i=!1;for(let a=0;a<n.length;a++){const u=n[a];if("number"!=typeof u){if(!i)if(4&r){if(r=2|1&r,""!==u&&!CD(t,u,e)||""===u&&1===n.length){if(wa(r))return!1;i=!0}}else{const c=8&r?u:n[++a];if(8&r&&null!==t.attrs){if(!wD(t.attrs,c,e)){if(wa(r))return!1;i=!0}continue}const h=ED(8&r?"class":u,s,Jy(t),e);if(-1===h){if(wa(r))return!1;i=!0;continue}if(""!==c){let f;f=h>o?"":s[h+1].toLowerCase();const m=8&r?f:null;if(m&&-1!==Zy(m,c,0)||2&r&&c!==f){if(wa(r))return!1;i=!0}}}}else{if(!i&&!wa(r)&&!wa(u))return!1;if(i&&wa(u))continue;i=!1,r=u|1&r}}return wa(r)||i}function wa(t){return 0==(1&t)}function ED(t,n,e,r){if(null===n)return-1;let s=0;if(r||!e){let o=!1;for(;s<n.length;){const i=n[s];if(i===t)return s;if(3===i||6===i)o=!0;else{if(1===i||2===i){let a=n[++s];for(;"string"==typeof a;)a=n[++s];continue}if(4===i)break;if(0===i){s+=4;continue}}s+=o?1:2}return-1}return function DD(t,n){let e=t.indexOf(4);if(e>-1)for(e++;e<t.length;){const r=t[e];if("number"==typeof r)return-1;if(r===n)return e;e++}return-1}(n,t)}function e4(t,n,e=!1){for(let r=0;r<n.length;r++)if(SD(t,n[r],e))return!0;return!1}function t4(t,n){return t?":not("+n.trim()+")":n}function ND(t){let n=t[0],e=1,r=2,s="",o=!1;for(;e<t.length;){let i=t[e];if("string"==typeof i)if(2&r){const a=t[++e];s+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?s+="."+i:4&r&&(s+=" "+i);else""!==s&&!wa(i)&&(n+=t4(o,s),s=""),r=i,o=o||!wa(r);e++}return""!==s&&(n+=t4(o,s)),n}const Xn={};function Eo(t){n4(or(),Dt(),Xt()+t,!1)}function n4(t,n,e,r){if(!r)if(3==(3&n[_n])){const o=t.preOrderCheckHooks;null!==o&&El(n,o,e)}else{const o=t.preOrderHooks;null!==o&&_l(n,o,0,e)}rs(e)}function i4(t,n=null,e=null,r){const s=a4(t,n,e,r);return s.resolveInjectorInitializers(),s}function a4(t,n=null,e=null,r,s=new Set){const o=[e||Je,XI(t)];return r=r||("object"==typeof t?void 0:hr(t)),new jy(o,n||Mp(),r||null,s)}let ku=(()=>{class t{static create(e,r){if(Array.isArray(e))return i4({name:""},r,e,"");{const s=e.name??"";return i4({name:s},e.parent,e.providers,s)}}}return t.THROW_IF_NOT_FOUND=_,t.NULL=new Vy,t.\u0275prov=vn({token:t,providedIn:"any",factory:()=>kt(Ly)}),t.__NG_ELEMENT_ID__=-1,t})();function Rn(t,n=mn.Default){const e=Dt();return null===e?kt(t,n):ep(Is(),e,sn(t),n)}function m4(t,n){const e=t.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const o=e[r+1];if(-1!==o){const i=t.data[o];st(e[r]),i.contentQueries(2,n[o],o)}}}function Lp(t,n,e,r,s,o,i,a,u,c,l){const h=n.blueprint.slice();return h[vo]=s,h[_n]=76|r,(null!==l||t&&1024&t[_n])&&(h[_n]|=1024),vu(h),h[Cr]=h[qi]=t,h[Cn]=e,h[ju]=i||t&&t[ju],h[Kn]=a||t&&t[Kn],h[mu]=u||t&&t[mu]||null,h[Wa]=c||t&&t[Wa]||null,h[$s]=o,h[qn]=function f1(){return h1++}(),h[ni]=l,h[_s]=2==n.type?t[_s]:h,h}function Yl(t,n,e,r,s){let o=t.data[n];if(null===o)o=function K1(t,n,e,r,s){const o=Ic(),i=Dc(),u=t.data[n]=function tT(t,n,e,r,s,o){return{type:e,index:r,insertBeforeIndex:null,injectorIndex:n?n.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:o,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:n,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,i?o:o&&o.parent,e,n,r,s);return null===t.firstChild&&(t.firstChild=u),null!==o&&(i?null==o.child&&null!==u.parent&&(o.child=u):null===o.next&&(o.next=u,u.prev=o)),u}(t,n,e,r,s),function P(){return Vn.lFrame.inI18n}()&&(o.flags|=32);else if(64&o.type){o.type=e,o.value=r,o.attrs=s;const i=function Ai(){const t=Vn.lFrame,n=t.currentTNode;return t.isParent?n:n.parent}();o.injectorIndex=null===i?-1:i.injectorIndex}return ho(o,!0),o}function $h(t,n,e,r){if(0===e)return-1;const s=n.length;for(let o=0;o<e;o++)n.push(r),t.blueprint.push(r),t.data.push(null);return s}function X1(t,n,e){dt(n);try{const r=t.viewQuery;null!==r&&r0(1,r,e);const s=t.template;null!==s&&g4(t,n,s,1,e),t.firstCreatePass&&(t.firstCreatePass=!1),t.staticContentQueries&&m4(t,n),t.staticViewQueries&&r0(2,t.viewQuery,e);const o=t.components;null!==o&&function QD(t,n){for(let e=0;e<n.length;e++)wT(t,n[e])}(n,o)}catch(r){throw t.firstCreatePass&&(t.incompleteFirstPass=!0,t.firstCreatePass=!1),r}finally{n[_n]&=-5,Pn()}}function Bp(t,n,e,r){const s=n[_n];if(128!=(128&s)){dt(n);try{vu(n),function Sl(t){return Vn.lFrame.bindingIndex=t}(t.bindingStartIndex),null!==e&&g4(t,n,e,2,r);const i=3==(3&s);if(i){const c=t.preOrderCheckHooks;null!==c&&El(n,c,null)}else{const c=t.preOrderHooks;null!==c&&_l(n,c,0,null),ch(n,0)}if(function xT(t){for(let n=R(t);null!==n;n=L(n)){if(!n[Yi])continue;const e=n[za];for(let r=0;r<e.length;r++){const s=e[r];512&s[_n]||Ec(s[Cr],1),s[_n]|=512}}}(n),function vT(t){for(let n=R(t);null!==n;n=L(n))for(let e=fs;e<n.length;e++){const r=n[e],s=r[Jt];Ga(r)&&Bp(s,r,s.template,r[Cn])}}(n),null!==t.contentQueries&&m4(t,n),i){const c=t.contentCheckHooks;null!==c&&El(n,c)}else{const c=t.contentHooks;null!==c&&_l(n,c,1),ch(n,1)}!function YD(t,n){const e=t.hostBindingOpCodes;if(null!==e)try{for(let r=0;r<e.length;r++){const s=e[r];if(s<0)rs(~s);else{const o=s,i=e[++r],a=e[++r];B(i,o),a(2,n[o])}}}finally{rs(-1)}}(t,n);const a=t.components;null!==a&&function ZD(t,n){for(let e=0;e<n.length;e++)bT(t,n[e])}(n,a);const u=t.viewQuery;if(null!==u&&r0(2,u,r),i){const c=t.viewCheckHooks;null!==c&&El(n,c)}else{const c=t.viewHooks;null!==c&&_l(n,c,2),ch(n,2)}!0===t.firstUpdatePass&&(t.firstUpdatePass=!1),n[_n]&=-41,512&n[_n]&&(n[_n]&=-513,Ec(n[Cr],-1))}finally{Pn()}}}function g4(t,n,e,r,s){const o=Xt(),i=2&r;try{rs(-1),i&&n.length>gr&&n4(t,n,gr,!1),bo(i?2:0,s),e(r,s)}finally{rs(o),bo(i?3:1,s)}}function q1(t,n,e){if(Ha(n)){const s=n.directiveEnd;for(let o=n.directiveStart;o<s;o++){const i=t.data[o];i.contentQueries&&i.contentQueries(1,e[o],o)}}}function Y1(t,n,e){wl()&&(function uT(t,n,e,r){const s=e.directiveStart,o=e.directiveEnd;ri(e)&&function mT(t,n,e){const r=lo(n,t),s=y4(e),o=t[ju],i=Vp(t,Lp(t,s,null,e.onPush?32:16,r,n,o,o.createRenderer(r,e),null,null,null));t[n.index]=i}(n,e,t.data[s+e.componentOffset]),t.firstCreatePass||Ol(e,n),no(r,n);const i=e.initialInputs;for(let a=s;a<o;a++){const u=t.data[a],c=bu(n,t,a,e);no(c,n),null!==i&&gT(0,a-s,c,u,0,i),cs(u)&&(to(e.index,n)[Cn]=bu(n,t,a,e))}}(t,n,e,lo(e,n)),64==(64&e.flags)&&C4(t,n,e))}function Z1(t,n,e=lo){const r=n.localNames;if(null!==r){let s=n.index+1;for(let o=0;o<r.length;o+=2){const i=r[o+1],a=-1===i?e(n,t):t[i];t[s++]=a}}}function y4(t){const n=t.tView;return null===n||n.incompleteFirstPass?t.tView=Q1(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts):n}function Q1(t,n,e,r,s,o,i,a,u,c){const l=gr+r,h=l+s,f=function JD(t,n){const e=[];for(let r=0;r<n;r++)e.push(r<t?null:Xn);return e}(l,h),m="function"==typeof c?c():c;return f[Jt]={type:t,blueprint:f,template:e,queries:null,viewQuery:a,declTNode:n,data:f.slice().fill(null,l),bindingStartIndex:l,expandoStartIndex:h,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof o?o():o,pipeRegistry:"function"==typeof i?i():i,firstChild:null,schemas:u,consts:m,incompleteFirstPass:!1}}function v4(t,n,e,r){const s=E4(n);null===e?s.push(r):(s.push(e),t.firstCreatePass&&_4(t).push(r,s.length-1))}function x4(t,n,e,r){for(let s in t)if(t.hasOwnProperty(s)){e=null===e?{}:e;const o=t[s];null===r?b4(e,n,s,o):r.hasOwnProperty(s)&&b4(e,n,r[s],o)}return e}function b4(t,n,e,r){t.hasOwnProperty(e)?t[e].push(n,r):t[e]=[n,r]}function J1(t,n,e,r){if(wl()){const s=null===r?null:{"":-1},o=function lT(t,n){const e=t.directiveRegistry;let r=null,s=null;if(e)for(let o=0;o<e.length;o++){const i=e[o];if(e4(n,i.selectors,!1))if(r||(r=[]),cs(i))if(null!==i.findHostDirectiveDefs){const a=[];s=s||new Map,i.findHostDirectiveDefs(i,a,s),r.unshift(...a,i),e0(t,n,a.length)}else r.unshift(i),e0(t,n,0);else s=s||new Map,i.findHostDirectiveDefs?.(i,r,s),r.push(i)}return null===r?null:[r,s]}(t,e);let i,a;null===o?i=a=null:[i,a]=o,null!==i&&w4(t,n,e,i,s,a),s&&function dT(t,n,e){if(n){const r=t.localNames=[];for(let s=0;s<n.length;s+=2){const o=e[n[s+1]];if(null==o)throw new Pt(-301,!1);r.push(n[s],o)}}}(e,r,s)}e.mergedAttrs=Rc(e.mergedAttrs,e.attrs)}function w4(t,n,e,r,s,o){for(let c=0;c<r.length;c++)fh(Ol(e,n),t,r[c].type);!function fT(t,n,e){t.flags|=1,t.directiveStart=n,t.directiveEnd=n+e,t.providerIndexes=n}(e,t.data.length,r.length);for(let c=0;c<r.length;c++){const l=r[c];l.providersResolver&&l.providersResolver(l)}let i=!1,a=!1,u=$h(t,n,r.length,null);for(let c=0;c<r.length;c++){const l=r[c];e.mergedAttrs=Rc(e.mergedAttrs,l.hostAttrs),pT(t,e,n,u,l),hT(u,l,s),null!==l.contentQueries&&(e.flags|=4),(null!==l.hostBindings||null!==l.hostAttrs||0!==l.hostVars)&&(e.flags|=64);const h=l.type.prototype;!i&&(h.ngOnChanges||h.ngOnInit||h.ngDoCheck)&&((t.preOrderHooks??(t.preOrderHooks=[])).push(e.index),i=!0),!a&&(h.ngOnChanges||h.ngDoCheck)&&((t.preOrderCheckHooks??(t.preOrderCheckHooks=[])).push(e.index),a=!0),u++}!function nT(t,n,e){const s=n.directiveEnd,o=t.data,i=n.attrs,a=[];let u=null,c=null;for(let l=n.directiveStart;l<s;l++){const h=o[l],f=e?e.get(h):null,y=f?f.outputs:null;u=x4(h.inputs,l,u,f?f.inputs:null),c=x4(h.outputs,l,c,y);const w=null===u||null===i||Jy(n)?null:yT(u,l,i);a.push(w)}null!==u&&(u.hasOwnProperty("class")&&(n.flags|=8),u.hasOwnProperty("style")&&(n.flags|=16)),n.initialInputs=a,n.inputs=u,n.outputs=c}(t,e,o)}function C4(t,n,e){const r=e.directiveStart,s=e.directiveEnd,o=e.index,i=function X(){return Vn.lFrame.currentDirectiveIndex}();try{rs(o);for(let a=r;a<s;a++){const u=t.data[a],c=n[a];ue(a),(null!==u.hostBindings||0!==u.hostVars||null!==u.hostAttrs)&&cT(u,c)}}finally{rs(-1),ue(i)}}function cT(t,n){null!==t.hostBindings&&t.hostBindings(1,n)}function e0(t,n,e){n.componentOffset=e,(t.components??(t.components=[])).push(n.index)}function hT(t,n,e){if(e){if(n.exportAs)for(let r=0;r<n.exportAs.length;r++)e[n.exportAs[r]]=t;cs(n)&&(e[""]=t)}}function pT(t,n,e,r,s){t.data[r]=s;const o=s.factory||(s.factory=Vo(s.type)),i=new kc(o,cs(s),Rn);t.blueprint[r]=i,e[r]=i,function iT(t,n,e,r,s){const o=s.hostBindings;if(o){let i=t.hostBindingOpCodes;null===i&&(i=t.hostBindingOpCodes=[]);const a=~n.index;(function aT(t){let n=t.length;for(;n>0;){const e=t[--n];if("number"==typeof e&&e<0)return e}return 0})(i)!=a&&i.push(a),i.push(e,r,o)}}(t,n,r,$h(t,e,s.hostVars,Xn),s)}function tu(t,n,e,r,s,o){const i=lo(t,n);!function t0(t,n,e,r,s,o,i){if(null==o)t.removeAttribute(n,s,e);else{const a=null==i?pn(o):i(o,r||"",s);t.setAttribute(n,s,a,e)}}(n[Kn],i,o,t.value,e,r,s)}function gT(t,n,e,r,s,o){const i=o[n];if(null!==i){const a=r.setInput;for(let u=0;u<i.length;){const c=i[u++],l=i[u++],h=i[u++];null!==a?r.setInput(e,h,c,l):e[l]=h}}}function yT(t,n,e){let r=null,s=0;for(;s<e.length;){const o=e[s];if(0!==o)if(5!==o){if("number"==typeof o)break;if(t.hasOwnProperty(o)){null===r&&(r=[]);const i=t[o];for(let a=0;a<i.length;a+=2)if(i[a]===n){r.push(o,i[a+1],e[s+1]);break}}s+=2}else s+=2;else s+=4}return r}function S4(t,n,e,r){return[t,!0,!1,n,null,0,r,e,null,null]}function bT(t,n){const e=to(n,t);if(Ga(e)){const r=e[Jt];48&e[_n]?Bp(r,e,r.template,e[Cn]):e[ti]>0&&n0(e)}}function n0(t){for(let r=R(t);null!==r;r=L(r))for(let s=fs;s<r.length;s++){const o=r[s];if(Ga(o))if(512&o[_n]){const i=o[Jt];Bp(i,o,i.template,o[Cn])}else o[ti]>0&&n0(o)}const e=t[Jt].components;if(null!==e)for(let r=0;r<e.length;r++){const s=to(e[r],t);Ga(s)&&s[ti]>0&&n0(s)}}function wT(t,n){const e=to(n,t),r=e[Jt];(function CT(t,n){for(let e=n.length;e<t.blueprint.length;e++)n.push(t.blueprint[e])})(r,e),X1(r,e,e[Cn])}function Vp(t,n){return t[gu]?t[yu][uo]=n:t[gu]=n,t[yu]=n,n}function Up(t){for(;t;){t[_n]|=32;const n=N(t);if(Gu(t)&&!n)return t;t=n}return null}function Wp(t,n,e,r=!0){const s=n[ju];s.begin&&s.begin();try{Bp(t,n,t.template,e)}catch(i){throw r&&D4(n,i),i}finally{s.end&&s.end()}}function r0(t,n,e){st(0),n(t,e)}function E4(t){return t[Ua]||(t[Ua]=[])}function _4(t){return t.cleanup||(t.cleanup=[])}function D4(t,n){const e=t[Wa],r=e?e.get(Kl,null):null;r&&r.handleError(n)}function s0(t,n,e,r,s){for(let o=0;o<e.length;){const i=e[o++],a=e[o++],u=n[i],c=t.data[i];null!==c.setInput?c.setInput(u,s,r,a):u[a]=s}}function zp(t,n,e){let r=e?t.styles:null,s=e?t.classes:null,o=0;if(null!==n)for(let i=0;i<n.length;i++){const a=n[i];"number"==typeof a?o=a:1==o?s=Ir(s,a):2==o&&(r=Ir(r,a+": "+n[++i]+";"))}e?t.styles=r:t.stylesWithoutHost=r,e?t.classes=s:t.classesWithoutHost=s}function Hp(t,n,e,r,s=!1){for(;null!==e;){const o=n[e.index];if(null!==o&&r.push(ms(o)),eo(o))for(let a=fs;a<o.length;a++){const u=o[a],c=u[Jt].firstChild;null!==c&&Hp(u[Jt],u,c,r)}const i=e.type;if(8&i)Hp(t,n,e.child,r);else if(32&i){const a=Nh(e,n);let u;for(;u=a();)r.push(u)}else if(16&i){const a=by(n,e);if(Array.isArray(a))r.push(...a);else{const u=N(n[_s]);Hp(u[Jt],u,a,r,!0)}}e=s?e.projectionNext:e.next}return r}class Fh{get rootNodes(){const n=this._lView,e=n[Jt];return Hp(e,n,e.firstChild,[])}constructor(n,e){this._lView=n,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[Cn]}set context(n){this._lView[Cn]=n}get destroyed(){return 128==(128&this._lView[_n])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const n=this._lView[Cr];if(eo(n)){const e=n[ya],r=e?e.indexOf(this):-1;r>-1&&(gs(n,r),Ll(e,r))}this._attachedToViewContainer=!1}ys(this._lView[Jt],this._lView)}onDestroy(n){v4(this._lView[Jt],this._lView,null,n)}markForCheck(){Up(this._cdRefInjectingView||this._lView)}detach(){this._lView[_n]&=-65}reattach(){this._lView[_n]|=64}detectChanges(){Wp(this._lView[Jt],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new Pt(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function Qt(t,n){kh(t,n,n[Kn],2,null,null)}(this._lView[Jt],this._lView)}attachToAppRef(n){if(this._attachedToViewContainer)throw new Pt(902,!1);this._appRef=n}}class ST extends Fh{constructor(n){super(n),this._view=n}detectChanges(){const n=this._view;Wp(n[Jt],n,n[Cn],!1)}checkNoChanges(){}get context(){return null}}class T4 extends Mh{constructor(n){super(),this.ngModule=n}resolveComponentFactory(n){const e=br(n);return new Ph(e,this.ngModule)}}function N4(t){const n=[];for(let e in t)t.hasOwnProperty(e)&&n.push({propName:t[e],templateName:e});return n}class _T{constructor(n,e){this.injector=n,this.parentInjector=e}get(n,e,r){r=p(r);const s=this.injector.get(n,V1,r);return s!==V1||e===V1?s:this.parentInjector.get(n,e,r)}}class Ph extends Ky{get inputs(){return N4(this.componentDef.inputs)}get outputs(){return N4(this.componentDef.outputs)}constructor(n,e){super(),this.componentDef=n,this.ngModule=e,this.componentType=n.type,this.selector=function kD(t){return t.map(ND).join(",")}(n.selectors),this.ngContentSelectors=n.ngContentSelectors?n.ngContentSelectors:[],this.isBoundToModule=!!e}create(n,e,r,s){let o=(s=s||this.ngModule)instanceof Tu?s:s?.injector;o&&null!==this.componentDef.getStandaloneInjector&&(o=this.componentDef.getStandaloneInjector(o)||o);const i=o?new _T(n,o):n,a=i.get(qy,null);if(null===a)throw new Pt(407,!1);const u=i.get(cD,null),c=a.createRenderer(null,this.componentDef),l=this.componentDef.selectors[0][0]||"div",h=r?function eT(t,n,e){return t.selectRootElement(n,e===ut.ShadowDom)}(c,r,this.componentDef.encapsulation):ze(c,l,function ET(t){const n=t.toLowerCase();return"svg"===n?"svg":"math"===n?"math":null}(l)),f=this.componentDef.onPush?288:272,m=Q1(0,null,null,1,0,null,null,null,null,null),y=Lp(null,m,null,f,null,null,a,c,u,i,null);let w,E;dt(y);try{const D=this.componentDef;let O,W=null;D.findHostDirectiveDefs?(O=[],W=new Map,D.findHostDirectiveDefs(D,O,W),O.push(D)):O=[D];const q=function DT(t,n){const e=t[Jt],r=gr;return t[r]=n,Yl(e,r,2,"#host",null)}(y,h),re=function TT(t,n,e,r,s,o,i,a){const u=s[Jt];!function NT(t,n,e,r){for(const s of t)n.mergedAttrs=Rc(n.mergedAttrs,s.hostAttrs);null!==n.mergedAttrs&&(zp(n,n.mergedAttrs,!0),null!==e&&Sy(r,e,n))}(r,t,n,i);const c=o.createRenderer(n,e),l=Lp(s,y4(e),null,e.onPush?32:16,s[t.index],t,o,c,a||null,null,null);return u.firstCreatePass&&e0(u,t,r.length-1),Vp(s,l),s[t.index]=l}(q,h,D,O,y,a,c);E=bl(m,gr),h&&function AT(t,n,e,r){if(r)Tl(t,e,["ng-version",lD.full]);else{const{attrs:s,classes:o}=function AD(t){const n=[],e=[];let r=1,s=2;for(;r<t.length;){let o=t[r];if("string"==typeof o)2===s?""!==o&&n.push(o,t[++r]):8===s&&e.push(o);else{if(!wa(s))break;s=o}r++}return{attrs:n,classes:e}}(n.selectors[0]);s&&Tl(t,e,s),o&&o.length>0&&Cy(t,e,o.join(" "))}}(c,D,h,r),void 0!==e&&function RT(t,n,e){const r=t.projection=[];for(let s=0;s<n.length;s++){const o=e[s];r.push(null!=o?Array.from(o):null)}}(E,this.ngContentSelectors,e),w=function kT(t,n,e,r,s,o){const i=Is(),a=s[Jt],u=lo(i,s);w4(a,s,i,e,null,r);for(let l=0;l<e.length;l++)no(bu(s,a,i.directiveStart+l,i),s);C4(a,s,i),u&&no(u,s);const c=bu(s,a,i.directiveStart+i.componentOffset,i);if(t[Cn]=s[Cn]=c,null!==o)for(const l of o)l(c,n);return q1(a,i,t),c}(re,D,O,W,y,[OT]),X1(m,y,null)}finally{Pn()}return new IT(this.componentType,w,Gl(E,y),y,E)}}class IT extends rD{constructor(n,e,r,s,o){super(),this.location=r,this._rootLView=s,this._tNode=o,this.instance=e,this.hostView=this.changeDetectorRef=new ST(s),this.componentType=n}setInput(n,e){const r=this._tNode.inputs;let s;if(null!==r&&(s=r[n])){const o=this._rootLView;s0(o[Jt],o,s,n,e),Up(to(this._tNode.index,o))}}get injector(){return new wu(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(n){this.hostView.onDestroy(n)}}function OT(){const t=Is();qa(Dt()[Jt],t)}function jp(t){return!!function a0(t){return null!==t&&("function"==typeof t||"object"==typeof t)}(t)&&(Array.isArray(t)||!(t instanceof Map)&&Symbol.iterator in t)}function nu(t,n,e){return t[n]=e}function _o(t,n,e){return!Object.is(t[n],e)&&(t[n]=e,!0)}function u0(t,n,e,r){const s=Dt();return _o(s,ba(),n)&&(or(),tu(Tn(),s,t,n,e,r)),u0}function Wc(t,n,e,r,s,o,i,a){const u=Dt(),c=or(),l=t+gr,h=c.firstCreatePass?function KT(t,n,e,r,s,o,i,a,u){const c=n.consts,l=Yl(n,t,4,i||null,Uo(c,a));J1(n,e,l,Uo(c,u)),qa(n,l);const h=l.tView=Q1(2,l,r,s,o,n.directiveRegistry,n.pipeRegistry,null,n.schemas,c);return null!==n.queries&&(n.queries.template(n,l),h.queries=n.queries.embeddedTView(l)),l}(l,c,u,n,e,r,s,o,i):c.data[l];ho(h,!1);const f=u[Kn].createComment("");Dp(c,u,f,h),no(f,u),Vp(u,u[l]=S4(f,u,f,h)),co(h)&&Y1(c,u,h),null!=i&&Z1(u,h,a)}function $i(t,n,e){const r=Dt();return _o(r,ba(),n)&&function Mi(t,n,e,r,s,o,i,a){const u=lo(n,e);let l,c=n.inputs;!a&&null!=c&&(l=c[r])?(s0(t,e,l,r,s),ri(n)&&function sT(t,n){const e=to(n,t);16&e[_n]||(e[_n]|=32)}(e,n.index)):3&n.type&&(r=function rT(t){return"class"===t?"className":"for"===t?"htmlFor":"formaction"===t?"formAction":"innerHtml"===t?"innerHTML":"readonly"===t?"readOnly":"tabindex"===t?"tabIndex":t}(r),s=null!=i?i(s,n.value||"",r):s,o.setProperty(u,r,s))}(or(),Tn(),r,t,n,r[Kn],e,!1),$i}function c0(t,n,e,r,s){const i=s?"class":"style";s0(t,e,n.inputs[i],i,r)}function yr(t,n,e,r){const s=Dt(),o=or(),i=gr+t,a=s[Kn],u=o.firstCreatePass?function YT(t,n,e,r,s,o){const i=n.consts,u=Yl(n,t,2,r,Uo(i,s));return J1(n,e,u,Uo(i,o)),null!==u.attrs&&zp(u,u.attrs,!1),null!==u.mergedAttrs&&zp(u,u.mergedAttrs,!0),null!==n.queries&&n.queries.elementStart(n,u),u}(i,o,s,n,e,r):o.data[i],c=s[i]=ze(a,n,function qu(){return Vn.lFrame.currentNamespace}()),l=co(u);return ho(u,!0),Sy(a,c,u),32!=(32&u.flags)&&Dp(o,s,c,u),0===function _c(){return Vn.lFrame.elementDepthCount}()&&no(c,s),function oh(){Vn.lFrame.elementDepthCount++}(),l&&(Y1(o,s,u),q1(o,u,s)),null!==r&&Z1(s,u),yr}function Mr(){let t=Is();Dc()?function Tc(){Vn.lFrame.isParent=!1}():(t=t.parent,ho(t,!1));const n=t;!function ih(){Vn.lFrame.elementDepthCount--}();const e=or();return e.firstCreatePass&&(qa(e,t),Ha(t)&&e.queries.elementEnd(t)),null!=n.classesWithoutHost&&function Ac(t){return 0!=(8&t.flags)}(n)&&c0(e,n,Dt(),n.classesWithoutHost,!0),null!=n.stylesWithoutHost&&function Og(t){return 0!=(16&t.flags)}(n)&&c0(e,n,Dt(),n.stylesWithoutHost,!1),Mr}function li(t,n,e,r){return yr(t,n,e,r),Mr(),li}function h0(){return Dt()}function Kp(t){return!!t&&"function"==typeof t.then}const G4=function j4(t){return!!t&&"function"==typeof t.subscribe};function ru(t,n,e,r){const s=Dt(),o=or(),i=Is();return function X4(t,n,e,r,s,o,i){const a=co(r),c=t.firstCreatePass&&_4(t),l=n[Cn],h=E4(n);let f=!0;if(3&r.type||i){const w=lo(r,n),E=i?i(w):w,D=h.length,O=i?q=>i(ms(q[r.index])):r.index;let W=null;if(!i&&a&&(W=function QT(t,n,e,r){const s=t.cleanup;if(null!=s)for(let o=0;o<s.length-1;o+=2){const i=s[o];if(i===e&&s[o+1]===r){const a=n[Ua],u=s[o+2];return a.length>u?a[u]:null}"string"==typeof i&&(o+=2)}return null}(t,n,s,r.index)),null!==W)(W.__ngLastListenerFn__||W).__ngNextListenerFn__=o,W.__ngLastListenerFn__=o,f=!1;else{o=Y4(r,n,l,o,!1);const q=e.listen(E,s,o);h.push(o,q),c&&c.push(s,O,D,D+1)}}else o=Y4(r,n,l,o,!1);const m=r.outputs;let y;if(f&&null!==m&&(y=m[s])){const w=y.length;if(w)for(let E=0;E<w;E+=2){const re=n[y[E]][y[E+1]].subscribe(o),pe=h.length;h.push(o,re),c&&c.push(s,r.index,pe,-(pe+1))}}}(o,s,s[Kn],i,t,n,r),ru}function q4(t,n,e,r){try{return bo(6,n,e),!1!==e(r)}catch(s){return D4(t,s),!1}finally{bo(7,n,e)}}function Y4(t,n,e,r,s){return function o(i){if(i===Function)return r;Up(t.componentOffset>-1?to(t.index,n):n);let u=q4(n,e,r,i),c=o.__ngNextListenerFn__;for(;c;)u=q4(n,e,c,i)&&u,c=c.__ngNextListenerFn__;return s&&!1===u&&(i.preventDefault(),i.returnValue=!1),u}}function Ca(t=1){return function lr(t){return(Vn.lFrame.contextLView=function si(t,n){for(;t>0;)n=n[qi],t--;return n}(t,Vn.lFrame.contextLView))[Cn]}(t)}function Xp(t,n){return t<<17|n<<2}function oc(t){return t>>17&32767}function p0(t){return 2|t}function zc(t){return(131068&t)>>2}function m0(t,n){return-131069&t|n<<2}function g0(t){return 1|t}function iv(t,n,e,r,s){const o=t[e+1],i=null===n;let a=r?oc(o):zc(o),u=!1;for(;0!==a&&(!1===u||i);){const l=t[a+1];aN(t[a],n)&&(u=!0,t[a+1]=r?g0(l):p0(l)),a=r?oc(l):zc(l)}u&&(t[e+1]=r?p0(o):g0(o))}function aN(t,n){return null===t||null==n||(Array.isArray(t)?t[1]:t)===n||!(!Array.isArray(t)||"string"!=typeof n)&&Su(t,n)>=0}const js={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function av(t){return t.substring(js.key,js.keyEnd)}function uv(t,n){const e=js.textEnd;return e===n?-1:(n=js.keyEnd=function dN(t,n,e){for(;n<e&&t.charCodeAt(n)>32;)n++;return n}(t,js.key=n,e),id(t,n,e))}function id(t,n,e){for(;n<e&&t.charCodeAt(n)<=32;)n++;return n}function Hc(t,n){return function Sa(t,n,e,r){const s=Dt(),o=or(),i=k(2);o.firstUpdatePass&&gv(o,t,i,r),n!==Xn&&_o(s,i,n)&&vv(o,o.data[Xt()],s,s[Kn],t,s[i+1]=function CN(t,n){return null==t||""===t||("string"==typeof n?t+=n:"object"==typeof t&&(t=hr(sc(t)))),t}(n,e),r,i)}(t,n,null,!0),Hc}function pv(t){!function Ea(t,n,e,r){const s=or(),o=k(2);s.firstUpdatePass&&gv(s,null,o,r);const i=Dt();if(e!==Xn&&_o(i,o,e)){const a=s.data[Xt()];if(bv(a,r)&&!mv(s,o)){let u=r?a.classesWithoutHost:a.stylesWithoutHost;null!==u&&(e=Ir(u,e||"")),c0(s,a,i,e,r)}else!function wN(t,n,e,r,s,o,i,a){s===Xn&&(s=Je);let u=0,c=0,l=0<s.length?s[0]:null,h=0<o.length?o[0]:null;for(;null!==l||null!==h;){const f=u<s.length?s[u+1]:void 0,m=c<o.length?o[c+1]:void 0;let w,y=null;l===h?(u+=2,c+=2,f!==m&&(y=h,w=m)):null===h||null!==l&&l<h?(u+=2,y=l):(c+=2,y=h,w=m),null!==y&&vv(t,n,e,r,y,w,i,a),l=u<s.length?s[u]:null,h=c<o.length?o[c]:null}}(s,a,i,i[Kn],i[o+1],i[o+1]=function xN(t,n,e){if(null==e||""===e)return Je;const r=[],s=sc(e);if(Array.isArray(s))for(let o=0;o<s.length;o++)t(r,s[o],!0);else if("object"==typeof s)for(const o in s)s.hasOwnProperty(o)&&t(r,o,s[o]);else"string"==typeof s&&n(r,s);return r}(t,n,e),r,o)}}(bN,ou,t,!0)}function ou(t,n){for(let e=function cN(t){return function lv(t){js.key=0,js.keyEnd=0,js.value=0,js.valueEnd=0,js.textEnd=t.length}(t),uv(t,id(t,0,js.textEnd))}(n);e>=0;e=uv(n,e))wo(t,av(n),!0)}function mv(t,n){return n>=t.expandoStartIndex}function gv(t,n,e,r){const s=t.data;if(null===s[e+1]){const o=s[Xt()],i=mv(t,e);bv(o,r)&&null===n&&!i&&(n=!1),n=function mN(t,n,e,r){const s=function fe(t){const n=Vn.lFrame.currentDirectiveIndex;return-1===n?null:t[n]}(t);let o=r?n.residualClasses:n.residualStyles;if(null===s)0===(r?n.classBindings:n.styleBindings)&&(e=Bh(e=y0(null,t,n,e,r),n.attrs,r),o=null);else{const i=n.directiveStylingLast;if(-1===i||t[i]!==s)if(e=y0(s,t,n,e,r),null===o){let u=function gN(t,n,e){const r=e?n.classBindings:n.styleBindings;if(0!==zc(r))return t[oc(r)]}(t,n,r);void 0!==u&&Array.isArray(u)&&(u=y0(null,t,n,u[1],r),u=Bh(u,n.attrs,r),function yN(t,n,e,r){t[oc(e?n.classBindings:n.styleBindings)]=r}(t,n,r,u))}else o=function vN(t,n,e){let r;const s=n.directiveEnd;for(let o=1+n.directiveStylingLast;o<s;o++)r=Bh(r,t[o].hostAttrs,e);return Bh(r,n.attrs,e)}(t,n,r)}return void 0!==o&&(r?n.residualClasses=o:n.residualStyles=o),e}(s,o,n,r),function oN(t,n,e,r,s,o){let i=o?n.classBindings:n.styleBindings,a=oc(i),u=zc(i);t[r]=e;let l,c=!1;if(Array.isArray(e)?(l=e[1],(null===l||Su(e,l)>0)&&(c=!0)):l=e,s)if(0!==u){const f=oc(t[a+1]);t[r+1]=Xp(f,a),0!==f&&(t[f+1]=m0(t[f+1],r)),t[a+1]=function rN(t,n){return 131071&t|n<<17}(t[a+1],r)}else t[r+1]=Xp(a,0),0!==a&&(t[a+1]=m0(t[a+1],r)),a=r;else t[r+1]=Xp(u,0),0===a?a=r:t[u+1]=m0(t[u+1],r),u=r;c&&(t[r+1]=p0(t[r+1])),iv(t,l,r,!0),iv(t,l,r,!1),function iN(t,n,e,r,s){const o=s?t.residualClasses:t.residualStyles;null!=o&&"string"==typeof n&&Su(o,n)>=0&&(e[r+1]=g0(e[r+1]))}(n,l,t,r,o),i=Xp(a,u),o?n.classBindings=i:n.styleBindings=i}(s,o,n,e,i,r)}}function y0(t,n,e,r,s){let o=null;const i=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<i&&(o=n[a],r=Bh(r,o.hostAttrs,s),o!==t);)a++;return null!==t&&(e.directiveStylingLast=a),r}function Bh(t,n,e){const r=e?1:2;let s=-1;if(null!==n)for(let o=0;o<n.length;o++){const i=n[o];"number"==typeof i?s=i:s===r&&(Array.isArray(t)||(t=void 0===t?[]:["",t]),wo(t,i,!!e||n[++o]))}return void 0===t?null:t}function bN(t,n,e){const r=String(n);""!==r&&!r.includes(" ")&&wo(t,r,e)}function vv(t,n,e,r,s,o,i,a){if(!(3&n.type))return;const u=t.data,c=u[a+1],l=function sN(t){return 1==(1&t)}(c)?xv(u,n,e,s,zc(c),i):void 0;qp(l)||(qp(o)||function nN(t){return 2==(2&t)}(c)&&(o=xv(u,null,e,s,a,i)),function bI(t,n,e,r,s){if(n)s?t.addClass(e,r):t.removeClass(e,r);else{let o=-1===r.indexOf("-")?void 0:Co.DashCase;null==s?t.removeStyle(e,r,o):("string"==typeof s&&s.endsWith("!important")&&(s=s.slice(0,-10),o|=Co.Important),t.setStyle(e,r,s,o))}}(r,i,Xu(Xt(),e),s,o))}function xv(t,n,e,r,s,o){const i=null===n;let a;for(;s>0;){const u=t[s],c=Array.isArray(u),l=c?u[1]:u,h=null===l;let f=e[s+1];f===Xn&&(f=h?Je:void 0);let m=h?xh(f,r):l===r?f:void 0;if(c&&!qp(m)&&(m=xh(u,r)),qp(m)&&(a=m,i))return a;const y=t[s+1];s=i?oc(y):zc(y)}if(null!==n){let u=o?n.residualClasses:n.residualStyles;null!=u&&(a=xh(u,r))}return a}function qp(t){return void 0!==t}function bv(t,n){return 0!=(t.flags&(n?8:16))}function Ps(t,n=""){const e=Dt(),r=or(),s=t+gr,o=r.firstCreatePass?Yl(r,s,1,n,null):r.data[s],i=e[s]=function ne(t,n){return t.createText(n)}(e[Kn],n);Dp(r,e,i,o),ho(o,!1)}function Yp(t){return v0("",t,""),Yp}function v0(t,n,e){const r=Dt(),s=function Ql(t,n,e,r){return _o(t,ba(),e)?n+pn(e)+r:Xn}(r,t,n,e);return s!==Xn&&function Au(t,n,e){const r=Xu(n,t);!function ve(t,n,e){t.setValue(n,e)}(t[Kn],r,e)}(r,Xt(),s),v0}const ud="en-US";let Wv=ud;class cd{}class px{}class mx extends cd{constructor(n,e){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new T4(this);const r=Js(n);this._bootstrapComponents=Nu(r.bootstrap),this._r3Injector=a4(n,e,[{provide:cd,useValue:this},{provide:Mh,useValue:this.componentFactoryResolver}],hr(n),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(n)}get injector(){return this._r3Injector}destroy(){const n=this._r3Injector;!n.destroyed&&n.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(n){this.destroyCbs.push(n)}}class _0 extends px{constructor(n){super(),this.moduleType=n}create(n){return new mx(this.moduleType,n)}}class z6 extends cd{constructor(n,e,r){super(),this.componentFactoryResolver=new T4(this),this.instance=null;const s=new jy([...n,{provide:cd,useValue:this},{provide:Mh,useValue:this.componentFactoryResolver}],e||Mp(),r,new Set(["environment"]));this.injector=s,s.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(n){this.injector.onDestroy(n)}}function tm(t,n,e=null){return new z6(t,n,e).injector}let H6=(()=>{class t{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e.id)){const r=Uy(0,e.type),s=r.length>0?tm([r],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e.id,s)}return this.cachedInjectors.get(e.id)}ngOnDestroy(){try{for(const e of this.cachedInjectors.values())null!==e&&e.destroy()}finally{this.cachedInjectors.clear()}}}return t.\u0275prov=vn({token:t,providedIn:"environment",factory:()=>new t(kt(Tu))}),t})();function gx(t){t.getStandaloneInjector=n=>n.get(H6).getOrCreateStandaloneInjector(t)}function D0(t,n,e){const r=Jr()+t,s=Dt();return s[r]===Xn?nu(s,r,e?n.call(e):n()):function Lh(t,n){return t[n]}(s,r)}function Sx(t,n,e,r){return function Ex(t,n,e,r,s,o){const i=n+e;return _o(t,i,s)?nu(t,i+1,o?r.call(o,s):r(s)):function jh(t,n){const e=t[n];return e===Xn?void 0:e}(t,i+1)}(Dt(),Jr(),t,n,e,r)}function T0(t){return n=>{setTimeout(t,void 0,n)}}const Ho=class pk extends ce{constructor(n=!1){super(),this.__isAsync=n}emit(n){super.next(n)}subscribe(n,e,r){let s=n,o=e||(()=>null),i=r;if(n&&"object"==typeof n){const u=n;s=u.next?.bind(u),o=u.error?.bind(u),i=u.complete?.bind(u)}this.__isAsync&&(o=T0(o),s&&(s=T0(s)),i&&(i=T0(i)));const a=super.subscribe({next:s,error:o,complete:i});return n instanceof ee&&n.add(a),a}};function mk(){return this._results[Symbol.iterator]()}class N0{get changes(){return this._changes||(this._changes=new Ho)}constructor(n=!1){this._emitDistinctChangesOnly=n,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=N0.prototype;e[Symbol.iterator]||(e[Symbol.iterator]=mk)}get(n){return this._results[n]}map(n){return this._results.map(n)}filter(n){return this._results.filter(n)}find(n){return this._results.find(n)}reduce(n,e){return this._results.reduce(n,e)}forEach(n){this._results.forEach(n)}some(n){return this._results.some(n)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(n,e){const r=this;r.dirty=!1;const s=function ii(t){return t.flat(Number.POSITIVE_INFINITY)}(n);(this._changesDetected=!function Wg(t,n,e){if(t.length!==n.length)return!1;for(let r=0;r<t.length;r++){let s=t[r],o=n[r];if(e&&(s=e(s),o=e(o)),o!==s)return!1}return!0}(r._results,s,e))&&(r._results=s,r.length=s.length,r.last=s[this.length-1],r.first=s[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}let Ru=(()=>{class t{}return t.__NG_ELEMENT_ID__=vk,t})();const gk=Ru,yk=class extends gk{constructor(n,e,r){super(),this._declarationLView=n,this._declarationTContainer=e,this.elementRef=r}createEmbeddedView(n,e){const r=this._declarationTContainer.tView,s=Lp(this._declarationLView,r,n,16,null,r.declTNode,null,null,null,null,e||null);s[fn]=this._declarationLView[this._declarationTContainer.index];const i=this._declarationLView[us];return null!==i&&(s[us]=i.createEmbeddedView(r)),X1(r,s,n),new Fh(s)}};function vk(){return nm(Is(),Dt())}function nm(t,n){return 4&t.type?new yk(n,t,Gl(t,n)):null}let _a=(()=>{class t{}return t.__NG_ELEMENT_ID__=xk,t})();function xk(){return Ax(Is(),Dt())}const bk=_a,Nx=class extends bk{constructor(n,e,r){super(),this._lContainer=n,this._hostTNode=e,this._hostLView=r}get element(){return Gl(this._hostTNode,this._hostLView)}get injector(){return new wu(this._hostTNode,this._hostLView)}get parentInjector(){const n=hh(this._hostTNode,this._hostLView);if(Yf(n)){const e=Al(n,this._hostLView),r=kl(n);return new wu(e[Jt].data[r+8],e)}return new wu(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(n){const e=kx(this._lContainer);return null!==e&&e[n]||null}get length(){return this._lContainer.length-fs}createEmbeddedView(n,e,r){let s,o;"number"==typeof r?s=r:null!=r&&(s=r.index,o=r.injector);const i=n.createEmbeddedView(e||{},o);return this.insert(i,s),i}createComponent(n,e,r,s,o){const i=n&&!function Mc(t){return"function"==typeof t}(n);let a;if(i)a=e;else{const h=e||{};a=h.index,r=h.injector,s=h.projectableNodes,o=h.environmentInjector||h.ngModuleRef}const u=i?n:new Ph(br(n)),c=r||this.parentInjector;if(!o&&null==u.ngModule){const f=(i?c:this.parentInjector).get(Tu,null);f&&(o=f)}const l=u.create(c,s,void 0,o);return this.insert(l.hostView,a),l}insert(n,e){const r=n._lView,s=r[Jt];if(function rh(t){return eo(t[Cr])}(r)){const l=this.indexOf(n);if(-1!==l)this.detach(l);else{const h=r[Cr],f=new Nx(h,h[$s],h[Cr]);f.detach(f.indexOf(n))}}const o=this._adjustIndex(e),i=this._lContainer;!function Wn(t,n,e,r){const s=fs+r,o=e.length;r>0&&(e[s-1][uo]=n),r<o-fs?(n[uo]=e[s],ap(e,fs+r,n)):(e.push(n),n[uo]=null),n[Cr]=e;const i=n[fn];null!==i&&e!==i&&function xn(t,n){const e=t[za];n[_s]!==n[Cr][Cr][_s]&&(t[Yi]=!0),null===e?t[za]=[n]:e.push(n)}(i,n);const a=n[us];null!==a&&a.insertView(t),n[_n]|=64}(s,r,i,o);const a=S1(o,i),u=r[Kn],c=fo(u,i[xo]);return null!==c&&function At(t,n,e,r,s,o){r[vo]=s,r[$s]=n,kh(t,r,e,1,s,o)}(s,i[$s],u,r,c,a),n.attachToViewContainerRef(),ap(k0(i),o,n),n}move(n,e){return this.insert(n,e)}indexOf(n){const e=kx(this._lContainer);return null!==e?e.indexOf(n):-1}remove(n){const e=this._adjustIndex(n,-1),r=gs(this._lContainer,e);r&&(Ll(k0(this._lContainer),e),ys(r[Jt],r))}detach(n){const e=this._adjustIndex(n,-1),r=gs(this._lContainer,e);return r&&null!=Ll(k0(this._lContainer),e)?new Fh(r):null}_adjustIndex(n,e=0){return n??this.length+e}};function kx(t){return t[ya]}function k0(t){return t[ya]||(t[ya]=[])}function Ax(t,n){let e;const r=n[t.index];if(eo(r))e=r;else{let s;if(8&t.type)s=ms(r);else{const o=n[Kn];s=o.createComment("");const i=lo(t,n);Sr(o,fo(o,i),s,function ta(t,n){return t.nextSibling(n)}(o,i),!1)}n[t.index]=e=S4(r,n,s,t),Vp(n,e)}return new Nx(e,t,n)}class A0{constructor(n){this.queryList=n,this.matches=null}clone(){return new A0(this.queryList)}setDirty(){this.queryList.setDirty()}}class R0{constructor(n=[]){this.queries=n}createEmbeddedView(n){const e=n.queries;if(null!==e){const r=null!==n.contentQueries?n.contentQueries[0]:e.length,s=[];for(let o=0;o<r;o++){const i=e.getByIndex(o);s.push(this.queries[i.indexInDeclarationView].clone())}return new R0(s)}return null}insertView(n){this.dirtyQueriesWithMatches(n)}detachView(n){this.dirtyQueriesWithMatches(n)}dirtyQueriesWithMatches(n){for(let e=0;e<this.queries.length;e++)null!==Px(n,e).matches&&this.queries[e].setDirty()}}class Rx{constructor(n,e,r=null){this.predicate=n,this.flags=e,this.read=r}}class O0{constructor(n=[]){this.queries=n}elementStart(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(n,e)}elementEnd(n){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(n)}embeddedTView(n){let e=null;for(let r=0;r<this.length;r++){const s=null!==e?e.length:0,o=this.getByIndex(r).embeddedTView(n,s);o&&(o.indexInDeclarationView=r,null!==e?e.push(o):e=[o])}return null!==e?new O0(e):null}template(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(n,e)}getByIndex(n){return this.queries[n]}get length(){return this.queries.length}track(n){this.queries.push(n)}}class M0{constructor(n,e=-1){this.metadata=n,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(n,e){this.isApplyingToNode(e)&&this.matchTNode(n,e)}elementEnd(n){this._declarationNodeIndex===n.index&&(this._appliesToNextNode=!1)}template(n,e){this.elementStart(n,e)}embeddedTView(n,e){return this.isApplyingToNode(n)?(this.crossesNgTemplate=!0,this.addMatch(-n.index,e),new M0(this.metadata)):null}isApplyingToNode(n){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=n.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(n,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let s=0;s<r.length;s++){const o=r[s];this.matchTNodeWithReadOption(n,e,wk(e,o)),this.matchTNodeWithReadOption(n,e,Ml(e,n,o,!1,!1))}else r===Ru?4&e.type&&this.matchTNodeWithReadOption(n,e,-1):this.matchTNodeWithReadOption(n,e,Ml(e,n,r,!1,!1))}matchTNodeWithReadOption(n,e,r){if(null!==r){const s=this.metadata.read;if(null!==s)if(s===eu||s===_a||s===Ru&&4&e.type)this.addMatch(e.index,-2);else{const o=Ml(e,n,s,!1,!1);null!==o&&this.addMatch(e.index,o)}else this.addMatch(e.index,r)}}addMatch(n,e){null===this.matches?this.matches=[n,e]:this.matches.push(n,e)}}function wk(t,n){const e=t.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===n)return e[r+1];return null}function Sk(t,n,e,r){return-1===e?function Ck(t,n){return 11&t.type?Gl(t,n):4&t.type?nm(t,n):null}(n,t):-2===e?function Ek(t,n,e){return e===eu?Gl(n,t):e===Ru?nm(n,t):e===_a?Ax(n,t):void 0}(t,n,r):bu(t,t[Jt],e,n)}function Ox(t,n,e,r){const s=n[us].queries[r];if(null===s.matches){const o=t.data,i=e.matches,a=[];for(let u=0;u<i.length;u+=2){const c=i[u];a.push(c<0?null:Sk(n,o[c],i[u+1],e.metadata.read))}s.matches=a}return s.matches}function $0(t,n,e,r){const s=t.queries.getByIndex(e),o=s.matches;if(null!==o){const i=Ox(t,n,s,e);for(let a=0;a<o.length;a+=2){const u=o[a];if(u>0)r.push(i[a/2]);else{const c=o[a+1],l=n[-u];for(let h=fs;h<l.length;h++){const f=l[h];f[fn]===f[Cr]&&$0(f[Jt],f,c,r)}if(null!==l[za]){const h=l[za];for(let f=0;f<h.length;f++){const m=h[f];$0(m[Jt],m,c,r)}}}}}return r}function ld(t){const n=Dt(),e=or(),r=Le();st(r+1);const s=Px(e,r);if(t.dirty&&function nh(t){return 4==(4&t[_n])}(n)===(2==(2&s.metadata.flags))){if(null===s.matches)t.reset([]);else{const o=s.crossesNgTemplate?$0(e,n,r,[]):Ox(e,n,s,r);t.reset(o,aD),t.notifyOnChanges()}return!0}return!1}function Kh(t,n,e){const r=or();r.firstCreatePass&&(function Fx(t,n,e){null===t.queries&&(t.queries=new O0),t.queries.track(new M0(n,e))}(r,new Rx(t,n,e),-1),2==(2&n)&&(r.staticViewQueries=!0)),function $x(t,n,e){const r=new N0(4==(4&e));v4(t,n,r,r.destroy),null===n[us]&&(n[us]=new R0),n[us].queries.push(new A0(r))}(r,Dt(),n)}function dd(){return function _k(t,n){return t[us].queries[n].queryList}(Dt(),Le())}function Px(t,n){return t.queries.getByIndex(n)}function sm(...t){}const om=new An("Application Initializer");let im=(()=>{class t{constructor(e){this.appInits=e,this.resolve=sm,this.reject=sm,this.initialized=!1,this.done=!1,this.donePromise=new Promise((r,s)=>{this.resolve=r,this.reject=s})}runInitializers(){if(this.initialized)return;const e=[],r=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let s=0;s<this.appInits.length;s++){const o=this.appInits[s]();if(Kp(o))e.push(o);else if(G4(o)){const i=new Promise((a,u)=>{o.subscribe({complete:a,error:u})});e.push(i)}}Promise.all(e).then(()=>{r()}).catch(s=>{this.reject(s)}),0===e.length&&r(),this.initialized=!0}}return t.\u0275fac=function(e){return new(e||t)(kt(om,8))},t.\u0275prov=vn({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const qh=new An("AppId",{providedIn:"root",factory:function tb(){return`${U0()}${U0()}${U0()}`}});function U0(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const nb=new An("Platform Initializer"),rb=new An("Platform ID",{providedIn:"platform",factory:()=>"unknown"});let Kk=(()=>{class t{log(e){console.log(e)}warn(e){console.warn(e)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:t.\u0275fac,providedIn:"platform"}),t})();const Ou=new An("LocaleId",{providedIn:"root",factory:()=>v(Ou,mn.Optional|mn.SkipSelf)||function Xk(){return typeof $localize<"u"&&$localize.locale||ud}()});class Yk{constructor(n,e){this.ngModuleFactory=n,this.componentFactories=e}}let sb=(()=>{class t{compileModuleSync(e){return new _0(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const r=this.compileModuleSync(e),o=Nu(Js(e).declarations).reduce((i,a)=>{const u=br(a);return u&&i.push(new Ph(u)),i},[]);return new Yk(r,o)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const Jk=(()=>Promise.resolve(0))();function W0(t){typeof Zone>"u"?Jk.then(()=>{t&&t.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",t)}class Ts{constructor({enableLongStackTrace:n=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Ho(!1),this.onMicrotaskEmpty=new Ho(!1),this.onStable=new Ho(!1),this.onError=new Ho(!1),typeof Zone>"u")throw new Pt(908,!1);Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),n&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!r&&e,s.shouldCoalesceRunChangeDetection=r,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function eA(){let t=fr.requestAnimationFrame,n=fr.cancelAnimationFrame;if(typeof Zone<"u"&&t&&n){const e=t[Zone.__symbol__("OriginalDelegate")];e&&(t=e);const r=n[Zone.__symbol__("OriginalDelegate")];r&&(n=r)}return{nativeRequestAnimationFrame:t,nativeCancelAnimationFrame:n}}().nativeRequestAnimationFrame,function rA(t){const n=()=>{!function nA(t){t.isCheckStableRunning||-1!==t.lastRequestAnimationFrameId||(t.lastRequestAnimationFrameId=t.nativeRequestAnimationFrame.call(fr,()=>{t.fakeTopEventTask||(t.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{t.lastRequestAnimationFrameId=-1,H0(t),t.isCheckStableRunning=!0,z0(t),t.isCheckStableRunning=!1},void 0,()=>{},()=>{})),t.fakeTopEventTask.invoke()}),H0(t))}(t)};t._inner=t._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,s,o,i,a)=>{try{return ab(t),e.invokeTask(s,o,i,a)}finally{(t.shouldCoalesceEventChangeDetection&&"eventTask"===o.type||t.shouldCoalesceRunChangeDetection)&&n(),ub(t)}},onInvoke:(e,r,s,o,i,a,u)=>{try{return ab(t),e.invoke(s,o,i,a,u)}finally{t.shouldCoalesceRunChangeDetection&&n(),ub(t)}},onHasTask:(e,r,s,o)=>{e.hasTask(s,o),r===s&&("microTask"==o.change?(t._hasPendingMicrotasks=o.microTask,H0(t),z0(t)):"macroTask"==o.change&&(t.hasPendingMacrotasks=o.macroTask))},onHandleError:(e,r,s,o)=>(e.handleError(s,o),t.runOutsideAngular(()=>t.onError.emit(o)),!1)})}(s)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!Ts.isInAngularZone())throw new Pt(909,!1)}static assertNotInAngularZone(){if(Ts.isInAngularZone())throw new Pt(909,!1)}run(n,e,r){return this._inner.run(n,e,r)}runTask(n,e,r,s){const o=this._inner,i=o.scheduleEventTask("NgZoneEvent: "+s,n,tA,sm,sm);try{return o.runTask(i,e,r)}finally{o.cancelTask(i)}}runGuarded(n,e,r){return this._inner.runGuarded(n,e,r)}runOutsideAngular(n){return this._outer.run(n)}}const tA={};function z0(t){if(0==t._nesting&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function H0(t){t.hasPendingMicrotasks=!!(t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&-1!==t.lastRequestAnimationFrameId)}function ab(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function ub(t){t._nesting--,z0(t)}class sA{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Ho,this.onMicrotaskEmpty=new Ho,this.onStable=new Ho,this.onError=new Ho}run(n,e,r){return n.apply(e,r)}runGuarded(n,e,r){return n.apply(e,r)}runOutsideAngular(n){return n()}runTask(n,e,r,s){return n.apply(e,r)}}const cb=new An(""),am=new An("");let K0,j0=(()=>{class t{constructor(e,r,s){this._ngZone=e,this.registry=r,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,K0||(function oA(t){K0=t}(s),s.addToWindow(r)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{Ts.assertNotInAngularZone(),W0(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())W0(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,s){let o=-1;r&&r>0&&(o=setTimeout(()=>{this._callbacks=this._callbacks.filter(i=>i.timeoutId!==o),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:o,updateCb:s})}whenStable(e,r,s){if(s&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,s),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,r,s){return[]}}return t.\u0275fac=function(e){return new(e||t)(kt(Ts),kt(G0),kt(am))},t.\u0275prov=vn({token:t,factory:t.\u0275fac}),t})(),G0=(()=>{class t{constructor(){this._applications=new Map}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return K0?.findTestabilityInTree(this,e,r)??null}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:t.\u0275fac,providedIn:"platform"}),t})();const Mu=!1;let ic=null;const lb=new An("AllowMultipleToken"),X0=new An("PlatformDestroyListeners"),db=new An("appBootstrapListener");class hb{constructor(n,e){this.name=n,this.token=e}}function pb(t,n,e=[]){const r=`Platform: ${n}`,s=new An(r);return(o=[])=>{let i=q0();if(!i||i.injector.get(lb,!1)){const a=[...e,...o,{provide:s,useValue:!0}];t?t(a):function uA(t){if(ic&&!ic.get(lb,!1))throw new Pt(400,!1);ic=t;const n=t.get(gb);(function fb(t){const n=t.get(nb,null);n&&n.forEach(e=>e())})(t)}(function mb(t=[],n){return ku.create({name:n,providers:[{provide:F1,useValue:"platform"},{provide:X0,useValue:new Set([()=>ic=null])},...t]})}(a,r))}return function lA(t){const n=q0();if(!n)throw new Pt(401,!1);return n}()}}function q0(){return ic?.get(gb)??null}let gb=(()=>{class t{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const s=function vb(t,n){let e;return e="noop"===t?new sA:("zone.js"===t?void 0:t)||new Ts(n),e}(r?.ngZone,function yb(t){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:!(!t||!t.ngZoneEventCoalescing)||!1,shouldCoalesceRunChangeDetection:!(!t||!t.ngZoneRunCoalescing)||!1}}(r)),o=[{provide:Ts,useValue:s}];return s.run(()=>{const i=ku.create({providers:o,parent:this.injector,name:e.moduleType.name}),a=e.create(i),u=a.injector.get(Kl,null);if(!u)throw new Pt(402,!1);return s.runOutsideAngular(()=>{const c=s.onError.subscribe({next:l=>{u.handleError(l)}});a.onDestroy(()=>{cm(this._modules,a),c.unsubscribe()})}),function xb(t,n,e){try{const r=e();return Kp(r)?r.catch(s=>{throw n.runOutsideAngular(()=>t.handleError(s)),s}):r}catch(r){throw n.runOutsideAngular(()=>t.handleError(r)),r}}(u,s,()=>{const c=a.injector.get(im);return c.runInitializers(),c.donePromise.then(()=>(function zv(t){as(t,"Expected localeId to be defined"),"string"==typeof t&&(Wv=t.toLowerCase().replace(/_/g,"-"))}(a.injector.get(Ou,ud)||ud),this._moduleDoBootstrap(a),a))})})}bootstrapModule(e,r=[]){const s=bb({},r);return function iA(t,n,e){const r=new _0(e);return Promise.resolve(r)}(0,0,e).then(o=>this.bootstrapModuleFactory(o,s))}_moduleDoBootstrap(e){const r=e.injector.get(um);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(s=>r.bootstrap(s));else{if(!e.instance.ngDoBootstrap)throw new Pt(-403,!1);e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Pt(404,!1);this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const e=this._injector.get(X0,null);e&&(e.forEach(r=>r()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return t.\u0275fac=function(e){return new(e||t)(kt(ku))},t.\u0275prov=vn({token:t,factory:t.\u0275fac,providedIn:"platform"}),t})();function bb(t,n){return Array.isArray(n)?n.reduce(bb,t):{...t,...n}}let um=(()=>{class t{get destroyed(){return this._destroyed}get injector(){return this._injector}constructor(e,r,s){this._zone=e,this._injector=r,this._exceptionHandler=s,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this._destroyed=!1,this._destroyListeners=[],this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const o=new $e(a=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{a.next(this._stable),a.complete()})}),i=new $e(a=>{let u;this._zone.runOutsideAngular(()=>{u=this._zone.onStable.subscribe(()=>{Ts.assertNotInAngularZone(),W0(()=>{!this._stable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks&&(this._stable=!0,a.next(!0))})})});const c=this._zone.onUnstable.subscribe(()=>{Ts.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{a.next(!1)}))});return()=>{u.unsubscribe(),c.unsubscribe()}});this.isStable=function os(...t){let n=Number.POSITIVE_INFINITY,e=null,r=t[t.length-1];return He(r)?(e=t.pop(),t.length>1&&"number"==typeof t[t.length-1]&&(n=t.pop())):"number"==typeof r&&(n=t.pop()),null===e&&1===t.length&&t[0]instanceof $e?t[0]:Fr(n)(go(t,e))}(o,i.pipe(function Ur(){return t=>is()(function nr(t,n){return function(r){let s;if(s="function"==typeof t?t:function(){return t},"function"==typeof n)return r.lift(new Ro(s,n));const o=Object.create(r,oo);return o.source=r,o.subjectFactory=s,o}}(Re)(t))}()))}bootstrap(e,r){const s=e instanceof Ky;if(!this._injector.get(im).done){!s&&function ga(t){const n=br(t)||Os(t)||Ms(t);return null!==n&&n.standalone}(e);throw new Pt(405,Mu)}let i;i=s?e:this._injector.get(Mh).resolveComponentFactory(e),this.componentTypes.push(i.componentType);const a=function aA(t){return t.isBoundToModule}(i)?void 0:this._injector.get(cd),c=i.create(ku.NULL,[],r||i.selector,a),l=c.location.nativeElement,h=c.injector.get(cb,null);return h?.registerApplication(l),c.onDestroy(()=>{this.detachView(c.hostView),cm(this.components,c),h?.unregisterApplication(l)}),this._loadComponent(c),c}tick(){if(this._runningTick)throw new Pt(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;cm(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e);const r=this._injector.get(db,[]);r.push(...this._bootstrapListeners),r.forEach(s=>s(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>cm(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new Pt(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return t.\u0275fac=function(e){return new(e||t)(kt(Ts),kt(Tu),kt(Kl))},t.\u0275prov=vn({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function cm(t,n){const e=t.indexOf(n);e>-1&&t.splice(e,1)}let Y0=(()=>{class t{}return t.__NG_ELEMENT_ID__=hA,t})();function hA(t){return function fA(t,n,e){if(ri(t)&&!e){const r=to(t.index,n);return new Fh(r,r)}return 47&t.type?new Fh(n[_s],n):null}(Is(),Dt(),16==(16&t))}class _b{constructor(){}supports(n){return jp(n)}create(n){return new xA(n)}}const vA=(t,n)=>n;class xA{constructor(n){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=n||vA}forEachItem(n){let e;for(e=this._itHead;null!==e;e=e._next)n(e)}forEachOperation(n){let e=this._itHead,r=this._removalsHead,s=0,o=null;for(;e||r;){const i=!r||e&&e.currentIndex<Db(r,s,o)?e:r,a=Db(i,s,o),u=i.currentIndex;if(i===r)s--,r=r._nextRemoved;else if(e=e._next,null==i.previousIndex)s++;else{o||(o=[]);const c=a-s,l=u-s;if(c!=l){for(let f=0;f<c;f++){const m=f<o.length?o[f]:o[f]=0,y=m+f;l<=y&&y<c&&(o[f]=m+1)}o[i.previousIndex]=l-c}}a!==u&&n(i,a,u)}}forEachPreviousItem(n){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)n(e)}forEachAddedItem(n){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)n(e)}forEachMovedItem(n){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)n(e)}forEachRemovedItem(n){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)n(e)}forEachIdentityChange(n){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)n(e)}diff(n){if(null==n&&(n=[]),!jp(n))throw new Pt(900,!1);return this.check(n)?this:null}onDestroy(){}check(n){this._reset();let s,o,i,e=this._itHead,r=!1;if(Array.isArray(n)){this.length=n.length;for(let a=0;a<this.length;a++)o=n[a],i=this._trackByFn(a,o),null!==e&&Object.is(e.trackById,i)?(r&&(e=this._verifyReinsertion(e,o,i,a)),Object.is(e.item,o)||this._addIdentityChange(e,o)):(e=this._mismatch(e,o,i,a),r=!0),e=e._next}else s=0,function HT(t,n){if(Array.isArray(t))for(let e=0;e<t.length;e++)n(t[e]);else{const e=t[Symbol.iterator]();let r;for(;!(r=e.next()).done;)n(r.value)}}(n,a=>{i=this._trackByFn(s,a),null!==e&&Object.is(e.trackById,i)?(r&&(e=this._verifyReinsertion(e,a,i,s)),Object.is(e.item,a)||this._addIdentityChange(e,a)):(e=this._mismatch(e,a,i,s),r=!0),e=e._next,s++}),this.length=s;return this._truncate(e),this.collection=n,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let n;for(n=this._previousItHead=this._itHead;null!==n;n=n._next)n._nextPrevious=n._next;for(n=this._additionsHead;null!==n;n=n._nextAdded)n.previousIndex=n.currentIndex;for(this._additionsHead=this._additionsTail=null,n=this._movesHead;null!==n;n=n._nextMoved)n.previousIndex=n.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(n,e,r,s){let o;return null===n?o=this._itTail:(o=n._prev,this._remove(n)),null!==(n=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null))?(Object.is(n.item,e)||this._addIdentityChange(n,e),this._reinsertAfter(n,o,s)):null!==(n=null===this._linkedRecords?null:this._linkedRecords.get(r,s))?(Object.is(n.item,e)||this._addIdentityChange(n,e),this._moveAfter(n,o,s)):n=this._addAfter(new bA(e,r),o,s),n}_verifyReinsertion(n,e,r,s){let o=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null);return null!==o?n=this._reinsertAfter(o,n._prev,s):n.currentIndex!=s&&(n.currentIndex=s,this._addToMoves(n,s)),n}_truncate(n){for(;null!==n;){const e=n._next;this._addToRemovals(this._unlink(n)),n=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(n,e,r){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(n);const s=n._prevRemoved,o=n._nextRemoved;return null===s?this._removalsHead=o:s._nextRemoved=o,null===o?this._removalsTail=s:o._prevRemoved=s,this._insertAfter(n,e,r),this._addToMoves(n,r),n}_moveAfter(n,e,r){return this._unlink(n),this._insertAfter(n,e,r),this._addToMoves(n,r),n}_addAfter(n,e,r){return this._insertAfter(n,e,r),this._additionsTail=null===this._additionsTail?this._additionsHead=n:this._additionsTail._nextAdded=n,n}_insertAfter(n,e,r){const s=null===e?this._itHead:e._next;return n._next=s,n._prev=e,null===s?this._itTail=n:s._prev=n,null===e?this._itHead=n:e._next=n,null===this._linkedRecords&&(this._linkedRecords=new Ib),this._linkedRecords.put(n),n.currentIndex=r,n}_remove(n){return this._addToRemovals(this._unlink(n))}_unlink(n){null!==this._linkedRecords&&this._linkedRecords.remove(n);const e=n._prev,r=n._next;return null===e?this._itHead=r:e._next=r,null===r?this._itTail=e:r._prev=e,n}_addToMoves(n,e){return n.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=n:this._movesTail._nextMoved=n),n}_addToRemovals(n){return null===this._unlinkedRecords&&(this._unlinkedRecords=new Ib),this._unlinkedRecords.put(n),n.currentIndex=null,n._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=n,n._prevRemoved=null):(n._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=n),n}_addIdentityChange(n,e){return n.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=n:this._identityChangesTail._nextIdentityChange=n,n}}class bA{constructor(n,e){this.item=n,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class wA{constructor(){this._head=null,this._tail=null}add(n){null===this._head?(this._head=this._tail=n,n._nextDup=null,n._prevDup=null):(this._tail._nextDup=n,n._prevDup=this._tail,n._nextDup=null,this._tail=n)}get(n,e){let r;for(r=this._head;null!==r;r=r._nextDup)if((null===e||e<=r.currentIndex)&&Object.is(r.trackById,n))return r;return null}remove(n){const e=n._prevDup,r=n._nextDup;return null===e?this._head=r:e._nextDup=r,null===r?this._tail=e:r._prevDup=e,null===this._head}}class Ib{constructor(){this.map=new Map}put(n){const e=n.trackById;let r=this.map.get(e);r||(r=new wA,this.map.set(e,r)),r.add(n)}get(n,e){const s=this.map.get(n);return s?s.get(n,e):null}remove(n){const e=n.trackById;return this.map.get(e).remove(n)&&this.map.delete(e),n}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function Db(t,n,e){const r=t.previousIndex;if(null===r)return r;let s=0;return e&&r<e.length&&(s=e[r]),r+n+s}function Nb(){return new hm([new _b])}let hm=(()=>{class t{constructor(e){this.factories=e}static create(e,r){if(null!=r){const s=r.factories.slice();e=e.concat(s)}return new t(e)}static extend(e){return{provide:t,useFactory:r=>t.create(e,r||Nb()),deps:[[t,new Eu,new Fc]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(null!=r)return r;throw new Pt(901,!1)}}return t.\u0275prov=vn({token:t,providedIn:"root",factory:Nb}),t})();const IA=pb(null,"core",[]);let DA=(()=>{class t{constructor(e){}}return t.\u0275fac=function(e){return new(e||t)(kt(um))},t.\u0275mod=Hs({type:t}),t.\u0275inj=Ws({}),t})();function t2(t){return"boolean"==typeof t?t:null!=t&&"false"!==t}let n2=null;function Kc(){return n2}class kA{}const di=new An("DocumentToken");let r2=(()=>{class t{historyGo(e){throw new Error("Not implemented")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:function(){return function AA(){return kt(Ab)}()},providedIn:"platform"}),t})();const RA=new An("Location Initialized");let Ab=(()=>{class t extends r2{constructor(e){super(),this._doc=e,this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Kc().getBaseHref(this._doc)}onPopState(e){const r=Kc().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){const r=Kc().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(e){this._location.pathname=e}pushState(e,r,s){Rb()?this._history.pushState(e,r,s):this._location.hash=s}replaceState(e,r,s){Rb()?this._history.replaceState(e,r,s):this._location.hash=s}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return t.\u0275fac=function(e){return new(e||t)(kt(di))},t.\u0275prov=vn({token:t,factory:function(){return function OA(){return new Ab(kt(di))}()},providedIn:"platform"}),t})();function Rb(){return!!window.history.pushState}function s2(t,n){if(0==t.length)return n;if(0==n.length)return t;let e=0;return t.endsWith("/")&&e++,n.startsWith("/")&&e++,2==e?t+n.substring(1):1==e?t+n:t+"/"+n}function Ob(t){const n=t.match(/#|\?|$/),e=n&&n.index||t.length;return t.slice(0,e-("/"===t[e-1]?1:0))+t.slice(e)}function $u(t){return t&&"?"!==t[0]?"?"+t:t}let Xc=(()=>{class t{historyGo(e){throw new Error("Not implemented")}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:function(){return v($b)},providedIn:"root"}),t})();const Mb=new An("appBaseHref");let $b=(()=>{class t extends Xc{constructor(e,r){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??v(di).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return s2(this._baseHref,e)}path(e=!1){const r=this._platformLocation.pathname+$u(this._platformLocation.search),s=this._platformLocation.hash;return s&&e?`${r}${s}`:r}pushState(e,r,s,o){const i=this.prepareExternalUrl(s+$u(o));this._platformLocation.pushState(e,r,i)}replaceState(e,r,s,o){const i=this.prepareExternalUrl(s+$u(o));this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return t.\u0275fac=function(e){return new(e||t)(kt(r2),kt(Mb,8))},t.\u0275prov=vn({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),MA=(()=>{class t extends Xc{constructor(e,r){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(e){const r=s2(this._baseHref,e);return r.length>0?"#"+r:r}pushState(e,r,s,o){let i=this.prepareExternalUrl(s+$u(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.pushState(e,r,i)}replaceState(e,r,s,o){let i=this.prepareExternalUrl(s+$u(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return t.\u0275fac=function(e){return new(e||t)(kt(r2),kt(Mb,8))},t.\u0275prov=vn({token:t,factory:t.\u0275fac}),t})(),o2=(()=>{class t{constructor(e){this._subject=new Ho,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;const r=this._locationStrategy.getBaseHref();this._basePath=function PA(t){if(new RegExp("^(https?:)?//").test(t)){const[,e]=t.split(/\/\/[^\/]+/);return e}return t}(Ob(Fb(r))),this._locationStrategy.onPopState(s=>{this._subject.emit({url:this.path(!0),pop:!0,state:s.state,type:s.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+$u(r))}normalize(e){return t.stripTrailingSlash(function FA(t,n){if(!t||!n.startsWith(t))return n;const e=n.substring(t.length);return""===e||["/",";","?","#"].includes(e[0])?e:n}(this._basePath,Fb(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,r="",s=null){this._locationStrategy.pushState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+$u(r)),s)}replaceState(e,r="",s=null){this._locationStrategy.replaceState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+$u(r)),s)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)})),()=>{const r=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(s=>s(e,r))}subscribe(e,r,s){return this._subject.subscribe({next:e,error:r,complete:s})}}return t.normalizeQueryParams=$u,t.joinWithSlash=s2,t.stripTrailingSlash=Ob,t.\u0275fac=function(e){return new(e||t)(kt(Xc))},t.\u0275prov=vn({token:t,factory:function(){return function $A(){return new o2(kt(Xc))}()},providedIn:"root"}),t})();function Fb(t){return t.replace(/\/index.html$/,"")}class S5{constructor(n,e,r,s){this.$implicit=n,this.ngForOf=e,this.index=r,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let Xb=(()=>{class t{set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}constructor(e,r,s){this._viewContainer=e,this._template=r,this._differs=s,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const e=this._ngForOf;!this._differ&&e&&(this._differ=this._differs.find(e).create(this.ngForTrackBy))}if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const r=this._viewContainer;e.forEachOperation((s,o,i)=>{if(null==s.previousIndex)r.createEmbeddedView(this._template,new S5(s.item,this._ngForOf,-1,-1),null===i?void 0:i);else if(null==i)r.remove(null===o?void 0:o);else if(null!==o){const a=r.get(o);r.move(a,i),qb(a,s)}});for(let s=0,o=r.length;s<o;s++){const a=r.get(s).context;a.index=s,a.count=o,a.ngForOf=this._ngForOf}e.forEachIdentityChange(s=>{qb(r.get(s.currentIndex),s)})}static ngTemplateContextGuard(e,r){return!0}}return t.\u0275fac=function(e){return new(e||t)(Rn(_a),Rn(Ru),Rn(hm))},t.\u0275dir=Es({type:t,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"},standalone:!0}),t})();function qb(t,n){t.context.$implicit=n.item}let Jh=(()=>{class t{constructor(e,r){this._viewContainer=e,this._context=new _5,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){Yb("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){Yb("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,r){return!0}}return t.\u0275fac=function(e){return new(e||t)(Rn(_a),Rn(Ru))},t.\u0275dir=Es({type:t,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0}),t})();class _5{constructor(){this.$implicit=null,this.ngIf=null}}function Yb(t,n){if(n&&!n.createEmbeddedView)throw new Error(`${t} must be a TemplateRef, but received '${hr(n)}'.`)}let Y5=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Hs({type:t}),t.\u0275inj=Ws({}),t})();let eR=(()=>{class t{}return t.\u0275prov=vn({token:t,providedIn:"root",factory:()=>new tR(kt(di),window)}),t})();class tR{constructor(n,e){this.document=n,this.window=e,this.offset=()=>[0,0]}setOffset(n){this.offset=Array.isArray(n)?()=>n:n}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(n){this.supportsScrolling()&&this.window.scrollTo(n[0],n[1])}scrollToAnchor(n){if(!this.supportsScrolling())return;const e=function nR(t,n){const e=t.getElementById(n)||t.getElementsByName(n)[0];if(e)return e;if("function"==typeof t.createTreeWalker&&t.body&&(t.body.createShadowRoot||t.body.attachShadow)){const r=t.createTreeWalker(t.body,NodeFilter.SHOW_ELEMENT);let s=r.currentNode;for(;s;){const o=s.shadowRoot;if(o){const i=o.getElementById(n)||o.querySelector(`[name="${n}"]`);if(i)return i}s=r.nextNode()}}return null}(this.document,n);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(n){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=n)}}scrollToElement(n){const e=n.getBoundingClientRect(),r=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,o=this.offset();this.window.scrollTo(r-o[0],s-o[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const n=ew(this.window.history)||ew(Object.getPrototypeOf(this.window.history));return!(!n||!n.writable&&!n.set)}catch{return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}function ew(t){return Object.getOwnPropertyDescriptor(t,"scrollRestoration")}class kR extends kA{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class C2 extends kR{static makeCurrent(){!function NA(t){n2||(n2=t)}(new C2)}onAndCancel(n,e,r){return n.addEventListener(e,r,!1),()=>{n.removeEventListener(e,r,!1)}}dispatchEvent(n,e){n.dispatchEvent(e)}remove(n){n.parentNode&&n.parentNode.removeChild(n)}createElement(n,e){return(e=e||this.getDefaultDocument()).createElement(n)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(n){return n.nodeType===Node.ELEMENT_NODE}isShadowRoot(n){return n instanceof DocumentFragment}getGlobalEventTarget(n,e){return"window"===e?window:"document"===e?n:"body"===e?n.body:null}getBaseHref(n){const e=function AR(){return tf=tf||document.querySelector("base"),tf?tf.getAttribute("href"):null}();return null==e?null:function RR(t){Em=Em||document.createElement("a"),Em.setAttribute("href",t);const n=Em.pathname;return"/"===n.charAt(0)?n:`/${n}`}(e)}resetBaseElement(){tf=null}getUserAgent(){return window.navigator.userAgent}getCookie(n){return function b5(t,n){n=encodeURIComponent(n);for(const e of t.split(";")){const r=e.indexOf("="),[s,o]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(s.trim()===n)return decodeURIComponent(o)}return null}(document.cookie,n)}}let Em,tf=null;const ow=new An("TRANSITION_ID"),MR=[{provide:om,useFactory:function OR(t,n,e){return()=>{e.get(im).donePromise.then(()=>{const r=Kc(),s=n.querySelectorAll(`style[ng-transition="${t}"]`);for(let o=0;o<s.length;o++)r.remove(s[o])})}},deps:[ow,di,ku],multi:!0}];let FR=(()=>{class t{build(){return new XMLHttpRequest}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:t.\u0275fac}),t})();const _m=new An("EventManagerPlugins");let Im=(()=>{class t{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(s=>{s.manager=this}),this._plugins=e.slice().reverse()}addEventListener(e,r,s){return this._findPluginFor(r).addEventListener(e,r,s)}addGlobalEventListener(e,r,s){return this._findPluginFor(r).addGlobalEventListener(e,r,s)}getZone(){return this._zone}_findPluginFor(e){const r=this._eventNameToPlugin.get(e);if(r)return r;const s=this._plugins;for(let o=0;o<s.length;o++){const i=s[o];if(i.supports(e))return this._eventNameToPlugin.set(e,i),i}throw new Error(`No event manager plugin found for event ${e}`)}}return t.\u0275fac=function(e){return new(e||t)(kt(_m),kt(Ts))},t.\u0275prov=vn({token:t,factory:t.\u0275fac}),t})();class iw{constructor(n){this._doc=n}addGlobalEventListener(n,e,r){const s=Kc().getGlobalEventTarget(this._doc,n);if(!s)throw new Error(`Unsupported event target ${s} for event ${e}`);return this.addEventListener(s,e,r)}}let aw=(()=>{class t{constructor(){this.usageCount=new Map}addStyles(e){for(const r of e)1===this.changeUsageCount(r,1)&&this.onStyleAdded(r)}removeStyles(e){for(const r of e)0===this.changeUsageCount(r,-1)&&this.onStyleRemoved(r)}onStyleRemoved(e){}onStyleAdded(e){}getAllStyles(){return this.usageCount.keys()}changeUsageCount(e,r){const s=this.usageCount;let o=s.get(e)??0;return o+=r,o>0?s.set(e,o):s.delete(e),o}ngOnDestroy(){for(const e of this.getAllStyles())this.onStyleRemoved(e);this.usageCount.clear()}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:t.\u0275fac}),t})(),nf=(()=>{class t extends aw{constructor(e){super(),this.doc=e,this.styleRef=new Map,this.hostNodes=new Set,this.resetHostNodes()}onStyleAdded(e){for(const r of this.hostNodes)this.addStyleToHost(r,e)}onStyleRemoved(e){const r=this.styleRef;r.get(e)?.forEach(o=>o.remove()),r.delete(e)}ngOnDestroy(){super.ngOnDestroy(),this.styleRef.clear(),this.resetHostNodes()}addHost(e){this.hostNodes.add(e);for(const r of this.getAllStyles())this.addStyleToHost(e,r)}removeHost(e){this.hostNodes.delete(e)}addStyleToHost(e,r){const s=this.doc.createElement("style");s.textContent=r,e.appendChild(s);const o=this.styleRef.get(r);o?o.push(s):this.styleRef.set(r,[s])}resetHostNodes(){const e=this.hostNodes;e.clear(),e.add(this.doc.head)}}return t.\u0275fac=function(e){return new(e||t)(kt(di))},t.\u0275prov=vn({token:t,factory:t.\u0275fac}),t})();const S2={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},E2=/%COMP%/g,lw=new An("RemoveStylesOnCompDestory",{providedIn:"root",factory:()=>!1});function dw(t,n){return n.flat(100).map(e=>e.replace(E2,t))}function hw(t){return n=>{if("__ngUnwrap__"===n)return t;!1===t(n)&&(n.preventDefault(),n.returnValue=!1)}}let _2=(()=>{class t{constructor(e,r,s,o){this.eventManager=e,this.sharedStylesHost=r,this.appId=s,this.removeStylesOnCompDestory=o,this.rendererByCompId=new Map,this.defaultRenderer=new I2(e)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;const s=this.getOrCreateRenderer(e,r);return s instanceof mw?s.applyToHost(e):s instanceof D2&&s.applyStyles(),s}getOrCreateRenderer(e,r){const s=this.rendererByCompId;let o=s.get(r.id);if(!o){const i=this.eventManager,a=this.sharedStylesHost,u=this.removeStylesOnCompDestory;switch(r.encapsulation){case ut.Emulated:o=new mw(i,a,r,this.appId,u);break;case ut.ShadowDom:return new zR(i,a,e,r);default:o=new D2(i,a,r,u)}o.onDestroy=()=>s.delete(r.id),s.set(r.id,o)}return o}ngOnDestroy(){this.rendererByCompId.clear()}begin(){}end(){}}return t.\u0275fac=function(e){return new(e||t)(kt(Im),kt(nf),kt(qh),kt(lw))},t.\u0275prov=vn({token:t,factory:t.\u0275fac}),t})();class I2{constructor(n){this.eventManager=n,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(n,e){return e?document.createElementNS(S2[e]||e,n):document.createElement(n)}createComment(n){return document.createComment(n)}createText(n){return document.createTextNode(n)}appendChild(n,e){(pw(n)?n.content:n).appendChild(e)}insertBefore(n,e,r){n&&(pw(n)?n.content:n).insertBefore(e,r)}removeChild(n,e){n&&n.removeChild(e)}selectRootElement(n,e){let r="string"==typeof n?document.querySelector(n):n;if(!r)throw new Error(`The selector "${n}" did not match any elements`);return e||(r.textContent=""),r}parentNode(n){return n.parentNode}nextSibling(n){return n.nextSibling}setAttribute(n,e,r,s){if(s){e=s+":"+e;const o=S2[s];o?n.setAttributeNS(o,e,r):n.setAttribute(e,r)}else n.setAttribute(e,r)}removeAttribute(n,e,r){if(r){const s=S2[r];s?n.removeAttributeNS(s,e):n.removeAttribute(`${r}:${e}`)}else n.removeAttribute(e)}addClass(n,e){n.classList.add(e)}removeClass(n,e){n.classList.remove(e)}setStyle(n,e,r,s){s&(Co.DashCase|Co.Important)?n.style.setProperty(e,r,s&Co.Important?"important":""):n.style[e]=r}removeStyle(n,e,r){r&Co.DashCase?n.style.removeProperty(e):n.style[e]=""}setProperty(n,e,r){n[e]=r}setValue(n,e){n.nodeValue=e}listen(n,e,r){return"string"==typeof n?this.eventManager.addGlobalEventListener(n,e,hw(r)):this.eventManager.addEventListener(n,e,hw(r))}}function pw(t){return"TEMPLATE"===t.tagName&&void 0!==t.content}class zR extends I2{constructor(n,e,r,s){super(n),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const o=dw(s.id,s.styles);for(const i of o){const a=document.createElement("style");a.textContent=i,this.shadowRoot.appendChild(a)}}nodeOrShadowRoot(n){return n===this.hostEl?this.shadowRoot:n}appendChild(n,e){return super.appendChild(this.nodeOrShadowRoot(n),e)}insertBefore(n,e,r){return super.insertBefore(this.nodeOrShadowRoot(n),e,r)}removeChild(n,e){return super.removeChild(this.nodeOrShadowRoot(n),e)}parentNode(n){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}}class D2 extends I2{constructor(n,e,r,s,o=r.id){super(n),this.sharedStylesHost=e,this.removeStylesOnCompDestory=s,this.rendererUsageCount=0,this.styles=dw(o,r.styles)}applyStyles(){this.sharedStylesHost.addStyles(this.styles),this.rendererUsageCount++}destroy(){this.removeStylesOnCompDestory&&(this.sharedStylesHost.removeStyles(this.styles),this.rendererUsageCount--,0===this.rendererUsageCount&&this.onDestroy?.())}}class mw extends D2{constructor(n,e,r,s,o){const i=s+"-"+r.id;super(n,e,r,o,i),this.contentAttr=function VR(t){return"_ngcontent-%COMP%".replace(E2,t)}(i),this.hostAttr=function UR(t){return"_nghost-%COMP%".replace(E2,t)}(i)}applyToHost(n){this.applyStyles(),this.setAttribute(n,this.hostAttr,"")}createElement(n,e){const r=super.createElement(n,e);return super.setAttribute(r,this.contentAttr,""),r}}let HR=(()=>{class t extends iw{constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,s){return e.addEventListener(r,s,!1),()=>this.removeEventListener(e,r,s)}removeEventListener(e,r,s){return e.removeEventListener(r,s)}}return t.\u0275fac=function(e){return new(e||t)(kt(di))},t.\u0275prov=vn({token:t,factory:t.\u0275fac}),t})();const gw=["alt","control","meta","shift"],jR={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},GR={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey};let KR=(()=>{class t extends iw{constructor(e){super(e)}supports(e){return null!=t.parseEventName(e)}addEventListener(e,r,s){const o=t.parseEventName(r),i=t.eventCallback(o.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Kc().onAndCancel(e,o.domEventName,i))}static parseEventName(e){const r=e.toLowerCase().split("."),s=r.shift();if(0===r.length||"keydown"!==s&&"keyup"!==s)return null;const o=t._normalizeKey(r.pop());let i="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),i="code."),gw.forEach(c=>{const l=r.indexOf(c);l>-1&&(r.splice(l,1),i+=c+".")}),i+=o,0!=r.length||0===o.length)return null;const u={};return u.domEventName=s,u.fullKey=i,u}static matchEventFullKeyCode(e,r){let s=jR[e.key]||e.key,o="";return r.indexOf("code.")>-1&&(s=e.code,o="code."),!(null==s||!s)&&(s=s.toLowerCase()," "===s?s="space":"."===s&&(s="dot"),gw.forEach(i=>{i!==s&&(0,GR[i])(e)&&(o+=i+".")}),o+=s,o===r)}static eventCallback(e,r,s){return o=>{t.matchEventFullKeyCode(o,e)&&s.runGuarded(()=>r(o))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return t.\u0275fac=function(e){return new(e||t)(kt(di))},t.\u0275prov=vn({token:t,factory:t.\u0275fac}),t})();const vw=[{provide:rb,useValue:"browser"},{provide:nb,useValue:function XR(){C2.makeCurrent()},multi:!0},{provide:di,useFactory:function YR(){return function _I(t){D1=t}(document),document},deps:[]}],ZR=pb(IA,"browser",vw),xw=new An(""),bw=[{provide:am,useClass:class $R{addToWindow(n){fr.getAngularTestability=(r,s=!0)=>{const o=n.findTestabilityInTree(r,s);if(null==o)throw new Error("Could not find testability for element.");return o},fr.getAllAngularTestabilities=()=>n.getAllTestabilities(),fr.getAllAngularRootElements=()=>n.getAllRootElements(),fr.frameworkStabilizers||(fr.frameworkStabilizers=[]),fr.frameworkStabilizers.push(r=>{const s=fr.getAllAngularTestabilities();let o=s.length,i=!1;const a=function(u){i=i||u,o--,0==o&&r(i)};s.forEach(function(u){u.whenStable(a)})})}findTestabilityInTree(n,e,r){return null==e?null:n.getTestability(e)??(r?Kc().isShadowRoot(e)?this.findTestabilityInTree(n,e.host,!0):this.findTestabilityInTree(n,e.parentElement,!0):null)}},deps:[]},{provide:cb,useClass:j0,deps:[Ts,G0,am]},{provide:j0,useClass:j0,deps:[Ts,G0,am]}],ww=[{provide:F1,useValue:"root"},{provide:Kl,useFactory:function qR(){return new Kl},deps:[]},{provide:_m,useClass:HR,multi:!0,deps:[di,Ts,rb]},{provide:_m,useClass:KR,multi:!0,deps:[di]},{provide:_2,useClass:_2,deps:[Im,nf,qh,lw]},{provide:qy,useExisting:_2},{provide:aw,useExisting:nf},{provide:nf,useClass:nf,deps:[di]},{provide:Im,useClass:Im,deps:[_m,Ts]},{provide:class rR{},useClass:FR,deps:[]},[]];let QR=(()=>{class t{constructor(e){}static withServerTransition(e){return{ngModule:t,providers:[{provide:qh,useValue:e.appId},{provide:ow,useExisting:qh},MR]}}}return t.\u0275fac=function(e){return new(e||t)(kt(xw,12))},t.\u0275mod=Hs({type:t}),t.\u0275inj=Ws({providers:[...ww,...bw],imports:[Y5,DA]}),t})(),Cw=(()=>{class t{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}}return t.\u0275fac=function(e){return new(e||t)(kt(di))},t.\u0275prov=vn({token:t,factory:function(e){let r=null;return r=e?new e:function eO(){return new Cw(kt(di))}(),r},providedIn:"root"}),t})();function Nn(...t){let n=t[t.length-1];return He(n)?(t.pop(),ds(t,n)):go(t)}typeof window<"u"&&window;class Na extends ce{constructor(n){super(),this._value=n}get value(){return this.getValue()}_subscribe(n){const e=super._subscribe(n);return e&&!e.closed&&n.next(this._value),e}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new $;return this._value}next(n){super.next(this._value=n)}}const Dm=(()=>{function t(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return t.prototype=Object.create(Error.prototype),t})();class iO extends xe{notifyNext(n,e,r,s,o){this.destination.next(e)}notifyError(n,e){this.destination.error(n)}notifyComplete(n){this.destination.complete()}}class aO extends xe{constructor(n,e,r){super(),this.parent=n,this.outerValue=e,this.outerIndex=r,this.index=0}_next(n){this.parent.notifyNext(this.outerValue,n,this.outerIndex,this.index++,this)}_error(n){this.parent.notifyError(n,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}function uO(t,n,e,r,s=new aO(t,e,r)){if(!s.closed)return n instanceof $e?n.subscribe(s):dn(n)(s)}const _w={};function Iw(...t){let n,e;return He(t[t.length-1])&&(e=t.pop()),"function"==typeof t[t.length-1]&&(n=t.pop()),1===t.length&&Ie(t[0])&&(t=t[0]),go(t,e).lift(new cO(n))}class cO{constructor(n){this.resultSelector=n}call(n,e){return e.subscribe(new lO(n,this.resultSelector))}}class lO extends iO{constructor(n,e){super(n),this.resultSelector=e,this.active=0,this.values=[],this.observables=[]}_next(n){this.values.push(_w),this.observables.push(n)}_complete(){const n=this.observables,e=n.length;if(0===e)this.destination.complete();else{this.active=e,this.toRespond=e;for(let r=0;r<e;r++)this.add(uO(this,n[r],void 0,r))}}notifyComplete(n){0==(this.active-=1)&&this.destination.complete()}notifyNext(n,e,r){const s=this.values,i=this.toRespond?s[r]===_w?--this.toRespond:this.toRespond:0;s[r]=e,0===i&&(this.resultSelector?this._tryResultSelector(s):this.destination.next(s.slice()))}_tryResultSelector(n){let e;try{e=this.resultSelector.apply(this,n)}catch(r){return void this.destination.error(r)}this.destination.next(e)}}function k2(...t){return function dO(){return Fr(1)}()(Nn(...t))}const qc=new $e(t=>t.complete());function A2(t){return t?function hO(t){return new $e(n=>t.schedule(()=>n.complete()))}(t):qc}function Dw(t){return new $e(n=>{let e;try{e=t()}catch(s){return void n.error(s)}return(e?Nt(e):A2()).subscribe(n)})}function rf(t,n){return new $e(n?e=>n.schedule(fO,0,{error:t,subscriber:e}):e=>e.error(t))}function fO({error:t,subscriber:n}){n.error(t)}function ka(t,n){return"function"==typeof n?e=>e.pipe(ka((r,s)=>Nt(t(r,s)).pipe(Me((o,i)=>n(r,o,s,i))))):e=>e.lift(new pO(t))}class pO{constructor(n){this.project=n}call(n,e){return e.subscribe(new mO(n,this.project))}}class mO extends Jn{constructor(n,e){super(n),this.project=e,this.index=0}_next(n){let e;const r=this.index++;try{e=this.project(n,r)}catch(s){return void this.destination.error(s)}this._innerSub(e)}_innerSub(n){const e=this.innerSubscription;e&&e.unsubscribe();const r=new wn(this),s=this.destination;s.add(r),this.innerSubscription=$r(n,r),this.innerSubscription!==r&&s.add(this.innerSubscription)}_complete(){const{innerSubscription:n}=this;(!n||n.closed)&&super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&&super._complete()}notifyNext(n){this.destination.next(n)}}const Tw=(()=>{function t(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return t.prototype=Object.create(Error.prototype),t})();function pd(t){return n=>0===t?A2():n.lift(new gO(t))}class gO{constructor(n){if(this.total=n,this.total<0)throw new Tw}call(n,e){return e.subscribe(new yO(n,this.total))}}class yO extends xe{constructor(n,e){super(n),this.total=e,this.count=0}_next(n){const e=this.total,r=++this.count;r<=e&&(this.destination.next(n),r===e&&(this.destination.complete(),this.unsubscribe()))}}function uc(t,n){return function(r){return r.lift(new xO(t,n))}}class xO{constructor(n,e){this.predicate=n,this.thisArg=e}call(n,e){return e.subscribe(new bO(n,this.predicate,this.thisArg))}}class bO extends xe{constructor(n,e,r){super(n),this.predicate=e,this.thisArg=r,this.count=0}_next(n){let e;try{e=this.predicate.call(this.thisArg,n,this.count++)}catch(r){return void this.destination.error(r)}e&&this.destination.next(n)}}function Tm(t=null){return n=>n.lift(new wO(t))}class wO{constructor(n){this.defaultValue=n}call(n,e){return e.subscribe(new CO(n,this.defaultValue))}}class CO extends xe{constructor(n,e){super(n),this.defaultValue=e,this.isEmpty=!0}_next(n){this.isEmpty=!1,this.destination.next(n)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function Nw(t=_O){return n=>n.lift(new SO(t))}class SO{constructor(n){this.errorFactory=n}call(n,e){return e.subscribe(new EO(n,this.errorFactory))}}class EO extends xe{constructor(n,e){super(n),this.errorFactory=e,this.hasValue=!1}_next(n){this.hasValue=!0,this.destination.next(n)}_complete(){if(this.hasValue)return this.destination.complete();{let n;try{n=this.errorFactory()}catch(e){n=e}this.destination.error(n)}}}function _O(){return new Dm}function cc(t,n){const e=arguments.length>=2;return r=>r.pipe(t?uc((s,o)=>t(s,o,r)):ke,pd(1),e?Tm(n):Nw(()=>new Dm))}function Yc(t,n){return _r(t,n,1)}function lc(){}function Io(t,n,e){return function(s){return s.lift(new IO(t,n,e))}}class IO{constructor(n,e,r){this.nextOrObserver=n,this.error=e,this.complete=r}call(n,e){return e.subscribe(new DO(n,this.nextOrObserver,this.error,this.complete))}}class DO extends xe{constructor(n,e,r,s){super(n),this._tapNext=lc,this._tapError=lc,this._tapComplete=lc,this._tapError=r||lc,this._tapComplete=s||lc,we(e)?(this._context=this,this._tapNext=e):e&&(this._context=e,this._tapNext=e.next||lc,this._tapError=e.error||lc,this._tapComplete=e.complete||lc)}_next(n){try{this._tapNext.call(this._context,n)}catch(e){return void this.destination.error(e)}this.destination.next(n)}_error(n){try{this._tapError.call(this._context,n)}catch(e){return void this.destination.error(e)}this.destination.error(n)}_complete(){try{this._tapComplete.call(this._context)}catch(n){return void this.destination.error(n)}return this.destination.complete()}}function Zc(t){return function(e){const r=new TO(t),s=e.lift(r);return r.caught=s}}class TO{constructor(n){this.selector=n}call(n,e){return e.subscribe(new NO(n,this.selector,this.caught))}}class NO extends Jn{constructor(n,e,r){super(n),this.selector=e,this.caught=r}error(n){if(!this.isStopped){let e;try{e=this.selector(n,this.caught)}catch(o){return void super.error(o)}this._unsubscribeAndRecycle();const r=new wn(this);this.add(r);const s=$r(e,r);s!==r&&this.add(s)}}}function kw(t,n){let e=!1;return arguments.length>=2&&(e=!0),function(s){return s.lift(new kO(t,n,e))}}class kO{constructor(n,e,r=!1){this.accumulator=n,this.seed=e,this.hasSeed=r}call(n,e){return e.subscribe(new AO(n,this.accumulator,this.seed,this.hasSeed))}}class AO extends xe{constructor(n,e,r,s){super(n),this.accumulator=e,this._seed=r,this.hasSeed=s,this.index=0}get seed(){return this._seed}set seed(n){this.hasSeed=!0,this._seed=n}_next(n){if(this.hasSeed)return this._tryNext(n);this.seed=n,this.destination.next(n)}_tryNext(n){const e=this.index++;let r;try{r=this.accumulator(this.seed,n,e)}catch(s){this.destination.error(s)}this.seed=r,this.destination.next(r)}}function R2(t){return function(e){return 0===t?A2():e.lift(new RO(t))}}class RO{constructor(n){if(this.total=n,this.total<0)throw new Tw}call(n,e){return e.subscribe(new OO(n,this.total))}}class OO extends xe{constructor(n,e){super(n),this.total=e,this.ring=new Array,this.count=0}_next(n){const e=this.ring,r=this.total,s=this.count++;e.length<r?e.push(n):e[s%r]=n}_complete(){const n=this.destination;let e=this.count;if(e>0){const r=this.count>=this.total?this.total:this.count,s=this.ring;for(let o=0;o<r;o++){const i=e++%r;n.next(s[i])}}n.complete()}}function Aw(t,n){const e=arguments.length>=2;return r=>r.pipe(t?uc((s,o)=>t(s,o,r)):ke,R2(1),e?Tm(n):Nw(()=>new Dm))}class $O{constructor(n,e){this.predicate=n,this.inclusive=e}call(n,e){return e.subscribe(new FO(n,this.predicate,this.inclusive))}}class FO extends xe{constructor(n,e,r){super(n),this.predicate=e,this.inclusive=r,this.index=0}_next(n){const e=this.destination;let r;try{r=this.predicate(n,this.index++)}catch(s){return void e.error(s)}this.nextOrComplete(n,r)}nextOrComplete(n,e){const r=this.destination;Boolean(e)?r.next(n):(this.inclusive&&r.next(n),r.complete())}}class LO{constructor(n){this.value=n}call(n,e){return e.subscribe(new BO(n,this.value))}}class BO extends xe{constructor(n,e){super(n),this.value=e}_next(n){this.destination.next(this.value)}}function O2(t){return n=>n.lift(new VO(t))}class VO{constructor(n){this.callback=n}call(n,e){return e.subscribe(new UO(n,this.callback))}}class UO extends xe{constructor(n,e){super(n),this.add(new ee(e))}}const Yn="primary",sf=Symbol("RouteTitle");class WO{constructor(n){this.params=n||{}}has(n){return Object.prototype.hasOwnProperty.call(this.params,n)}get(n){if(this.has(n)){const e=this.params[n];return Array.isArray(e)?e[0]:e}return null}getAll(n){if(this.has(n)){const e=this.params[n];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function md(t){return new WO(t)}function zO(t,n,e){const r=e.path.split("/");if(r.length>t.length||"full"===e.pathMatch&&(n.hasChildren()||r.length<t.length))return null;const s={};for(let o=0;o<r.length;o++){const i=r[o],a=t[o];if(i.startsWith(":"))s[i.substring(1)]=a;else if(i!==a.path)return null}return{consumed:t.slice(0,r.length),posParams:s}}function iu(t,n){const e=t?Object.keys(t):void 0,r=n?Object.keys(n):void 0;if(!e||!r||e.length!=r.length)return!1;let s;for(let o=0;o<e.length;o++)if(s=e[o],!Rw(t[s],n[s]))return!1;return!0}function Rw(t,n){if(Array.isArray(t)&&Array.isArray(n)){if(t.length!==n.length)return!1;const e=[...t].sort(),r=[...n].sort();return e.every((s,o)=>r[o]===s)}return t===n}function Ow(t){return Array.prototype.concat.apply([],t)}function Mw(t){return t.length>0?t[t.length-1]:null}function po(t,n){for(const e in t)t.hasOwnProperty(e)&&n(t[e],e)}function dc(t){return G4(t)?t:Kp(t)?Nt(Promise.resolve(t)):Nn(t)}const Nm=!1,jO={exact:function Pw(t,n,e){if(!Qc(t.segments,n.segments)||!km(t.segments,n.segments,e)||t.numberOfChildren!==n.numberOfChildren)return!1;for(const r in n.children)if(!t.children[r]||!Pw(t.children[r],n.children[r],e))return!1;return!0},subset:Lw},$w={exact:function GO(t,n){return iu(t,n)},subset:function KO(t,n){return Object.keys(n).length<=Object.keys(t).length&&Object.keys(n).every(e=>Rw(t[e],n[e]))},ignored:()=>!0};function Fw(t,n,e){return jO[e.paths](t.root,n.root,e.matrixParams)&&$w[e.queryParams](t.queryParams,n.queryParams)&&!("exact"===e.fragment&&t.fragment!==n.fragment)}function Lw(t,n,e){return Bw(t,n,n.segments,e)}function Bw(t,n,e,r){if(t.segments.length>e.length){const s=t.segments.slice(0,e.length);return!(!Qc(s,e)||n.hasChildren()||!km(s,e,r))}if(t.segments.length===e.length){if(!Qc(t.segments,e)||!km(t.segments,e,r))return!1;for(const s in n.children)if(!t.children[s]||!Lw(t.children[s],n.children[s],r))return!1;return!0}{const s=e.slice(0,t.segments.length),o=e.slice(t.segments.length);return!!(Qc(t.segments,s)&&km(t.segments,s,r)&&t.children[Yn])&&Bw(t.children[Yn],n,o,r)}}function km(t,n,e){return n.every((r,s)=>$w[e](t[s].parameters,r.parameters))}class hc{constructor(n=new ur([],{}),e={},r=null){this.root=n,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=md(this.queryParams)),this._queryParamMap}toString(){return YO.serialize(this)}}class ur{constructor(n,e){this.segments=n,this.children=e,this.parent=null,po(e,(r,s)=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Am(this)}}class af{constructor(n,e){this.path=n,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=md(this.parameters)),this._parameterMap}toString(){return Ww(this)}}function Qc(t,n){return t.length===n.length&&t.every((e,r)=>e.path===n[r].path)}let uf=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:function(){return new M2},providedIn:"root"}),t})();class M2{parse(n){const e=new o8(n);return new hc(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(n){const e=`/${cf(n.root,!0)}`,r=function JO(t){const n=Object.keys(t).map(e=>{const r=t[e];return Array.isArray(r)?r.map(s=>`${Rm(e)}=${Rm(s)}`).join("&"):`${Rm(e)}=${Rm(r)}`}).filter(e=>!!e);return n.length?`?${n.join("&")}`:""}(n.queryParams),s="string"==typeof n.fragment?`#${function ZO(t){return encodeURI(t)}(n.fragment)}`:"";return`${e}${r}${s}`}}const YO=new M2;function Am(t){return t.segments.map(n=>Ww(n)).join("/")}function cf(t,n){if(!t.hasChildren())return Am(t);if(n){const e=t.children[Yn]?cf(t.children[Yn],!1):"",r=[];return po(t.children,(s,o)=>{o!==Yn&&r.push(`${o}:${cf(s,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}{const e=function qO(t,n){let e=[];return po(t.children,(r,s)=>{s===Yn&&(e=e.concat(n(r,s)))}),po(t.children,(r,s)=>{s!==Yn&&(e=e.concat(n(r,s)))}),e}(t,(r,s)=>s===Yn?[cf(t.children[Yn],!1)]:[`${s}:${cf(r,!1)}`]);return 1===Object.keys(t.children).length&&null!=t.children[Yn]?`${Am(t)}/${e[0]}`:`${Am(t)}/(${e.join("//")})`}}function Vw(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Rm(t){return Vw(t).replace(/%3B/gi,";")}function $2(t){return Vw(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Om(t){return decodeURIComponent(t)}function Uw(t){return Om(t.replace(/\+/g,"%20"))}function Ww(t){return`${$2(t.path)}${function QO(t){return Object.keys(t).map(n=>`;${$2(n)}=${$2(t[n])}`).join("")}(t.parameters)}`}const e8=/^[^\/()?;=#]+/;function Mm(t){const n=t.match(e8);return n?n[0]:""}const t8=/^[^=?&#]+/,r8=/^[^&#]+/;class o8{constructor(n){this.url=n,this.remaining=n}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new ur([],{}):new ur([],this.parseChildren())}parseQueryParams(){const n={};if(this.consumeOptional("?"))do{this.parseQueryParam(n)}while(this.consumeOptional("&"));return n}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const n=[];for(this.peekStartsWith("(")||n.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),n.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(n.length>0||Object.keys(e).length>0)&&(r[Yn]=new ur(n,e)),r}parseSegment(){const n=Mm(this.remaining);if(""===n&&this.peekStartsWith(";"))throw new Pt(4009,Nm);return this.capture(n),new af(Om(n),this.parseMatrixParams())}parseMatrixParams(){const n={};for(;this.consumeOptional(";");)this.parseParam(n);return n}parseParam(n){const e=Mm(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const s=Mm(this.remaining);s&&(r=s,this.capture(r))}n[Om(e)]=Om(r)}parseQueryParam(n){const e=function n8(t){const n=t.match(t8);return n?n[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const i=function s8(t){const n=t.match(r8);return n?n[0]:""}(this.remaining);i&&(r=i,this.capture(r))}const s=Uw(e),o=Uw(r);if(n.hasOwnProperty(s)){let i=n[s];Array.isArray(i)||(i=[i],n[s]=i),i.push(o)}else n[s]=o}parseParens(n){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=Mm(this.remaining),s=this.remaining[r.length];if("/"!==s&&")"!==s&&";"!==s)throw new Pt(4010,Nm);let o;r.indexOf(":")>-1?(o=r.slice(0,r.indexOf(":")),this.capture(o),this.capture(":")):n&&(o=Yn);const i=this.parseChildren();e[o]=1===Object.keys(i).length?i[Yn]:new ur([],i),this.consumeOptional("//")}return e}peekStartsWith(n){return this.remaining.startsWith(n)}consumeOptional(n){return!!this.peekStartsWith(n)&&(this.remaining=this.remaining.substring(n.length),!0)}capture(n){if(!this.consumeOptional(n))throw new Pt(4011,Nm)}}function F2(t){return t.segments.length>0?new ur([],{[Yn]:t}):t}function $m(t){const n={};for(const r of Object.keys(t.children)){const o=$m(t.children[r]);(o.segments.length>0||o.hasChildren())&&(n[r]=o)}return function i8(t){if(1===t.numberOfChildren&&t.children[Yn]){const n=t.children[Yn];return new ur(t.segments.concat(n.segments),n.children)}return t}(new ur(t.segments,n))}function Jc(t){return t instanceof hc}const P2=!1;function a8(t,n,e,r,s){if(0===e.length)return gd(n.root,n.root,n.root,r,s);const o=function Kw(t){if("string"==typeof t[0]&&1===t.length&&"/"===t[0])return new Gw(!0,0,t);let n=0,e=!1;const r=t.reduce((s,o,i)=>{if("object"==typeof o&&null!=o){if(o.outlets){const a={};return po(o.outlets,(u,c)=>{a[c]="string"==typeof u?u.split("/"):u}),[...s,{outlets:a}]}if(o.segmentPath)return[...s,o.segmentPath]}return"string"!=typeof o?[...s,o]:0===i?(o.split("/").forEach((a,u)=>{0==u&&"."===a||(0==u&&""===a?e=!0:".."===a?n++:""!=a&&s.push(a))}),s):[...s,o]},[]);return new Gw(e,n,r)}(e);return o.toRoot()?gd(n.root,n.root,new ur([],{}),r,s):function i(u){const c=function c8(t,n,e,r){if(t.isAbsolute)return new yd(n.root,!0,0);if(-1===r)return new yd(e,e===n.root,0);return function Xw(t,n,e){let r=t,s=n,o=e;for(;o>s;){if(o-=s,r=r.parent,!r)throw new Pt(4005,P2&&"Invalid number of '../'");s=r.segments.length}return new yd(r,!1,s-o)}(e,r+(lf(t.commands[0])?0:1),t.numberOfDoubleDots)}(o,n,t.snapshot?._urlSegment,u),l=c.processChildren?vd(c.segmentGroup,c.index,o.commands):L2(c.segmentGroup,c.index,o.commands);return gd(n.root,c.segmentGroup,l,r,s)}(t.snapshot?._lastPathIndex)}function lf(t){return"object"==typeof t&&null!=t&&!t.outlets&&!t.segmentPath}function df(t){return"object"==typeof t&&null!=t&&t.outlets}function gd(t,n,e,r,s){let i,o={};r&&po(r,(u,c)=>{o[c]=Array.isArray(u)?u.map(l=>`${l}`):`${u}`}),i=t===n?e:jw(t,n,e);const a=F2($m(i));return new hc(a,o,s)}function jw(t,n,e){const r={};return po(t.children,(s,o)=>{r[o]=s===n?e:jw(s,n,e)}),new ur(t.segments,r)}class Gw{constructor(n,e,r){if(this.isAbsolute=n,this.numberOfDoubleDots=e,this.commands=r,n&&r.length>0&&lf(r[0]))throw new Pt(4003,P2&&"Root segment cannot have matrix parameters");const s=r.find(df);if(s&&s!==Mw(r))throw new Pt(4004,P2&&"{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class yd{constructor(n,e,r){this.segmentGroup=n,this.processChildren=e,this.index=r}}function L2(t,n,e){if(t||(t=new ur([],{})),0===t.segments.length&&t.hasChildren())return vd(t,n,e);const r=function d8(t,n,e){let r=0,s=n;const o={match:!1,pathIndex:0,commandIndex:0};for(;s<t.segments.length;){if(r>=e.length)return o;const i=t.segments[s],a=e[r];if(df(a))break;const u=`${a}`,c=r<e.length-1?e[r+1]:null;if(s>0&&void 0===u)break;if(u&&c&&"object"==typeof c&&void 0===c.outlets){if(!Yw(u,c,i))return o;r+=2}else{if(!Yw(u,{},i))return o;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(t,n,e),s=e.slice(r.commandIndex);if(r.match&&r.pathIndex<t.segments.length){const o=new ur(t.segments.slice(0,r.pathIndex),{});return o.children[Yn]=new ur(t.segments.slice(r.pathIndex),t.children),vd(o,0,s)}return r.match&&0===s.length?new ur(t.segments,{}):r.match&&!t.hasChildren()?B2(t,n,e):r.match?vd(t,0,s):B2(t,n,e)}function vd(t,n,e){if(0===e.length)return new ur(t.segments,{});{const r=function l8(t){return df(t[0])?t[0].outlets:{[Yn]:t}}(e),s={};if(!r[Yn]&&t.children[Yn]&&1===t.numberOfChildren&&0===t.children[Yn].segments.length){const o=vd(t.children[Yn],n,e);return new ur(t.segments,o.children)}return po(r,(o,i)=>{"string"==typeof o&&(o=[o]),null!==o&&(s[i]=L2(t.children[i],n,o))}),po(t.children,(o,i)=>{void 0===r[i]&&(s[i]=o)}),new ur(t.segments,s)}}function B2(t,n,e){const r=t.segments.slice(0,n);let s=0;for(;s<e.length;){const o=e[s];if(df(o)){const u=h8(o.outlets);return new ur(r,u)}if(0===s&&lf(e[0])){r.push(new af(t.segments[n].path,qw(e[0]))),s++;continue}const i=df(o)?o.outlets[Yn]:`${o}`,a=s<e.length-1?e[s+1]:null;i&&a&&lf(a)?(r.push(new af(i,qw(a))),s+=2):(r.push(new af(i,{})),s++)}return new ur(r,{})}function h8(t){const n={};return po(t,(e,r)=>{"string"==typeof e&&(e=[e]),null!==e&&(n[r]=B2(new ur([],{}),0,e))}),n}function qw(t){const n={};return po(t,(e,r)=>n[r]=`${e}`),n}function Yw(t,n,e){return t==e.path&&iu(n,e.parameters)}const hf="imperative";class au{constructor(n,e){this.id=n,this.url=e}}class V2 extends au{constructor(n,e,r="imperative",s=null){super(n,e),this.type=0,this.navigationTrigger=r,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class el extends au{constructor(n,e,r){super(n,e),this.urlAfterRedirects=r,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Fm extends au{constructor(n,e,r,s){super(n,e),this.reason=r,this.code=s,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class Pm extends au{constructor(n,e,r,s){super(n,e),this.reason=r,this.code=s,this.type=16}}class U2 extends au{constructor(n,e,r,s){super(n,e),this.error=r,this.target=s,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class f8 extends au{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class p8 extends au{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class m8 extends au{constructor(n,e,r,s,o){super(n,e),this.urlAfterRedirects=r,this.state=s,this.shouldActivate=o,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class g8 extends au{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class y8 extends au{constructor(n,e,r,s){super(n,e),this.urlAfterRedirects=r,this.state=s,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class v8{constructor(n){this.route=n,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class x8{constructor(n){this.route=n,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class b8{constructor(n){this.snapshot=n,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class w8{constructor(n){this.snapshot=n,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class C8{constructor(n){this.snapshot=n,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class S8{constructor(n){this.snapshot=n,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Zw{constructor(n,e,r){this.routerEvent=n,this.position=e,this.anchor=r,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}let I8=(()=>{class t{createUrlTree(e,r,s,o,i,a){return a8(e||r.root,s,o,i,a)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:t.\u0275fac}),t})(),T8=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:function(n){return I8.\u0275fac(n)},providedIn:"root"}),t})();class Qw{constructor(n){this._root=n}get root(){return this._root.value}parent(n){const e=this.pathFromRoot(n);return e.length>1?e[e.length-2]:null}children(n){const e=W2(n,this._root);return e?e.children.map(r=>r.value):[]}firstChild(n){const e=W2(n,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(n){const e=z2(n,this._root);return e.length<2?[]:e[e.length-2].children.map(s=>s.value).filter(s=>s!==n)}pathFromRoot(n){return z2(n,this._root).map(e=>e.value)}}function W2(t,n){if(t===n.value)return n;for(const e of n.children){const r=W2(t,e);if(r)return r}return null}function z2(t,n){if(t===n.value)return[n];for(const e of n.children){const r=z2(t,e);if(r.length)return r.unshift(n),r}return[]}class Pu{constructor(n,e){this.value=n,this.children=e}toString(){return`TreeNode(${this.value})`}}function xd(t){const n={};return t&&t.children.forEach(e=>n[e.value.outlet]=e),n}class Jw extends Qw{constructor(n,e){super(n),this.snapshot=e,H2(this,n)}toString(){return this.snapshot.toString()}}function eC(t,n){const e=function N8(t,n){const i=new Lm([],{},{},"",{},Yn,n,null,t.root,-1,{});return new nC("",new Pu(i,[]))}(t,n),r=new Na([new af("",{})]),s=new Na({}),o=new Na({}),i=new Na({}),a=new Na(""),u=new bd(r,s,i,a,o,Yn,n,e.root);return u.snapshot=e.root,new Jw(new Pu(u,[]),e)}class bd{constructor(n,e,r,s,o,i,a,u){this.url=n,this.params=e,this.queryParams=r,this.fragment=s,this.data=o,this.outlet=i,this.component=a,this.title=this.data?.pipe(Me(c=>c[sf]))??Nn(void 0),this._futureSnapshot=u}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(Me(n=>md(n)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(Me(n=>md(n)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function tC(t,n="emptyOnly"){const e=t.pathFromRoot;let r=0;if("always"!==n)for(r=e.length-1;r>=1;){const s=e[r],o=e[r-1];if(s.routeConfig&&""===s.routeConfig.path)r--;else{if(o.component)break;r--}}return function k8(t){return t.reduce((n,e)=>({params:{...n.params,...e.params},data:{...n.data,...e.data},resolve:{...e.data,...n.resolve,...e.routeConfig?.data,...e._resolvedData}}),{params:{},data:{},resolve:{}})}(e.slice(r))}class Lm{get title(){return this.data?.[sf]}constructor(n,e,r,s,o,i,a,u,c,l,h){this.url=n,this.params=e,this.queryParams=r,this.fragment=s,this.data=o,this.outlet=i,this.component=a,this.routeConfig=u,this._urlSegment=c,this._lastPathIndex=l,this._resolve=h}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=md(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=md(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class nC extends Qw{constructor(n,e){super(e),this.url=n,H2(this,e)}toString(){return rC(this._root)}}function H2(t,n){n.value._routerState=t,n.children.forEach(e=>H2(t,e))}function rC(t){const n=t.children.length>0?` { ${t.children.map(rC).join(", ")} } `:"";return`${t.value}${n}`}function j2(t){if(t.snapshot){const n=t.snapshot,e=t._futureSnapshot;t.snapshot=e,iu(n.queryParams,e.queryParams)||t.queryParams.next(e.queryParams),n.fragment!==e.fragment&&t.fragment.next(e.fragment),iu(n.params,e.params)||t.params.next(e.params),function HO(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;++e)if(!iu(t[e],n[e]))return!1;return!0}(n.url,e.url)||t.url.next(e.url),iu(n.data,e.data)||t.data.next(e.data)}else t.snapshot=t._futureSnapshot,t.data.next(t._futureSnapshot.data)}function G2(t,n){const e=iu(t.params,n.params)&&function XO(t,n){return Qc(t,n)&&t.every((e,r)=>iu(e.parameters,n[r].parameters))}(t.url,n.url);return e&&!(!t.parent!=!n.parent)&&(!t.parent||G2(t.parent,n.parent))}function ff(t,n,e){if(e&&t.shouldReuseRoute(n.value,e.value.snapshot)){const r=e.value;r._futureSnapshot=n.value;const s=function R8(t,n,e){return n.children.map(r=>{for(const s of e.children)if(t.shouldReuseRoute(r.value,s.value.snapshot))return ff(t,r,s);return ff(t,r)})}(t,n,e);return new Pu(r,s)}{if(t.shouldAttach(n.value)){const o=t.retrieve(n.value);if(null!==o){const i=o.route;return i.value._futureSnapshot=n.value,i.children=n.children.map(a=>ff(t,a)),i}}const r=function O8(t){return new bd(new Na(t.url),new Na(t.params),new Na(t.queryParams),new Na(t.fragment),new Na(t.data),t.outlet,t.component,t)}(n.value),s=n.children.map(o=>ff(t,o));return new Pu(r,s)}}const K2="ngNavigationCancelingError";function sC(t,n){const{redirectTo:e,navigationBehaviorOptions:r}=Jc(n)?{redirectTo:n,navigationBehaviorOptions:void 0}:n,s=oC(!1,0,n);return s.url=e,s.navigationBehaviorOptions=r,s}function oC(t,n,e){const r=new Error("NavigationCancelingError: "+(t||""));return r[K2]=!0,r.cancellationCode=n,e&&(r.url=e),r}function iC(t){return aC(t)&&Jc(t.url)}function aC(t){return t&&t[K2]}class M8{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.injector=null,this.children=new pf,this.attachRef=null}}let pf=(()=>{class t{constructor(){this.contexts=new Map}onChildOutletCreated(e,r){const s=this.getOrCreateContext(e);s.outlet=r,this.contexts.set(e,s)}onChildOutletDestroyed(e){const r=this.getContext(e);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let r=this.getContext(e);return r||(r=new M8,this.contexts.set(e,r)),r}getContext(e){return this.contexts.get(e)||null}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const Bm=!1;let X2=(()=>{class t{constructor(){this.activated=null,this._activatedRoute=null,this.name=Yn,this.activateEvents=new Ho,this.deactivateEvents=new Ho,this.attachEvents=new Ho,this.detachEvents=new Ho,this.parentContexts=v(pf),this.location=v(_a),this.changeDetector=v(Y0),this.environmentInjector=v(Tu)}ngOnChanges(e){if(e.name){const{firstChange:r,previousValue:s}=e.name;if(r)return;this.isTrackedInParentContexts(s)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(s)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Pt(4012,Bm);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Pt(4012,Bm);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Pt(4012,Bm);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new Pt(4013,Bm);this._activatedRoute=e;const s=this.location,i=e.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,u=new $8(e,a,s.injector);if(r&&function F8(t){return!!t.resolveComponentFactory}(r)){const c=r.resolveComponentFactory(i);this.activated=s.createComponent(c,s.length,u)}else this.activated=s.createComponent(i,{index:s.length,injector:u,environmentInjector:r??this.environmentInjector});this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275dir=Es({type:t,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[xa]}),t})();class $8{constructor(n,e,r){this.route=n,this.childContexts=e,this.parent=r}get(n,e){return n===bd?this.route:n===pf?this.childContexts:this.parent.get(n,e)}}let q2=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=ns({type:t,selectors:[["ng-component"]],standalone:!0,features:[gx],decls:1,vars:0,template:function(e,r){1&e&&li(0,"router-outlet")},dependencies:[X2],encapsulation:2}),t})();function uC(t,n){return t.providers&&!t._injector&&(t._injector=tm(t.providers,n,`Route: ${t.path}`)),t._injector??n}function Z2(t){const n=t.children&&t.children.map(Z2),e=n?{...t,children:n}:{...t};return!e.component&&!e.loadComponent&&(n||e.loadChildren)&&e.outlet&&e.outlet!==Yn&&(e.component=q2),e}function ia(t){return t.outlet||Yn}function cC(t,n){const e=t.filter(r=>ia(r)===n);return e.push(...t.filter(r=>ia(r)!==n)),e}function mf(t){if(!t)return null;if(t.routeConfig?._injector)return t.routeConfig._injector;for(let n=t.parent;n;n=n.parent){const e=n.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}class U8{constructor(n,e,r,s){this.routeReuseStrategy=n,this.futureState=e,this.currState=r,this.forwardEvent=s}activate(n){const e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,n),j2(this.futureState.root),this.activateChildRoutes(e,r,n)}deactivateChildRoutes(n,e,r){const s=xd(e);n.children.forEach(o=>{const i=o.value.outlet;this.deactivateRoutes(o,s[i],r),delete s[i]}),po(s,(o,i)=>{this.deactivateRouteAndItsChildren(o,r)})}deactivateRoutes(n,e,r){const s=n.value,o=e?e.value:null;if(s===o)if(s.component){const i=r.getContext(s.outlet);i&&this.deactivateChildRoutes(n,e,i.children)}else this.deactivateChildRoutes(n,e,r);else o&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(n,e){n.value.component&&this.routeReuseStrategy.shouldDetach(n.value.snapshot)?this.detachAndStoreRouteSubtree(n,e):this.deactivateRouteAndOutlet(n,e)}detachAndStoreRouteSubtree(n,e){const r=e.getContext(n.value.outlet),s=r&&n.value.component?r.children:e,o=xd(n);for(const i of Object.keys(o))this.deactivateRouteAndItsChildren(o[i],s);if(r&&r.outlet){const i=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(n.value.snapshot,{componentRef:i,route:n,contexts:a})}}deactivateRouteAndOutlet(n,e){const r=e.getContext(n.value.outlet),s=r&&n.value.component?r.children:e,o=xd(n);for(const i of Object.keys(o))this.deactivateRouteAndItsChildren(o[i],s);r&&(r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated()),r.attachRef=null,r.resolver=null,r.route=null)}activateChildRoutes(n,e,r){const s=xd(e);n.children.forEach(o=>{this.activateRoutes(o,s[o.value.outlet],r),this.forwardEvent(new S8(o.value.snapshot))}),n.children.length&&this.forwardEvent(new w8(n.value.snapshot))}activateRoutes(n,e,r){const s=n.value,o=e?e.value:null;if(j2(s),s===o)if(s.component){const i=r.getOrCreateContext(s.outlet);this.activateChildRoutes(n,e,i.children)}else this.activateChildRoutes(n,e,r);else if(s.component){const i=r.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const a=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),i.children.onOutletReAttached(a.contexts),i.attachRef=a.componentRef,i.route=a.route.value,i.outlet&&i.outlet.attach(a.componentRef,a.route.value),j2(a.route.value),this.activateChildRoutes(n,null,i.children)}else{const a=mf(s.snapshot),u=a?.get(Mh)??null;i.attachRef=null,i.route=s,i.resolver=u,i.injector=a,i.outlet&&i.outlet.activateWith(s,i.injector),this.activateChildRoutes(n,null,i.children)}}else this.activateChildRoutes(n,null,r)}}class lC{constructor(n){this.path=n,this.route=this.path[this.path.length-1]}}class Vm{constructor(n,e){this.component=n,this.route=e}}function W8(t,n,e){const r=t._root;return gf(r,n?n._root:null,e,[r.value])}function wd(t,n){const e=Symbol(),r=n.get(t,e);return r===e?"function"!=typeof t||function Br(t){return null!==Dr(t)}(t)?n.get(t):t:r}function gf(t,n,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=xd(n);return t.children.forEach(i=>{(function H8(t,n,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=t.value,i=n?n.value:null,a=e?e.getContext(t.value.outlet):null;if(i&&o.routeConfig===i.routeConfig){const u=function j8(t,n,e){if("function"==typeof e)return e(t,n);switch(e){case"pathParamsChange":return!Qc(t.url,n.url);case"pathParamsOrQueryParamsChange":return!Qc(t.url,n.url)||!iu(t.queryParams,n.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!G2(t,n)||!iu(t.queryParams,n.queryParams);default:return!G2(t,n)}}(i,o,o.routeConfig.runGuardsAndResolvers);u?s.canActivateChecks.push(new lC(r)):(o.data=i.data,o._resolvedData=i._resolvedData),gf(t,n,o.component?a?a.children:null:e,r,s),u&&a&&a.outlet&&a.outlet.isActivated&&s.canDeactivateChecks.push(new Vm(a.outlet.component,i))}else i&&yf(n,a,s),s.canActivateChecks.push(new lC(r)),gf(t,null,o.component?a?a.children:null:e,r,s)})(i,o[i.value.outlet],e,r.concat([i.value]),s),delete o[i.value.outlet]}),po(o,(i,a)=>yf(i,e.getContext(a),s)),s}function yf(t,n,e){const r=xd(t),s=t.value;po(r,(o,i)=>{yf(o,s.component?n?n.children.getContext(i):null:n,e)}),e.canDeactivateChecks.push(new Vm(s.component&&n&&n.outlet&&n.outlet.isActivated?n.outlet.component:null,s))}function vf(t){return"function"==typeof t}function Q2(t){return t instanceof Dm||"EmptyError"===t?.name}const Um=Symbol("INITIAL_VALUE");function Cd(){return ka(t=>Iw(t.map(n=>n.pipe(pd(1),function vO(...t){const n=t[t.length-1];return He(n)?(t.pop(),e=>k2(t,e,n)):e=>k2(t,e)}(Um)))).pipe(Me(n=>{for(const e of n)if(!0!==e){if(e===Um)return Um;if(!1===e||e instanceof hc)return e}return!0}),uc(n=>n!==Um),pd(1)))}function dC(t){return function Oe(...t){return It(t)}(Io(n=>{if(Jc(n))throw sC(0,n)}),Me(n=>!0===n))}const J2={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function hC(t,n,e,r,s){const o=e3(t,n,e);return o.matched?function u7(t,n,e,r){const s=n.canMatch;return s&&0!==s.length?Nn(s.map(i=>{const a=wd(i,t);return dc(function Z8(t){return t&&vf(t.canMatch)}(a)?a.canMatch(n,e):t.runInContext(()=>a(n,e)))})).pipe(Cd(),dC()):Nn(!0)}(r=uC(n,r),n,e).pipe(Me(i=>!0===i?o:{...J2})):Nn(o)}function e3(t,n,e){if(""===n.path)return"full"===n.pathMatch&&(t.hasChildren()||e.length>0)?{...J2}:{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const s=(n.matcher||zO)(e,t,n);if(!s)return{...J2};const o={};po(s.posParams,(a,u)=>{o[u]=a.path});const i=s.consumed.length>0?{...o,...s.consumed[s.consumed.length-1].parameters}:o;return{matched:!0,consumedSegments:s.consumed,remainingSegments:e.slice(s.consumed.length),parameters:i,positionalParamSegments:s.posParams??{}}}function Wm(t,n,e,r){if(e.length>0&&function d7(t,n,e){return e.some(r=>zm(t,n,r)&&ia(r)!==Yn)}(t,e,r)){const o=new ur(n,function l7(t,n,e,r){const s={};s[Yn]=r,r._sourceSegment=t,r._segmentIndexShift=n.length;for(const o of e)if(""===o.path&&ia(o)!==Yn){const i=new ur([],{});i._sourceSegment=t,i._segmentIndexShift=n.length,s[ia(o)]=i}return s}(t,n,r,new ur(e,t.children)));return o._sourceSegment=t,o._segmentIndexShift=n.length,{segmentGroup:o,slicedSegments:[]}}if(0===e.length&&function h7(t,n,e){return e.some(r=>zm(t,n,r))}(t,e,r)){const o=new ur(t.segments,function c7(t,n,e,r,s){const o={};for(const i of r)if(zm(t,e,i)&&!s[ia(i)]){const a=new ur([],{});a._sourceSegment=t,a._segmentIndexShift=n.length,o[ia(i)]=a}return{...s,...o}}(t,n,e,r,t.children));return o._sourceSegment=t,o._segmentIndexShift=n.length,{segmentGroup:o,slicedSegments:e}}const s=new ur(t.segments,t.children);return s._sourceSegment=t,s._segmentIndexShift=n.length,{segmentGroup:s,slicedSegments:e}}function zm(t,n,e){return(!(t.hasChildren()||n.length>0)||"full"!==e.pathMatch)&&""===e.path}function fC(t,n,e,r){return!!(ia(t)===r||r!==Yn&&zm(n,e,t))&&("**"===t.path||e3(n,t,e).matched)}function pC(t,n,e){return 0===n.length&&!t.children[e]}const Hm=!1;class jm{constructor(n){this.segmentGroup=n||null}}class mC{constructor(n){this.urlTree=n}}function xf(t){return rf(new jm(t))}function gC(t){return rf(new mC(t))}function f7(t){return rf(new Pt(4e3,Hm&&`Only absolute redirects can have named outlets. redirectTo: '${t}'`))}class g7{constructor(n,e,r,s,o){this.injector=n,this.configLoader=e,this.urlSerializer=r,this.urlTree=s,this.config=o,this.allowRedirects=!0}apply(){const n=Wm(this.urlTree.root,[],[],this.config).segmentGroup,e=new ur(n.segments,n.children);return this.expandSegmentGroup(this.injector,this.config,e,Yn).pipe(Me(o=>this.createUrlTree($m(o),this.urlTree.queryParams,this.urlTree.fragment))).pipe(Zc(o=>{if(o instanceof mC)return this.allowRedirects=!1,this.match(o.urlTree);throw o instanceof jm?this.noMatchError(o):o}))}match(n){return this.expandSegmentGroup(this.injector,this.config,n.root,Yn).pipe(Me(s=>this.createUrlTree($m(s),n.queryParams,n.fragment))).pipe(Zc(s=>{throw s instanceof jm?this.noMatchError(s):s}))}noMatchError(n){return new Pt(4002,Hm&&`Cannot match any routes. URL Segment: '${n.segmentGroup}'`)}createUrlTree(n,e,r){const s=F2(n);return new hc(s,e,r)}expandSegmentGroup(n,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.expandChildren(n,e,r).pipe(Me(o=>new ur([],o))):this.expandSegment(n,r,e,r.segments,s,!0)}expandChildren(n,e,r){const s=[];for(const o of Object.keys(r.children))"primary"===o?s.unshift(o):s.push(o);return Nt(s).pipe(Yc(o=>{const i=r.children[o],a=cC(e,o);return this.expandSegmentGroup(n,a,i,o).pipe(Me(u=>({segment:u,outlet:o})))}),kw((o,i)=>(o[i.outlet]=i.segment,o),{}),Aw())}expandSegment(n,e,r,s,o,i){return Nt(r).pipe(Yc(a=>this.expandSegmentAgainstRoute(n,e,r,a,s,o,i).pipe(Zc(c=>{if(c instanceof jm)return Nn(null);throw c}))),cc(a=>!!a),Zc((a,u)=>{if(Q2(a))return pC(e,s,o)?Nn(new ur([],{})):xf(e);throw a}))}expandSegmentAgainstRoute(n,e,r,s,o,i,a){return fC(s,e,o,i)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(n,e,s,o,i):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i):xf(e):xf(e)}expandSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(n,r,s,i):this.expandRegularSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i)}expandWildCardWithParamsAgainstRouteUsingRedirect(n,e,r,s){const o=this.applyRedirectCommands([],r.redirectTo,{});return r.redirectTo.startsWith("/")?gC(o):this.lineralizeSegments(r,o).pipe(_r(i=>{const a=new ur(i,{});return this.expandSegment(n,a,e,i,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(n,e,r,s,o,i){const{matched:a,consumedSegments:u,remainingSegments:c,positionalParamSegments:l}=e3(e,s,o);if(!a)return xf(e);const h=this.applyRedirectCommands(u,s.redirectTo,l);return s.redirectTo.startsWith("/")?gC(h):this.lineralizeSegments(s,h).pipe(_r(f=>this.expandSegment(n,e,r,f.concat(c),i,!1)))}matchSegmentAgainstRoute(n,e,r,s,o){return"**"===r.path?(n=uC(r,n),r.loadChildren?(r._loadedRoutes?Nn({routes:r._loadedRoutes,injector:r._loadedInjector}):this.configLoader.loadChildren(n,r)).pipe(Me(a=>(r._loadedRoutes=a.routes,r._loadedInjector=a.injector,new ur(s,{})))):Nn(new ur(s,{}))):hC(e,r,s,n).pipe(ka(({matched:i,consumedSegments:a,remainingSegments:u})=>i?this.getChildConfig(n=r._injector??n,r,s).pipe(_r(l=>{const h=l.injector??n,f=l.routes,{segmentGroup:m,slicedSegments:y}=Wm(e,a,u,f),w=new ur(m.segments,m.children);if(0===y.length&&w.hasChildren())return this.expandChildren(h,f,w).pipe(Me(W=>new ur(a,W)));if(0===f.length&&0===y.length)return Nn(new ur(a,{}));const E=ia(r)===o;return this.expandSegment(h,w,f,y,E?Yn:o,!0).pipe(Me(O=>new ur(a.concat(O.segments),O.children)))})):xf(e)))}getChildConfig(n,e,r){return e.children?Nn({routes:e.children,injector:n}):e.loadChildren?void 0!==e._loadedRoutes?Nn({routes:e._loadedRoutes,injector:e._loadedInjector}):function a7(t,n,e,r){const s=n.canLoad;return void 0===s||0===s.length?Nn(!0):Nn(s.map(i=>{const a=wd(i,t);return dc(function K8(t){return t&&vf(t.canLoad)}(a)?a.canLoad(n,e):t.runInContext(()=>a(n,e)))})).pipe(Cd(),dC())}(n,e,r).pipe(_r(s=>s?this.configLoader.loadChildren(n,e).pipe(Io(o=>{e._loadedRoutes=o.routes,e._loadedInjector=o.injector})):function p7(t){return rf(oC(Hm&&`Cannot load children because the guard of the route "path: '${t.path}'" returned false`,3))}(e))):Nn({routes:[],injector:n})}lineralizeSegments(n,e){let r=[],s=e.root;for(;;){if(r=r.concat(s.segments),0===s.numberOfChildren)return Nn(r);if(s.numberOfChildren>1||!s.children[Yn])return f7(n.redirectTo);s=s.children[Yn]}}applyRedirectCommands(n,e,r){return this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),n,r)}applyRedirectCreateUrlTree(n,e,r,s){const o=this.createSegmentGroup(n,e.root,r,s);return new hc(o,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(n,e){const r={};return po(n,(s,o)=>{if("string"==typeof s&&s.startsWith(":")){const a=s.substring(1);r[o]=e[a]}else r[o]=s}),r}createSegmentGroup(n,e,r,s){const o=this.createSegments(n,e.segments,r,s);let i={};return po(e.children,(a,u)=>{i[u]=this.createSegmentGroup(n,a,r,s)}),new ur(o,i)}createSegments(n,e,r,s){return e.map(o=>o.path.startsWith(":")?this.findPosParam(n,o,s):this.findOrReturn(o,r))}findPosParam(n,e,r){const s=r[e.path.substring(1)];if(!s)throw new Pt(4001,Hm&&`Cannot redirect to '${n}'. Cannot find '${e.path}'.`);return s}findOrReturn(n,e){let r=0;for(const s of e){if(s.path===n.path)return e.splice(r),s;r++}return n}}class v7{}class w7{constructor(n,e,r,s,o,i,a){this.injector=n,this.rootComponentType=e,this.config=r,this.urlTree=s,this.url=o,this.paramsInheritanceStrategy=i,this.urlSerializer=a}recognize(){const n=Wm(this.urlTree.root,[],[],this.config.filter(e=>void 0===e.redirectTo)).segmentGroup;return this.processSegmentGroup(this.injector,this.config,n,Yn).pipe(Me(e=>{if(null===e)return null;const r=new Lm([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},Yn,this.rootComponentType,null,this.urlTree.root,-1,{}),s=new Pu(r,e),o=new nC(this.url,s);return this.inheritParamsAndData(o._root),o}))}inheritParamsAndData(n){const e=n.value,r=tC(e,this.paramsInheritanceStrategy);e.params=Object.freeze(r.params),e.data=Object.freeze(r.data),n.children.forEach(s=>this.inheritParamsAndData(s))}processSegmentGroup(n,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.processChildren(n,e,r):this.processSegment(n,e,r,r.segments,s)}processChildren(n,e,r){return Nt(Object.keys(r.children)).pipe(Yc(s=>{const o=r.children[s],i=cC(e,s);return this.processSegmentGroup(n,i,o,s)}),kw((s,o)=>s&&o?(s.push(...o),s):null),function MO(t,n=!1){return e=>e.lift(new $O(t,n))}(s=>null!==s),Tm(null),Aw(),Me(s=>{if(null===s)return null;const o=vC(s);return function C7(t){t.sort((n,e)=>n.value.outlet===Yn?-1:e.value.outlet===Yn?1:n.value.outlet.localeCompare(e.value.outlet))}(o),o}))}processSegment(n,e,r,s,o){return Nt(e).pipe(Yc(i=>this.processSegmentAgainstRoute(i._injector??n,i,r,s,o)),cc(i=>!!i),Zc(i=>{if(Q2(i))return pC(r,s,o)?Nn([]):Nn(null);throw i}))}processSegmentAgainstRoute(n,e,r,s,o){if(e.redirectTo||!fC(e,r,s,o))return Nn(null);let i;if("**"===e.path){const a=s.length>0?Mw(s).parameters:{},u=bC(r)+s.length;i=Nn({snapshot:new Lm(s,a,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,wC(e),ia(e),e.component??e._loadedComponent??null,e,xC(r),u,CC(e)),consumedSegments:[],remainingSegments:[]})}else i=hC(r,e,s,n).pipe(Me(({matched:a,consumedSegments:u,remainingSegments:c,parameters:l})=>{if(!a)return null;const h=bC(r)+u.length;return{snapshot:new Lm(u,l,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,wC(e),ia(e),e.component??e._loadedComponent??null,e,xC(r),h,CC(e)),consumedSegments:u,remainingSegments:c}}));return i.pipe(ka(a=>{if(null===a)return Nn(null);const{snapshot:u,consumedSegments:c,remainingSegments:l}=a;n=e._injector??n;const h=e._loadedInjector??n,f=function S7(t){return t.children?t.children:t.loadChildren?t._loadedRoutes:[]}(e),{segmentGroup:m,slicedSegments:y}=Wm(r,c,l,f.filter(E=>void 0===E.redirectTo));if(0===y.length&&m.hasChildren())return this.processChildren(h,f,m).pipe(Me(E=>null===E?null:[new Pu(u,E)]));if(0===f.length&&0===y.length)return Nn([new Pu(u,[])]);const w=ia(e)===o;return this.processSegment(h,f,m,y,w?Yn:o).pipe(Me(E=>null===E?null:[new Pu(u,E)]))}))}}function E7(t){const n=t.value.routeConfig;return n&&""===n.path&&void 0===n.redirectTo}function vC(t){const n=[],e=new Set;for(const r of t){if(!E7(r)){n.push(r);continue}const s=n.find(o=>r.value.routeConfig===o.value.routeConfig);void 0!==s?(s.children.push(...r.children),e.add(s)):n.push(r)}for(const r of e){const s=vC(r.children);n.push(new Pu(r.value,s))}return n.filter(r=>!e.has(r))}function xC(t){let n=t;for(;n._sourceSegment;)n=n._sourceSegment;return n}function bC(t){let n=t,e=n._segmentIndexShift??0;for(;n._sourceSegment;)n=n._sourceSegment,e+=n._segmentIndexShift??0;return e-1}function wC(t){return t.data||{}}function CC(t){return t.resolve||{}}function SC(t){return"string"==typeof t.title||null===t.title}function t3(t){return ka(n=>{const e=t(n);return e?Nt(e).pipe(Me(()=>n)):Nn(n)})}const Sd=new An("ROUTES");let n3=(()=>{class t{constructor(){this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap,this.compiler=v(sb)}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return Nn(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);const r=dc(e.loadComponent()).pipe(Me(_C),Io(o=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=o}),O2(()=>{this.componentLoaders.delete(e)})),s=new Zs(r,()=>new ce).pipe(is());return this.componentLoaders.set(e,s),s}loadChildren(e,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return Nn({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const o=this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(Me(a=>{this.onLoadEndListener&&this.onLoadEndListener(r);let u,c,l=!1;Array.isArray(a)?c=a:(u=a.create(e).injector,c=Ow(u.get(Sd,[],mn.Self|mn.Optional)));return{routes:c.map(Z2),injector:u}}),O2(()=>{this.childrenLoaders.delete(r)})),i=new Zs(o,()=>new ce).pipe(is());return this.childrenLoaders.set(r,i),i}loadModuleFactoryOrRoutes(e){return dc(e()).pipe(Me(_C),_r(r=>r instanceof px||Array.isArray(r)?Nn(r):Nt(this.compiler.compileModuleAsync(r))))}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function _C(t){return function R7(t){return t&&"object"==typeof t&&"default"in t}(t)?t.default:t}let Km=(()=>{class t{get hasRequestedNavigation(){return 0!==this.navigationId}constructor(){this.currentNavigation=null,this.lastSuccessfulNavigation=null,this.events=new ce,this.configLoader=v(n3),this.environmentInjector=v(Tu),this.urlSerializer=v(uf),this.rootContexts=v(pf),this.navigationId=0,this.afterPreactivation=()=>Nn(void 0),this.rootComponentType=null,this.configLoader.onLoadEndListener=s=>this.events.next(new x8(s)),this.configLoader.onLoadStartListener=s=>this.events.next(new v8(s))}complete(){this.transitions?.complete()}handleNavigationRequest(e){const r=++this.navigationId;this.transitions?.next({...this.transitions.value,...e,id:r})}setupNavigations(e){return this.transitions=new Na({id:0,targetPageId:0,currentUrlTree:e.currentUrlTree,currentRawUrl:e.currentUrlTree,extractedUrl:e.urlHandlingStrategy.extract(e.currentUrlTree),urlAfterRedirects:e.urlHandlingStrategy.extract(e.currentUrlTree),rawUrl:e.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:hf,restoredState:null,currentSnapshot:e.routerState.snapshot,targetSnapshot:null,currentRouterState:e.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe(uc(r=>0!==r.id),Me(r=>({...r,extractedUrl:e.urlHandlingStrategy.extract(r.rawUrl)})),ka(r=>{let s=!1,o=!1;return Nn(r).pipe(Io(i=>{this.currentNavigation={id:i.id,initialUrl:i.rawUrl,extractedUrl:i.extractedUrl,trigger:i.source,extras:i.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null}}),ka(i=>{const a=e.browserUrlTree.toString(),u=!e.navigated||i.extractedUrl.toString()!==a||a!==e.currentUrlTree.toString();if(!u&&"reload"!==(i.extras.onSameUrlNavigation??e.onSameUrlNavigation)){const l="";return this.events.next(new Pm(i.id,e.serializeUrl(r.rawUrl),l,0)),e.rawUrlTree=i.rawUrl,i.resolve(null),qc}if(e.urlHandlingStrategy.shouldProcessUrl(i.rawUrl))return IC(i.source)&&(e.browserUrlTree=i.extractedUrl),Nn(i).pipe(ka(l=>{const h=this.transitions?.getValue();return this.events.next(new V2(l.id,this.urlSerializer.serialize(l.extractedUrl),l.source,l.restoredState)),h!==this.transitions?.getValue()?qc:Promise.resolve(l)}),function y7(t,n,e,r){return ka(s=>function m7(t,n,e,r,s){return new g7(t,n,e,r,s).apply()}(t,n,e,s.extractedUrl,r).pipe(Me(o=>({...s,urlAfterRedirects:o}))))}(this.environmentInjector,this.configLoader,this.urlSerializer,e.config),Io(l=>{this.currentNavigation={...this.currentNavigation,finalUrl:l.urlAfterRedirects},r.urlAfterRedirects=l.urlAfterRedirects}),function I7(t,n,e,r,s){return _r(o=>function b7(t,n,e,r,s,o,i="emptyOnly"){return new w7(t,n,e,r,s,i,o).recognize().pipe(ka(a=>null===a?function x7(t){return new $e(n=>n.error(t))}(new v7):Nn(a)))}(t,n,e,o.urlAfterRedirects,r.serialize(o.urlAfterRedirects),r,s).pipe(Me(i=>({...o,targetSnapshot:i}))))}(this.environmentInjector,this.rootComponentType,e.config,this.urlSerializer,e.paramsInheritanceStrategy),Io(l=>{if(r.targetSnapshot=l.targetSnapshot,"eager"===e.urlUpdateStrategy){if(!l.extras.skipLocationChange){const f=e.urlHandlingStrategy.merge(l.urlAfterRedirects,l.rawUrl);e.setBrowserUrl(f,l)}e.browserUrlTree=l.urlAfterRedirects}const h=new f8(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects),l.targetSnapshot);this.events.next(h)}));if(u&&e.urlHandlingStrategy.shouldProcessUrl(e.rawUrlTree)){const{id:l,extractedUrl:h,source:f,restoredState:m,extras:y}=i,w=new V2(l,this.urlSerializer.serialize(h),f,m);this.events.next(w);const E=eC(h,this.rootComponentType).snapshot;return Nn(r={...i,targetSnapshot:E,urlAfterRedirects:h,extras:{...y,skipLocationChange:!1,replaceUrl:!1}})}{const l="";return this.events.next(new Pm(i.id,e.serializeUrl(r.extractedUrl),l,1)),e.rawUrlTree=i.rawUrl,i.resolve(null),qc}}),Io(i=>{const a=new p8(i.id,this.urlSerializer.serialize(i.extractedUrl),this.urlSerializer.serialize(i.urlAfterRedirects),i.targetSnapshot);this.events.next(a)}),Me(i=>r={...i,guards:W8(i.targetSnapshot,i.currentSnapshot,this.rootContexts)}),function J8(t,n){return _r(e=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:o,canDeactivateChecks:i}}=e;return 0===i.length&&0===o.length?Nn({...e,guardsResult:!0}):function e7(t,n,e,r){return Nt(t).pipe(_r(s=>function i7(t,n,e,r,s){const o=n&&n.routeConfig?n.routeConfig.canDeactivate:null;return o&&0!==o.length?Nn(o.map(a=>{const u=mf(n)??s,c=wd(a,u);return dc(function Y8(t){return t&&vf(t.canDeactivate)}(c)?c.canDeactivate(t,n,e,r):u.runInContext(()=>c(t,n,e,r))).pipe(cc())})).pipe(Cd()):Nn(!0)}(s.component,s.route,e,n,r)),cc(s=>!0!==s,!0))}(i,r,s,t).pipe(_r(a=>a&&function G8(t){return"boolean"==typeof t}(a)?function t7(t,n,e,r){return Nt(n).pipe(Yc(s=>k2(function r7(t,n){return null!==t&&n&&n(new b8(t)),Nn(!0)}(s.route.parent,r),function n7(t,n){return null!==t&&n&&n(new C8(t)),Nn(!0)}(s.route,r),function o7(t,n,e){const r=n[n.length-1],o=n.slice(0,n.length-1).reverse().map(i=>function z8(t){const n=t.routeConfig?t.routeConfig.canActivateChild:null;return n&&0!==n.length?{node:t,guards:n}:null}(i)).filter(i=>null!==i).map(i=>Dw(()=>Nn(i.guards.map(u=>{const c=mf(i.node)??e,l=wd(u,c);return dc(function q8(t){return t&&vf(t.canActivateChild)}(l)?l.canActivateChild(r,t):c.runInContext(()=>l(r,t))).pipe(cc())})).pipe(Cd())));return Nn(o).pipe(Cd())}(t,s.path,e),function s7(t,n,e){const r=n.routeConfig?n.routeConfig.canActivate:null;if(!r||0===r.length)return Nn(!0);const s=r.map(o=>Dw(()=>{const i=mf(n)??e,a=wd(o,i);return dc(function X8(t){return t&&vf(t.canActivate)}(a)?a.canActivate(n,t):i.runInContext(()=>a(n,t))).pipe(cc())}));return Nn(s).pipe(Cd())}(t,s.route,e))),cc(s=>!0!==s,!0))}(r,o,t,n):Nn(a)),Me(a=>({...e,guardsResult:a})))})}(this.environmentInjector,i=>this.events.next(i)),Io(i=>{if(r.guardsResult=i.guardsResult,Jc(i.guardsResult))throw sC(0,i.guardsResult);const a=new m8(i.id,this.urlSerializer.serialize(i.extractedUrl),this.urlSerializer.serialize(i.urlAfterRedirects),i.targetSnapshot,!!i.guardsResult);this.events.next(a)}),uc(i=>!!i.guardsResult||(e.restoreHistory(i),this.cancelNavigationTransition(i,"",3),!1)),t3(i=>{if(i.guards.canActivateChecks.length)return Nn(i).pipe(Io(a=>{const u=new g8(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(u)}),ka(a=>{let u=!1;return Nn(a).pipe(function D7(t,n){return _r(e=>{const{targetSnapshot:r,guards:{canActivateChecks:s}}=e;if(!s.length)return Nn(e);let o=0;return Nt(s).pipe(Yc(i=>function T7(t,n,e,r){const s=t.routeConfig,o=t._resolve;return void 0!==s?.title&&!SC(s)&&(o[sf]=s.title),function N7(t,n,e,r){const s=function k7(t){return[...Object.keys(t),...Object.getOwnPropertySymbols(t)]}(t);if(0===s.length)return Nn({});const o={};return Nt(s).pipe(_r(i=>function A7(t,n,e,r){const s=mf(n)??r,o=wd(t,s);return dc(o.resolve?o.resolve(n,e):s.runInContext(()=>o(n,e)))}(t[i],n,e,r).pipe(cc(),Io(a=>{o[i]=a}))),R2(1),function PO(t){return n=>n.lift(new LO(t))}(o),Zc(i=>Q2(i)?qc:rf(i)))}(o,t,n,r).pipe(Me(i=>(t._resolvedData=i,t.data=tC(t,e).resolve,s&&SC(s)&&(t.data[sf]=s.title),null)))}(i.route,r,t,n)),Io(()=>o++),R2(1),_r(i=>o===s.length?Nn(e):qc))})}(e.paramsInheritanceStrategy,this.environmentInjector),Io({next:()=>u=!0,complete:()=>{u||(e.restoreHistory(a),this.cancelNavigationTransition(a,"",2))}}))}),Io(a=>{const u=new y8(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(u)}))}),t3(i=>{const a=u=>{const c=[];u.routeConfig?.loadComponent&&!u.routeConfig._loadedComponent&&c.push(this.configLoader.loadComponent(u.routeConfig).pipe(Io(l=>{u.component=l}),Me(()=>{})));for(const l of u.children)c.push(...a(l));return c};return Iw(a(i.targetSnapshot.root)).pipe(Tm(),pd(1))}),t3(()=>this.afterPreactivation()),Me(i=>{const a=function A8(t,n,e){const r=ff(t,n._root,e?e._root:void 0);return new Jw(r,n)}(e.routeReuseStrategy,i.targetSnapshot,i.currentRouterState);return r={...i,targetRouterState:a}}),Io(i=>{e.currentUrlTree=i.urlAfterRedirects,e.rawUrlTree=e.urlHandlingStrategy.merge(i.urlAfterRedirects,i.rawUrl),e.routerState=i.targetRouterState,"deferred"===e.urlUpdateStrategy&&(i.extras.skipLocationChange||e.setBrowserUrl(e.rawUrlTree,i),e.browserUrlTree=i.urlAfterRedirects)}),((t,n,e)=>Me(r=>(new U8(n,r.targetRouterState,r.currentRouterState,e).activate(t),r)))(this.rootContexts,e.routeReuseStrategy,i=>this.events.next(i)),pd(1),Io({next:i=>{s=!0,this.lastSuccessfulNavigation=this.currentNavigation,e.navigated=!0,this.events.next(new el(i.id,this.urlSerializer.serialize(i.extractedUrl),this.urlSerializer.serialize(e.currentUrlTree))),e.titleStrategy?.updateTitle(i.targetRouterState.snapshot),i.resolve(!0)},complete:()=>{s=!0}}),O2(()=>{s||o||this.cancelNavigationTransition(r,"",1),this.currentNavigation?.id===r.id&&(this.currentNavigation=null)}),Zc(i=>{if(o=!0,aC(i)){iC(i)||(e.navigated=!0,e.restoreHistory(r,!0));const a=new Fm(r.id,this.urlSerializer.serialize(r.extractedUrl),i.message,i.cancellationCode);if(this.events.next(a),iC(i)){const u=e.urlHandlingStrategy.merge(i.url,e.rawUrlTree),c={skipLocationChange:r.extras.skipLocationChange,replaceUrl:"eager"===e.urlUpdateStrategy||IC(r.source)};e.scheduleNavigation(u,hf,null,c,{resolve:r.resolve,reject:r.reject,promise:r.promise})}else r.resolve(!1)}else{e.restoreHistory(r,!0);const a=new U2(r.id,this.urlSerializer.serialize(r.extractedUrl),i,r.targetSnapshot??void 0);this.events.next(a);try{r.resolve(e.errorHandler(i))}catch(u){r.reject(u)}}return qc}))}))}cancelNavigationTransition(e,r,s){const o=new Fm(e.id,this.urlSerializer.serialize(e.extractedUrl),r,s);this.events.next(o),e.resolve(!1)}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function IC(t){return t!==hf}let DC=(()=>{class t{buildTitle(e){let r,s=e.root;for(;void 0!==s;)r=this.getResolvedTitleForRoute(s)??r,s=s.children.find(o=>o.outlet===Yn);return r}getResolvedTitleForRoute(e){return e.data[sf]}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:function(){return v(O7)},providedIn:"root"}),t})(),O7=(()=>{class t extends DC{constructor(e){super(),this.title=e}updateTitle(e){const r=this.buildTitle(e);void 0!==r&&this.title.setTitle(r)}}return t.\u0275fac=function(e){return new(e||t)(kt(Cw))},t.\u0275prov=vn({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),M7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:function(){return v(F7)},providedIn:"root"}),t})();class $7{shouldDetach(n){return!1}store(n,e){}shouldAttach(n){return!1}retrieve(n){return null}shouldReuseRoute(n,e){return n.routeConfig===e.routeConfig}}let F7=(()=>{class t extends $7{}return t.\u0275fac=function(){let n;return function(r){return(n||(n=function Fl(t){return oe(()=>{const n=t.prototype.constructor,e=n[ln]||mh(n),r=Object.prototype;let s=Object.getPrototypeOf(t.prototype).constructor;for(;s&&s!==r;){const o=s[ln]||mh(s);if(o&&o!==e)return o;s=Object.getPrototypeOf(s)}return o=>new o})}(t)))(r||t)}}(),t.\u0275prov=vn({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const Xm=new An("",{providedIn:"root",factory:()=>({})});let L7=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:function(){return v(B7)},providedIn:"root"}),t})(),B7=(()=>{class t{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,r){return e}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();function V7(t){throw t}function U7(t,n,e){return n.parse("/")}const W7={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},z7={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let Fi=(()=>{class t{get navigationId(){return this.navigationTransitions.navigationId}get browserPageId(){if("computed"===this.canceledNavigationResolution)return this.location.getState()?.\u0275routerPageId}get events(){return this.navigationTransitions.events}constructor(){this.disposed=!1,this.currentPageId=0,this.console=v(Kk),this.isNgZoneEnabled=!1,this.options=v(Xm,{optional:!0})||{},this.errorHandler=this.options.errorHandler||V7,this.malformedUriErrorHandler=this.options.malformedUriErrorHandler||U7,this.navigated=!1,this.lastSuccessfulId=-1,this.urlHandlingStrategy=v(L7),this.routeReuseStrategy=v(M7),this.urlCreationStrategy=v(T8),this.titleStrategy=v(DC),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.config=Ow(v(Sd,{optional:!0})??[]),this.navigationTransitions=v(Km),this.urlSerializer=v(uf),this.location=v(o2),this.isNgZoneEnabled=v(Ts)instanceof Ts&&Ts.isInAngularZone(),this.resetConfig(this.config),this.currentUrlTree=new hc,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=eC(this.currentUrlTree,null),this.navigationTransitions.setupNavigations(this).subscribe(e=>{this.lastSuccessfulId=e.id,this.currentPageId=this.browserPageId??0},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)})}resetRootComponentType(e){this.routerState.root.component=e,this.navigationTransitions.rootComponentType=e}initialNavigation(){if(this.setUpLocationChangeListener(),!this.navigationTransitions.hasRequestedNavigation){const e=this.location.getState();this.navigateToSyncWithBrowser(this.location.path(!0),hf,e)}}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const r="popstate"===e.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{this.navigateToSyncWithBrowser(e.url,r,e.state)},0)}))}navigateToSyncWithBrowser(e,r,s){const o={replaceUrl:!0},i=s?.navigationId?s:null;if(s){const u={...s};delete u.navigationId,delete u.\u0275routerPageId,0!==Object.keys(u).length&&(o.state=u)}const a=this.parseUrl(e);this.scheduleNavigation(a,r,i,o)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}resetConfig(e){this.config=e.map(Z2),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,r={}){const{relativeTo:s,queryParams:o,fragment:i,queryParamsHandling:a,preserveFragment:u}=r,c=u?this.currentUrlTree.fragment:i;let l=null;switch(a){case"merge":l={...this.currentUrlTree.queryParams,...o};break;case"preserve":l=this.currentUrlTree.queryParams;break;default:l=o||null}return null!==l&&(l=this.removeEmptyProps(l)),this.urlCreationStrategy.createUrlTree(s,this.routerState,this.currentUrlTree,e,l,c??null)}navigateByUrl(e,r={skipLocationChange:!1}){const s=Jc(e)?e:this.parseUrl(e),o=this.urlHandlingStrategy.merge(s,this.rawUrlTree);return this.scheduleNavigation(o,hf,null,r)}navigate(e,r={skipLocationChange:!1}){return function H7(t){for(let n=0;n<t.length;n++){const e=t[n];if(null==e)throw new Pt(4008,false)}}(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let r;try{r=this.urlSerializer.parse(e)}catch(s){r=this.malformedUriErrorHandler(s,this.urlSerializer,e)}return r}isActive(e,r){let s;if(s=!0===r?{...W7}:!1===r?{...z7}:r,Jc(e))return Fw(this.currentUrlTree,e,s);const o=this.parseUrl(e);return Fw(this.currentUrlTree,o,s)}removeEmptyProps(e){return Object.keys(e).reduce((r,s)=>{const o=e[s];return null!=o&&(r[s]=o),r},{})}scheduleNavigation(e,r,s,o,i){if(this.disposed)return Promise.resolve(!1);let a,u,c,l;return i?(a=i.resolve,u=i.reject,c=i.promise):c=new Promise((h,f)=>{a=h,u=f}),l="computed"===this.canceledNavigationResolution?s&&s.\u0275routerPageId?s.\u0275routerPageId:(this.browserPageId??0)+1:0,this.navigationTransitions.handleNavigationRequest({targetPageId:l,source:r,restoredState:s,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,rawUrl:e,extras:o,resolve:a,reject:u,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(h=>Promise.reject(h))}setBrowserUrl(e,r){const s=this.urlSerializer.serialize(e);if(this.location.isCurrentPathEqualTo(s)||r.extras.replaceUrl){const i={...r.extras.state,...this.generateNgRouterState(r.id,this.browserPageId)};this.location.replaceState(s,"",i)}else{const o={...r.extras.state,...this.generateNgRouterState(r.id,r.targetPageId)};this.location.go(s,"",o)}}restoreHistory(e,r=!1){if("computed"===this.canceledNavigationResolution){const o=this.currentPageId-(this.browserPageId??this.currentPageId);0!==o?this.location.historyGo(o):this.currentUrlTree===this.getCurrentNavigation()?.finalUrl&&0===o&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree())}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(e,r){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=vn({token:t,factory:t.\u0275fac,providedIn:"root"}),t})(),Ed=(()=>{class t{constructor(e,r,s,o,i,a){this.router=e,this.route=r,this.tabIndexAttribute=s,this.renderer=o,this.el=i,this.locationStrategy=a,this._preserveFragment=!1,this._skipLocationChange=!1,this._replaceUrl=!1,this.href=null,this.commands=null,this.onChanges=new ce;const u=i.nativeElement.tagName?.toLowerCase();this.isAnchorElement="a"===u||"area"===u,this.isAnchorElement?this.subscription=e.events.subscribe(c=>{c instanceof el&&this.updateHref()}):this.setTabIndexIfNotOnNativeEl("0")}set preserveFragment(e){this._preserveFragment=t2(e)}get preserveFragment(){return this._preserveFragment}set skipLocationChange(e){this._skipLocationChange=t2(e)}get skipLocationChange(){return this._skipLocationChange}set replaceUrl(e){this._replaceUrl=t2(e)}get replaceUrl(){return this._replaceUrl}setTabIndexIfNotOnNativeEl(e){null!=this.tabIndexAttribute||this.isAnchorElement||this.applyAttributeValue("tabindex",e)}ngOnChanges(e){this.isAnchorElement&&this.updateHref(),this.onChanges.next(this)}set routerLink(e){null!=e?(this.commands=Array.isArray(e)?e:[e],this.setTabIndexIfNotOnNativeEl("0")):(this.commands=null,this.setTabIndexIfNotOnNativeEl(null))}onClick(e,r,s,o,i){return!!(null===this.urlTree||this.isAnchorElement&&(0!==e||r||s||o||i||"string"==typeof this.target&&"_self"!=this.target))||(this.router.navigateByUrl(this.urlTree,{skipLocationChange:this.skipLocationChange,replaceUrl:this.replaceUrl,state:this.state}),!this.isAnchorElement)}ngOnDestroy(){this.subscription?.unsubscribe()}updateHref(){this.href=null!==this.urlTree&&this.locationStrategy?this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(this.urlTree)):null;const e=null===this.href?null:function Py(t,n,e){return function KI(t,n){return"src"===n&&("embed"===t||"frame"===t||"iframe"===t||"media"===t||"script"===t)||"href"===n&&("base"===t||"link"===t)?Fy:$y}(n,e)(t)}(this.href,this.el.nativeElement.tagName.toLowerCase(),"href");this.applyAttributeValue("href",e)}applyAttributeValue(e,r){const s=this.renderer,o=this.el.nativeElement;null!==r?s.setAttribute(o,e,r):s.removeAttribute(o,e)}get urlTree(){return null===this.commands?null:this.router.createUrlTree(this.commands,{relativeTo:void 0!==this.relativeTo?this.relativeTo:this.route,queryParams:this.queryParams,fragment:this.fragment,queryParamsHandling:this.queryParamsHandling,preserveFragment:this.preserveFragment})}}return t.\u0275fac=function(e){return new(e||t)(Rn(Fi),Rn(bd),function Pl(t){return function Pg(t,n){if("class"===n)return t.classes;if("style"===n)return t.styles;const e=t.attrs;if(e){const r=e.length;let s=0;for(;s<r;){const o=e[s];if(qf(o))break;if(0===o)s+=2;else if("number"==typeof o)for(s++;s<r&&"string"==typeof e[s];)s++;else{if(o===n)return e[s+1];s+=2}}}return null}(Is(),t)}("tabindex"),Rn($p),Rn(eu),Rn(Xc))},t.\u0275dir=Es({type:t,selectors:[["","routerLink",""]],hostVars:1,hostBindings:function(e,r){1&e&&ru("click",function(o){return r.onClick(o.button,o.ctrlKey,o.shiftKey,o.altKey,o.metaKey)}),2&e&&u0("target",r.target)},inputs:{target:"target",queryParams:"queryParams",fragment:"fragment",queryParamsHandling:"queryParamsHandling",state:"state",relativeTo:"relativeTo",preserveFragment:"preserveFragment",skipLocationChange:"skipLocationChange",replaceUrl:"replaceUrl",routerLink:"routerLink"},standalone:!0,features:[xa]}),t})();class TC{}let K7=(()=>{class t{constructor(e,r,s,o,i){this.router=e,this.injector=s,this.preloadingStrategy=o,this.loader=i}setUpPreloading(){this.subscription=this.router.events.pipe(uc(e=>e instanceof el),Yc(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,r){const s=[];for(const o of r){o.providers&&!o._injector&&(o._injector=tm(o.providers,e,`Route: ${o.path}`));const i=o._injector??e,a=o._loadedInjector??i;(o.loadChildren&&!o._loadedRoutes&&void 0===o.canLoad||o.loadComponent&&!o._loadedComponent)&&s.push(this.preloadConfig(i,o)),(o.children||o._loadedRoutes)&&s.push(this.processRoutes(a,o.children??o._loadedRoutes))}return Nt(s).pipe(Fr())}preloadConfig(e,r){return this.preloadingStrategy.preload(r,()=>{let s;s=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(e,r):Nn(null);const o=s.pipe(_r(i=>null===i?Nn(void 0):(r._loadedRoutes=i.routes,r._loadedInjector=i.injector,this.processRoutes(i.injector??e,i.routes))));return r.loadComponent&&!r._loadedComponent?Nt([o,this.loader.loadComponent(r)]).pipe(Fr()):o})}}return t.\u0275fac=function(e){return new(e||t)(kt(Fi),kt(sb),kt(Tu),kt(TC),kt(n3))},t.\u0275prov=vn({token:t,factory:t.\u0275fac,providedIn:"root"}),t})();const s3=new An("");let NC=(()=>{class t{constructor(e,r,s,o,i={}){this.urlSerializer=e,this.transitions=r,this.viewportScroller=s,this.zone=o,this.options=i,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},i.scrollPositionRestoration=i.scrollPositionRestoration||"disabled",i.anchorScrolling=i.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof V2?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof el&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.transitions.events.subscribe(e=>{e instanceof Zw&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.transitions.events.next(new Zw(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription?.unsubscribe(),this.scrollEventsSubscription?.unsubscribe()}}return t.\u0275fac=function(e){!function p4(){throw new Error("invalid")}()},t.\u0275prov=vn({token:t,factory:t.\u0275fac}),t})();var Pi=(()=>((Pi=Pi||{})[Pi.COMPLETE=0]="COMPLETE",Pi[Pi.FAILED=1]="FAILED",Pi[Pi.REDIRECTING=2]="REDIRECTING",Pi))();const _d=!1;function fc(t,n){return{\u0275kind:t,\u0275providers:n}}const o3=new An("",{providedIn:"root",factory:()=>!1});function AC(){const t=v(ku);return n=>{const e=t.get(um);if(n!==e.components[0])return;const r=t.get(Fi),s=t.get(RC);1===t.get(i3)&&r.initialNavigation(),t.get(OC,null,mn.Optional)?.setUpPreloading(),t.get(s3,null,mn.Optional)?.init(),r.resetRootComponentType(e.componentTypes[0]),s.closed||(s.next(),s.complete(),s.unsubscribe())}}const RC=new An(_d?"bootstrap done indicator":"",{factory:()=>new ce}),i3=new An(_d?"initial navigation":"",{providedIn:"root",factory:()=>1});function Q7(){let t=[];return t=_d?[{provide:Rp,multi:!0,useFactory:()=>{const n=v(Fi);return()=>n.events.subscribe(e=>{console.group?.(`Router Event: ${e.constructor.name}`),console.log(function E8(t){if(!("type"in t))return`Unknown Router Event: ${t.constructor.name}`;switch(t.type){case 14:return`ActivationEnd(path: '${t.snapshot.routeConfig?.path||""}')`;case 13:return`ActivationStart(path: '${t.snapshot.routeConfig?.path||""}')`;case 12:return`ChildActivationEnd(path: '${t.snapshot.routeConfig?.path||""}')`;case 11:return`ChildActivationStart(path: '${t.snapshot.routeConfig?.path||""}')`;case 8:return`GuardsCheckEnd(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}', state: ${t.state}, shouldActivate: ${t.shouldActivate})`;case 7:return`GuardsCheckStart(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}', state: ${t.state})`;case 2:return`NavigationCancel(id: ${t.id}, url: '${t.url}')`;case 16:return`NavigationSkipped(id: ${t.id}, url: '${t.url}')`;case 1:return`NavigationEnd(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}')`;case 3:return`NavigationError(id: ${t.id}, url: '${t.url}', error: ${t.error})`;case 0:return`NavigationStart(id: ${t.id}, url: '${t.url}')`;case 6:return`ResolveEnd(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}', state: ${t.state})`;case 5:return`ResolveStart(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}', state: ${t.state})`;case 10:return`RouteConfigLoadEnd(path: ${t.route.path})`;case 9:return`RouteConfigLoadStart(path: ${t.route.path})`;case 4:return`RoutesRecognized(id: ${t.id}, url: '${t.url}', urlAfterRedirects: '${t.urlAfterRedirects}', state: ${t.state})`;case 15:return`Scroll(anchor: '${t.anchor}', position: '${t.position?`${t.position[0]}, ${t.position[1]}`:null}')`}}(e)),console.log(e),console.groupEnd?.()})}}]:[],fc(1,t)}const OC=new An(_d?"router preloader":"");function J7(t){return fc(0,[{provide:OC,useExisting:K7},{provide:TC,useExisting:t}])}const bf=!1,MC=new An(bf?"router duplicate forRoot guard":"ROUTER_FORROOT_GUARD"),eM=[o2,{provide:uf,useClass:M2},Fi,pf,{provide:bd,useFactory:function kC(t){return t.routerState.root},deps:[Fi]},n3,bf?{provide:o3,useValue:!0}:[]];function tM(){return new hb("Router",Fi)}let a3=(()=>{class t{constructor(e){}static forRoot(e,r){return{ngModule:t,providers:[eM,bf&&r?.enableTracing?Q7().\u0275providers:[],{provide:Sd,multi:!0,useValue:e},{provide:MC,useFactory:oM,deps:[[Fi,new Fc,new Eu]]},{provide:Xm,useValue:r||{}},r?.useHash?{provide:Xc,useClass:MA}:{provide:Xc,useClass:$b},{provide:s3,useFactory:()=>{const t=v(eR),n=v(Ts),e=v(Xm),r=v(Km),s=v(uf);return e.scrollOffset&&t.setOffset(e.scrollOffset),new NC(s,r,t,n,e)}},r?.preloadingStrategy?J7(r.preloadingStrategy).\u0275providers:[],{provide:hb,multi:!0,useFactory:tM},r?.initialNavigation?iM(r):[],[{provide:$C,useFactory:AC},{provide:db,multi:!0,useExisting:$C}]]}}static forChild(e){return{ngModule:t,providers:[{provide:Sd,multi:!0,useValue:e}]}}}return t.\u0275fac=function(e){return new(e||t)(kt(MC,8))},t.\u0275mod=Hs({type:t}),t.\u0275inj=Ws({imports:[q2]}),t})();function oM(t){if(bf&&t)throw new Pt(4007,"The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead.");return"guarded"}function iM(t){return["disabled"===t.initialNavigation?fc(3,[{provide:om,multi:!0,useFactory:()=>{const n=v(Fi);return()=>{n.setUpLocationChangeListener()}}},{provide:i3,useValue:2}]).\u0275providers:[],"enabledBlocking"===t.initialNavigation?fc(2,[{provide:i3,useValue:0},{provide:om,multi:!0,deps:[ku],useFactory:n=>{const e=n.get(RA,Promise.resolve());return()=>e.then(()=>new Promise(r=>{const s=n.get(Fi),o=n.get(RC);(function X7(t,n){t.events.pipe(uc(e=>e instanceof el||e instanceof Fm||e instanceof U2||e instanceof Pm),Me(e=>e instanceof el||e instanceof Pm?Pi.COMPLETE:e instanceof Fm&&(0===e.code||1===e.code)?Pi.REDIRECTING:Pi.FAILED),uc(e=>e!==Pi.REDIRECTING),pd(1)).subscribe(()=>{n()})})(s,()=>{r(!0)}),n.get(Km).afterPreactivation=()=>(r(!0),o.closed?Nn(void 0):o),s.initialNavigation()}))}}]).\u0275providers:[]]}const $C=new An(bf?"Router Initializer":""),uM=[];let cM=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Hs({type:t}),t.\u0275inj=Ws({imports:[a3.forRoot(uM),a3]}),t})(),lM=(()=>{class t{constructor(){this.title="angular-snow"}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=ns({type:t,selectors:[["app-root"]],decls:1,vars:0,template:function(e,r){1&e&&li(0,"router-outlet")},dependencies:[X2]}),t})();var bs=M(5861),wf=(()=>(function(t){t[t.English=0]="English",t[t.Russian=1]="Russian",t[t.Czech=2]="Czech"}(wf||(wf={})),wf))();class dM{constructor(){this.selectedLanguage=wf.English,this.firstOpened=!0,this.secondOpened=!1,this.launchedTurn=!1,this.halfFinishedTurn=!1}}function hM(t,n){if(1&t){const e=h0();yr(0,"div",1)(1,"div",2),ru("click",function(){return Zi(e),Qi(Ca().turnCard())}),Mr(),yr(2,"div",3)(3,"div",4),Ps(4,"Egor Ulianov"),Mr(),yr(5,"div",5),Ps(6,"Software developer"),Mr(),yr(7,"div",6)(8,"div",7)(9,"div",8),ru("click",function(){Zi(e);const s=Ca();return Qi(s.setLanguage(s.languagesEnum.Russian))}),Ps(10,"C2"),Mr()(),yr(11,"div",9)(12,"div",8),ru("click",function(){Zi(e);const s=Ca();return Qi(s.setLanguage(s.languagesEnum.English))}),Ps(13,"B2"),Mr()(),yr(14,"div",10)(15,"div",8),ru("click",function(){Zi(e);const s=Ca();return Qi(s.setLanguage(s.languagesEnum.Czech))}),Ps(16,"C1"),Mr()()()(),yr(17,"div",11)(18,"div",12),Ps(19," Born in Siberia in 2000 "),Mr(),yr(20,"div",12),Ps(21," Graduated from high school in 2018 with honors "),Mr(),yr(22,"div",12),Ps(23," Moved to the Czech Republic in 2018 "),Mr(),yr(24,"div",12),Ps(25," Work in Misterine s.r.o. since summer 2019 "),Mr(),yr(26,"div",12),Ps(27," Graduated from the FEE CTU in Prague with a bachelor's degree in 2022 "),Mr()()()}if(2&t){const e=Ca();Hc("card-container-half-rotate",e.viewModel.launchedTurn),Eo(8),Hc("flag-chosen",e.viewModel.selectedLanguage===e.languagesEnum.Russian),Eo(3),Hc("flag-chosen",e.viewModel.selectedLanguage===e.languagesEnum.English),Eo(3),Hc("flag-chosen",e.viewModel.selectedLanguage===e.languagesEnum.Czech)}}function fM(t,n){if(1&t){const e=h0();yr(0,"div",1)(1,"div",13)(2,"div",14),Ps(3,"My social networks"),Mr()(),yr(4,"div",15)(5,"div",16),ru("click",function(){return Zi(e),Qi(Ca().toTelegramPage())}),li(6,"div",17),yr(7,"div"),Ps(8,"Telegram"),Mr()(),yr(9,"div",16),ru("click",function(){return Zi(e),Qi(Ca().toLinkedInPage())}),li(10,"div",18),yr(11,"div"),Ps(12,"LinkedIn"),Mr()(),yr(13,"div",16),ru("click",function(){return Zi(e),Qi(Ca().toGithubPage())}),li(14,"div",19),yr(15,"div"),Ps(16,"GitHub"),Mr()()()()}2&t&&Hc("card-container-half-rotate",Ca().viewModel.halfFinishedTurn)}let pM=(()=>{class t{constructor(){this.viewModel=new dM}get languagesEnum(){return wf}ngOnInit(){}setLanguage(e){this.viewModel.selectedLanguage=e}turnCard(){var e=this;return(0,bs.Z)(function*(){e.viewModel.launchedTurn=!0,yield e.delay(300),e.viewModel.launchedTurn=!1,e.viewModel.firstOpened=!1,e.viewModel.secondOpened=!0,e.viewModel.halfFinishedTurn=!0,yield e.delay(300),e.viewModel.halfFinishedTurn=!1})()}toTelegramPage(){window.open("https://t.me/egor_ulianov","_blank")}toLinkedInPage(){window.open("https://www.linkedin.com/in/egor-ulianov-858aa5190/","_blank")}toGithubPage(){window.open("https://github.com/egor-ulianov","_blank")}delay(e){return(0,bs.Z)(function*(){return new Promise(r=>setTimeout(r,e))})()}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=ns({type:t,selectors:[["app-introduction-card"]],decls:2,vars:2,consts:[["class","card-container card-flex-container",3,"card-container-half-rotate",4,"ngIf"],[1,"card-container","card-flex-container"],[1,"avatar-logo",3,"click"],[1,"header"],[1,"name-surname-text"],[1,"description"],[1,"flags"],[1,"flag","ru-flag"],[1,"flag-content",3,"click"],[1,"flag","en-flag"],[1,"flag","cz-flag"],[1,"biography"],[1,"biography-point"],[1,"header","header-back"],[1,""],[1,"networks-container"],[1,"network-point",3,"click"],[1,"qr-image","telegram-qr"],[1,"qr-image","linkedin-qr"],[1,"qr-image","github-qr"]],template:function(e,r){1&e&&(Wc(0,hM,28,8,"div",0),Wc(1,fM,17,2,"div",0)),2&e&&($i("ngIf",r.viewModel.firstOpened),Eo(1),$i("ngIf",r.viewModel.secondOpened))},dependencies:[Jh],styles:["body[_ngcontent-%COMP%]{perspective:800px;min-width:540px;min-height:590px;width:auto!important;width:540px;width:590px}@media (orientation: landscape){.card-container[_ngcontent-%COMP%]{padding:5vw;height:65vh;width:65vw}.networks-container[_ngcontent-%COMP%]{flex-direction:row}.avatar-logo[_ngcontent-%COMP%]{width:30vh;border-radius:15px;height:30vh}.header[_ngcontent-%COMP%]{font-size:clamp(20px,6vh,40px);width:220px}.description[_ngcontent-%COMP%]{font-size:clamp(15px,5vh,30px)}}@media (orientation: portrait){.card-container[_ngcontent-%COMP%]{padding:5vh;height:70vh;width:65vw;margin-top:10vh!important}.networks-container[_ngcontent-%COMP%]{flex-direction:column}.avatar-logo[_ngcontent-%COMP%]{width:25vw;border-radius:15px;height:25vw}.header[_ngcontent-%COMP%]{font-size:clamp(20px,6vw,40px);width:170px!important}.description[_ngcontent-%COMP%]{font-size:clamp(15px,5vw,30px)}}@media only screen and (min-width: 950px){.biography[_ngcontent-%COMP%]{font-size:clamp(20px,3.5vh,30px)!important}.qr-image[_ngcontent-%COMP%]{width:30vh!important;height:30vh!important}}.card-container[_ngcontent-%COMP%]{margin:auto;background:#205295;background:linear-gradient(180deg,rgba(32,82,149,1) 0%,rgba(44,116,179,1) 100%);border:0px;border-radius:15px;transition:ease .3s all;box-shadow:0 0 50px #325782}.card-flex-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;flex-wrap:wrap;justify-content:space-between;align-items:flex-start;align-content:stretch;gap:20px}.card-container-half-rotate[_ngcontent-%COMP%]{transform:rotate3d(-.2,2,0,90deg)}.avatar-logo[_ngcontent-%COMP%]{background-image:url(avatar.0f62eb719157c503.png);background-position:center;background-repeat:no-repeat;background-size:cover;margin-left:auto;margin-right:auto;min-width:110px;min-height:110px}.header[_ngcontent-%COMP%]{font-family:Chakra Petch,sans-serif;white-space:initial;color:#f5f5f5;height:-moz-fit-content;height:fit-content;display:flex;flex-direction:column;width:220px;margin-left:auto;margin-right:auto}.header-back[_ngcontent-%COMP%]{width:auto;margin:0 auto;height:-moz-fit-content;height:fit-content;text-align:center}.name-surname-text[_ngcontent-%COMP%]{margin:0 auto 5px;font-weight:600;white-space:initial}.description[_ngcontent-%COMP%]{font-weight:200;white-space:initial;margin:0 auto 5px}.flags[_ngcontent-%COMP%]{white-space:initial;font-size:x-large;margin:0 auto 10px;display:flex;flex-direction:row;justify-content:space-between;align-items:flex-start}.flag[_ngcontent-%COMP%]{width:40px;height:30px;margin:1vw}.ru-flag[_ngcontent-%COMP%]{background-image:url(russia-flag.d66948757733184b.png);background-position:center;background-repeat:no-repeat;background-size:cover}.flag-content[_ngcontent-%COMP%]{transition:ease .3s all;opacity:0;text-align:center;border-radius:5px}.flag-content[_ngcontent-%COMP%]:hover{opacity:1;background-color:#2053957c;cursor:pointer}.flag-chosen[_ngcontent-%COMP%]{border:whitesmoke 2px solid;border-radius:5px;width:36px;height:26px}.en-flag[_ngcontent-%COMP%]{background-image:url(britain-flag.f156aa16e18fc721.png);background-position:center;background-repeat:no-repeat;background-size:cover}.cz-flag[_ngcontent-%COMP%]{background-image:url(czech_flag.93c0a03583cb089d.png);background-position:center;background-repeat:no-repeat;background-size:cover}.biography[_ngcontent-%COMP%]{font-family:Chakra Petch,sans-serif;white-space:initial;color:#f5f5f5;display:flex;flex-direction:column;font-size:clamp(15px,2vh,25px);margin:auto auto auto 0;text-align:left}.biography-point[_ngcontent-%COMP%]{background-image:url(snowflake.9ed12a50aefb788d.png);background-position:left top 5px;background-repeat:no-repeat;background-size:2vh 2vh;padding-left:3vh}.backside-container[_ngcontent-%COMP%]{flex-direction:column}.networks-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;font-family:Chakra Petch,sans-serif;white-space:initial;flex-wrap:wrap;color:#f5f5f5;justify-content:center;margin-left:auto;margin-right:auto}.network-point[_ngcontent-%COMP%]{text-align:center;display:flex;flex-direction:column;margin:10px;cursor:pointer;transition:ease .3s all}.network-point[_ngcontent-%COMP%]:hover{transform:scale(1.05)}.qr-image[_ngcontent-%COMP%]{width:15vh;border-radius:15px;height:15vh;background-position:center;background-repeat:no-repeat;background-size:cover}.telegram-qr[_ngcontent-%COMP%]{background-image:url(telegram.c6f01acd8bd504ce.png)}.linkedin-qr[_ngcontent-%COMP%]{background-image:url(linkedin.df59a702f0e0ab15.png)}.github-qr[_ngcontent-%COMP%]{background-image:url(github.ce435cd2e389f5ef.png)}"]}),t})();class u3{constructor(n,e,r,s){this.label=n,this.description=e,this.link=r,this.faIcon=s}}class mM{constructor(){this.menuItems=[new u3("About me","Here you can find some information about me and my main social networks","/introduction","fa-solid fa-id-card"),new u3("Face detector","Find out how awesome you are","/face-detector","fa-solid fa-face-grin-wide"),new u3("Object detector","Integration of TensorFlow JS SSD COCO demo","/object-detector","fa-regular fa-location-crosshairs")]}}function gM(t,n){if(1&t&&(yr(0,"div",7),li(1,"i"),Mr()),2&t){const e=Ca().$implicit;Eo(1),pv(e.faIcon)}}const yM=function(t){return[t]};function vM(t,n){if(1&t&&(yr(0,"div",3),Wc(1,gM,2,3,"div",4),yr(2,"div",5),Ps(3),Mr(),yr(4,"div",6),Ps(5),Mr()()),2&t){const e=n.$implicit;$i("routerLink",Sx(4,yM,e.link)),Eo(1),$i("ngIf",e.faIcon),Eo(2),Yp(e.label),Eo(2),Yp(e.description)}}let xM=(()=>{class t{constructor(){this.viewModel=new mM}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275cmp=ns({type:t,selectors:[["app-home"]],decls:5,vars:1,consts:[["id","welcome",1,"welcome"],["id","menu",1,"menu-container"],["class","menu-item",3,"routerLink",4,"ngFor","ngForOf"],[1,"menu-item",3,"routerLink"],["class","menu-icon",4,"ngIf"],[1,"menu-title"],[1,"menu-description"],[1,"menu-icon"]],template:function(e,r){1&e&&(yr(0,"div")(1,"div",0),Ps(2," Welcome to my GitHub! "),Mr(),yr(3,"div",1),Wc(4,vM,6,6,"div",2),Mr()()),2&e&&(Eo(4),$i("ngForOf",r.viewModel.menuItems))},dependencies:[Xb,Jh,Ed],styles:[".welcome[_ngcontent-%COMP%]{color:#f5f5f5;font-family:Chakra Petch,sans-serif;width:100vw;display:flex;justify-content:space-around;font-size:xx-large;margin-top:5vh}.menu-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;overflow-x:scroll;overflow-y:hidden;-ms-overflow-style:none;scrollbar-width:none;justify-content:flex-start;margin-left:5vw;margin-right:5vw;margin-top:5vh;gap:10px;max-width:-moz-fit-content;max-width:fit-content;margin-left:auto;margin-right:auto}.menu-container[_ngcontent-%COMP%]::-webkit-scrollbar{display:none}.menu-item[_ngcontent-%COMP%]{min-width:300px;max-width:300px;height:500px;max-height:60vh;color:#f5f5f5;font-family:Chakra Petch,sans-serif;background-color:#000000d4;border-radius:5px;text-align:center;padding:15px;transition:all .3s ease}.menu-item[_ngcontent-%COMP%]:hover{scale:1.02;background-color:#000000f2}.menu-icon[_ngcontent-%COMP%]{font-size:60px}.menu-title[_ngcontent-%COMP%]{margin-top:20px;font-size:xx-large}.menu-description[_ngcontent-%COMP%]{margin-top:20px;font-size:x-large}"]}),t})();class bM{constructor(){this.cameraHeight=1,this.cameraWidth=1,this.isCameraLoaded=!1}}var wM=M(3866),d=M(1726),FC=M(4554),Aa=function(){return Aa=Object.assign||function(t){for(var n,e=1,r=arguments.length;e<r;e++)for(var s in n=arguments[e])Object.prototype.hasOwnProperty.call(n,s)&&(t[s]=n[s]);return t},Aa.apply(this,arguments)};function Lu(t,n,e,r){return new(e||(e=Promise))(function(s,o){function i(c){try{u(r.next(c))}catch(l){o(l)}}function a(c){try{u(r.throw(c))}catch(l){o(l)}}function u(c){var l;c.done?s(c.value):(l=c.value,l instanceof e?l:new e(function(h){h(l)})).then(i,a)}u((r=r.apply(t,n||[])).next())})}function Bu(t,n){var e,r,s,o,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(u){return function(c){return function(l){if(e)throw new TypeError("Generator is already executing.");for(;i;)try{if(e=1,r&&(s=2&l[0]?r.return:l[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,l[1])).done)return s;switch(r=0,s&&(l=[2&l[0],s.value]),l[0]){case 0:case 1:s=l;break;case 4:return i.label++,{value:l[1],done:!1};case 5:i.label++,r=l[1],l=[0];continue;case 7:l=i.ops.pop(),i.trys.pop();continue;default:if(!((s=(s=i.trys).length>0&&s[s.length-1])||6!==l[0]&&2!==l[0])){i=0;continue}if(3===l[0]&&(!s||l[1]>s[0]&&l[1]<s[3])){i.label=l[1];break}if(6===l[0]&&i.label<s[1]){i.label=s[1],s=l;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(l);break}s[2]&&i.ops.pop(),i.trys.pop();continue}l=n.call(t,i)}catch(h){l=[6,h],r=0}finally{e=s=0}if(5&l[0])throw l[1];return{value:l[0]?l[1]:void 0,done:!0}}([u,c])}}}function pc(t){var n=t.map(function(e){return e[0]});return n.push(t[t.length-1][1]),n}var PC={lips:pc([[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]]),leftEye:pc([[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]]),leftEyebrow:pc([[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]]),leftIris:pc([[474,475],[475,476],[476,477],[477,474]]),rightEye:pc([[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]]),rightEyebrow:pc([[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]]),rightIris:pc([[469,470],[470,471],[471,472],[472,469]]),faceOval:pc([[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]])},CM=[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]],SM=Object.entries(PC).map(function(t){var n=t[0];return t[1].map(function(e){return[e,n]})}).flat(),LC=new Map(SM);function c3(t){for(var n={locationData:{relativeKeypoints:[]}},e=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,i=0;i<t.length;++i){var a=t[i];e=Math.min(e,a.x),r=Math.max(r,a.x),s=Math.min(s,a.y),o=Math.max(o,a.y),n.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return n.locationData.relativeBoundingBox={xMin:e,yMin:s,xMax:r,yMax:o,width:r-e,height:o-s},n}var l3={runtime:"mediapipe",maxFaces:1,refineLandmarks:!1},EM=function(){function t(n){var e=this;this.width=0,this.height=0,this.selfieMode=!1,this.faceMeshSolution=new wM.FaceMesh({locateFile:function(r,s){return n.solutionPath?n.solutionPath.replace(/\/+$/,"")+"/"+r:s+"/"+r}}),this.faceMeshSolution.setOptions({refineLandmarks:n.refineLandmarks,selfieMode:this.selfieMode,maxNumFaces:n.maxFaces}),this.faceMeshSolution.onResults(function(r){if(e.height=r.image.height,e.width=r.image.width,e.faces=[],null!==r.multiFaceLandmarks)for(var s=r.multiFaceLandmarks,o=0;o<s.length;o++){var i=e.translateOutput(s[o]);e.faces.push({keypoints:i,box:c3(i).locationData.relativeBoundingBox})}})}return t.prototype.translateOutput=function(n){var e=this;return n.map(function(r,s){var o={x:r.x*e.width,y:r.y*e.height,z:r.z*e.width},i=LC.get(s);return null!=i&&(o.name=i),o})},t.prototype.estimateFaces=function(n,e){return Lu(this,void 0,void 0,function(){var r,s;return Bu(this,function(o){switch(o.label){case 0:return e&&e.flipHorizontal&&e.flipHorizontal!==this.selfieMode&&(this.selfieMode=e.flipHorizontal,this.faceMeshSolution.setOptions({selfieMode:this.selfieMode})),n instanceof d.Tensor?(s=ImageData.bind,[4,d.browser.toPixels(n)]):[3,2];case 1:return r=new(s.apply(ImageData,[void 0,o.sent(),n.shape[1],n.shape[0]])),[3,3];case 2:r=n,o.label=3;case 3:return[4,this.faceMeshSolution.send({image:n=r})];case 4:return o.sent(),[2,this.faces]}})})},t.prototype.dispose=function(){this.faceMeshSolution.close()},t.prototype.reset=function(){this.faceMeshSolution.reset(),this.width=0,this.height=0,this.faces=null,this.selfieMode=!1},t.prototype.initialize=function(){return this.faceMeshSolution.initialize()},t}();function _M(t){return Lu(this,void 0,void 0,function(){var n,e;return Bu(this,function(r){switch(r.label){case 0:return n=function(s){if(null==s)return Aa({},l3);var o=Aa({},s);return o.runtime="mediapipe",null==o.maxFaces&&(o.maxFaces=l3.maxFaces),null==o.refineLandmarks&&(o.refineLandmarks=l3.refineLandmarks),o}(t),[4,(e=new EM(n)).initialize()];case 1:return r.sent(),[2,e]}})})}var d3=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},IM={};(function(){var t;function n(S){var z=0;return function(){return z<S.length?{done:!1,value:S[z++]}:{done:!0}}}var e="function"==typeof Object.defineProperties?Object.defineProperty:function(S,z,J){return S==Array.prototype||S==Object.prototype||(S[z]=J.value),S},r=function(S){S=["object"==typeof globalThis&&globalThis,S,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof d3&&d3];for(var z=0;z<S.length;++z){var J=S[z];if(J&&J.Math==Math)return J}throw Error("Cannot find global object")}(this);function s(S,z){if(z)e:{var J=r;S=S.split(".");for(var ie=0;ie<S.length-1;ie++){var De=S[ie];if(!(De in J))break e;J=J[De]}(z=z(ie=J[S=S[S.length-1]]))!=ie&&null!=z&&e(J,S,{configurable:!0,writable:!0,value:z})}}function o(S){return(S={next:S})[Symbol.iterator]=function(){return this},S}function i(S){var z=typeof Symbol<"u"&&Symbol.iterator&&S[Symbol.iterator];return z?z.call(S):{next:n(S)}}function a(S){if(!(S instanceof Array)){S=i(S);for(var z,J=[];!(z=S.next()).done;)J.push(z.value);S=J}return S}s("Symbol",function(S){function z(De,Ee){this.g=De,e(this,"description",{configurable:!0,writable:!0,value:Ee})}if(S)return S;z.prototype.toString=function(){return this.g};var J="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",ie=0;return function De(Ee){if(this instanceof De)throw new TypeError("Symbol is not a constructor");return new z(J+(Ee||"")+"_"+ie++,Ee)}}),s("Symbol.iterator",function(S){if(S)return S;S=Symbol("Symbol.iterator");for(var z="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),J=0;J<z.length;J++){var ie=r[z[J]];"function"==typeof ie&&"function"!=typeof ie.prototype[S]&&e(ie.prototype,S,{configurable:!0,writable:!0,value:function(){return o(n(this))}})}return S});var u,c="function"==typeof Object.create?Object.create:function(S){function z(){}return z.prototype=S,new z};if("function"==typeof Object.setPrototypeOf)u=Object.setPrototypeOf;else{var l;e:{var h={};try{h.__proto__={a:!0},l=h.a;break e}catch{}l=!1}u=l?function(S,z){if(S.__proto__=z,S.__proto__!==z)throw new TypeError(S+" is not extensible");return S}:null}var f=u;function m(S,z){if(S.prototype=c(z.prototype),S.prototype.constructor=S,f)f(S,z);else for(var J in z)if("prototype"!=J)if(Object.defineProperties){var ie=Object.getOwnPropertyDescriptor(z,J);ie&&Object.defineProperty(S,J,ie)}else S[J]=z[J];S.na=z.prototype}function y(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.u=this.o=0,this.j=null}function w(S){if(S.l)throw new TypeError("Generator is already running");S.l=!0}function E(S,z){S.j={da:z,ea:!0},S.g=S.o||S.u}function D(S,z,J){return S.g=J,{value:z}}function O(S){this.g=new y,this.h=S}function W(S,z,J,ie){try{var De=z.call(S.g.i,J);if(!(De instanceof Object))throw new TypeError("Iterator result "+De+" is not an object");if(!De.done)return S.g.l=!1,De;var Ee=De.value}catch(Te){return S.g.i=null,E(S.g,Te),q(S)}return S.g.i=null,ie.call(S.g,Ee),q(S)}function q(S){for(;S.g.g;)try{var z=S.h(S.g);if(z)return S.g.l=!1,{value:z.value,done:!1}}catch(J){S.g.h=void 0,E(S.g,J)}if(S.g.l=!1,S.g.j){if(z=S.g.j,S.g.j=null,z.ea)throw z.da;return{value:z.return,done:!0}}return{value:void 0,done:!0}}function re(S){this.next=function(z){return w(S.g),S.g.i?z=W(S,S.g.i.next,z,S.g.s):(S.g.s(z),z=q(S)),z},this.throw=function(z){return w(S.g),S.g.i?z=W(S,S.g.i.throw,z,S.g.s):(E(S.g,z),z=q(S)),z},this.return=function(z){return function(J,ie){w(J.g);var De=J.g.i;return De?W(J,"return"in De?De.return:function(Ee){return{value:Ee,done:!0}},ie,J.g.return):(J.g.return(ie),q(J))}(S,z)},this[Symbol.iterator]=function(){return this}}function pe(S){return function(z){function J(De){return z.next(De)}function ie(De){return z.throw(De)}return new Promise(function(De,Ee){!function Te(Qe){Qe.done?De(Qe.value):Promise.resolve(Qe.value).then(J,ie).then(Te,Ee)}(z.next())})}(new re(new O(S)))}y.prototype.s=function(S){this.h=S},y.prototype.return=function(S){this.j={return:S},this.g=this.u},s("Promise",function(S){function z(Te){this.h=0,this.i=void 0,this.g=[],this.s=!1;var Qe=this.j();try{Te(Qe.resolve,Qe.reject)}catch(Ct){Qe.reject(Ct)}}function J(){this.g=null}function ie(Te){return Te instanceof z?Te:new z(function(Qe){Qe(Te)})}if(S)return S;J.prototype.h=function(Te){if(null==this.g){this.g=[];var Qe=this;this.i(function(){Qe.l()})}this.g.push(Te)};var De=r.setTimeout;J.prototype.i=function(Te){De(Te,0)},J.prototype.l=function(){for(;this.g&&this.g.length;){var Te=this.g;this.g=[];for(var Qe=0;Qe<Te.length;++Qe){var Ct=Te[Qe];Te[Qe]=null;try{Ct()}catch(Bt){this.j(Bt)}}}this.g=null},J.prototype.j=function(Te){this.i(function(){throw Te})},z.prototype.j=function(){function Te(Bt){return function(tn){Ct||(Ct=!0,Bt.call(Qe,tn))}}var Qe=this,Ct=!1;return{resolve:Te(this.D),reject:Te(this.l)}},z.prototype.D=function(Te){if(Te===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(Te instanceof z)this.H(Te);else{e:switch(typeof Te){case"object":var Qe=null!=Te;break e;case"function":Qe=!0;break e;default:Qe=!1}Qe?this.A(Te):this.o(Te)}},z.prototype.A=function(Te){var Qe=void 0;try{Qe=Te.then}catch(Ct){return void this.l(Ct)}"function"==typeof Qe?this.I(Qe,Te):this.o(Te)},z.prototype.l=function(Te){this.u(2,Te)},z.prototype.o=function(Te){this.u(1,Te)},z.prototype.u=function(Te,Qe){if(0!=this.h)throw Error("Cannot settle("+Te+", "+Qe+"): Promise already settled in state"+this.h);this.h=Te,this.i=Qe,2===this.h&&this.G(),this.B()},z.prototype.G=function(){var Te=this;De(function(){if(Te.C()){var Qe=r.console;void 0!==Qe&&Qe.error(Te.i)}},1)},z.prototype.C=function(){if(this.s)return!1;var Te=r.CustomEvent,Qe=r.Event,Ct=r.dispatchEvent;return void 0===Ct||("function"==typeof Te?Te=new Te("unhandledrejection",{cancelable:!0}):"function"==typeof Qe?Te=new Qe("unhandledrejection",{cancelable:!0}):(Te=r.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,Te),Te.promise=this,Te.reason=this.i,Ct(Te))},z.prototype.B=function(){if(null!=this.g){for(var Te=0;Te<this.g.length;++Te)Ee.h(this.g[Te]);this.g=null}};var Ee=new J;return z.prototype.H=function(Te){var Qe=this.j();Te.M(Qe.resolve,Qe.reject)},z.prototype.I=function(Te,Qe){var Ct=this.j();try{Te.call(Qe,Ct.resolve,Ct.reject)}catch(Bt){Ct.reject(Bt)}},z.prototype.then=function(Te,Qe){function Ct($n,an){return"function"==typeof $n?function(Gn){try{Bt($n(Gn))}catch(tr){tn(tr)}}:an}var Bt,tn,Dn=new z(function($n,an){Bt=$n,tn=an});return this.M(Ct(Te,Bt),Ct(Qe,tn)),Dn},z.prototype.catch=function(Te){return this.then(void 0,Te)},z.prototype.M=function(Te,Qe){function Ct(){switch(Bt.h){case 1:Te(Bt.i);break;case 2:Qe(Bt.i);break;default:throw Error("Unexpected state: "+Bt.h)}}var Bt=this;null==this.g?Ee.h(Ct):this.g.push(Ct),this.s=!0},z.resolve=ie,z.reject=function(Te){return new z(function(Qe,Ct){Ct(Te)})},z.race=function(Te){return new z(function(Qe,Ct){for(var Bt=i(Te),tn=Bt.next();!tn.done;tn=Bt.next())ie(tn.value).M(Qe,Ct)})},z.all=function(Te){var Qe=i(Te),Ct=Qe.next();return Ct.done?ie([]):new z(function(Bt,tn){function Dn(Gn){return function(tr){$n[Gn]=tr,0==--an&&Bt($n)}}var $n=[],an=0;do{$n.push(void 0),an++,ie(Ct.value).M(Dn($n.length-1),tn),Ct=Qe.next()}while(!Ct.done)})},z});var Ae="function"==typeof Object.assign?Object.assign:function(S,z){for(var J=1;J<arguments.length;J++){var ie=arguments[J];if(ie)for(var De in ie)Object.prototype.hasOwnProperty.call(ie,De)&&(S[De]=ie[De])}return S};s("Object.assign",function(S){return S||Ae}),s("Object.is",function(S){return S||function(z,J){return z===J?0!==z||1/z==1/J:z!=z&&J!=J}}),s("Array.prototype.includes",function(S){return S||function(z,J){var ie=this;ie instanceof String&&(ie=String(ie));var De=ie.length;for(0>(J=J||0)&&(J=Math.max(J+De,0));J<De;J++){var Ee=ie[J];if(Ee===z||Object.is(Ee,z))return!0}return!1}}),s("String.prototype.includes",function(S){return S||function(z,J){if(null==this)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(z instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return-1!==this.indexOf(z,J||0)}}),s("Array.prototype.keys",function(S){return S||function(){return function(z,J){z instanceof String&&(z+="");var ie=0,De=!1,Ee={next:function(){return!De&&ie<z.length?{value:ie++,done:!1}:(De=!0,{done:!0,value:void 0})}};return Ee[Symbol.iterator]=function(){return Ee},Ee}(this)}});var Be=this||self;function Ke(S,z){S=S.split(".");var J,ie=Be;for((S[0]in ie||void 0===ie.execScript||ie.execScript("var "+S[0]));S.length&&(J=S.shift());)S.length||void 0===z?ie=ie[J]&&ie[J]!==Object.prototype[J]?ie[J]:ie[J]={}:ie[J]=z}function Ge(){throw Error("Invalid UTF8")}function ft(S,z){return z=String.fromCharCode.apply(null,z),null==S?z:S+z}var yt,pt,wt=typeof TextDecoder<"u",vt=typeof TextEncoder<"u",xt={},Et=null;function mt(S){var z;void 0===z&&(z=0),Ot(),z=xt[z];for(var J=Array(Math.floor(S.length/3)),ie=z[64]||"",De=0,Ee=0;De<S.length-2;De+=3){var Te=S[De],Qe=S[De+1],Ct=S[De+2],Bt=z[Te>>2];J[Ee++]=Bt+(Te=z[(3&Te)<<4|Qe>>4])+(Qe=z[(15&Qe)<<2|Ct>>6])+(Ct=z[63&Ct])}switch(Bt=0,Ct=ie,S.length-De){case 2:Ct=z[(15&(Bt=S[De+1]))<<2]||ie;case 1:J[Ee]=z[(S=S[De])>>2]+z[(3&S)<<4|Bt>>4]+Ct+ie}return J.join("")}function _t(S){var z=S.length,J=3*z/4;J%3?J=Math.floor(J):-1!="=.".indexOf(S[z-1])&&(J=-1!="=.".indexOf(S[z-2])?J-2:J-1);var ie=new Uint8Array(J),De=0;return function(Ee,Te){function Qe(an){for(;Ct<Ee.length;){var Gn=Ee.charAt(Ct++),tr=Et[Gn];if(null!=tr)return tr;if(!/^[\s\xa0]*$/.test(Gn))throw Error("Unknown base64 encoding at char: "+Gn)}return an}Ot();for(var Ct=0;;){var Bt=Qe(-1),tn=Qe(0),Dn=Qe(64),$n=Qe(64);if(64===$n&&-1===Bt)break;Te(Bt<<2|tn>>4),64!=Dn&&(Te(tn<<4&240|Dn>>2),64!=$n&&Te(Dn<<6&192|$n))}}(S,function(Ee){ie[De++]=Ee}),De!==J?ie.subarray(0,De):ie}function Ot(){if(!Et){Et={};for(var S="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),z=["+/=","+/","-_=","-_.","-_"],J=0;5>J;J++){var ie=S.concat(z[J].split(""));xt[J]=ie;for(var De=0;De<ie.length;De++){var Ee=ie[De];void 0===Et[Ee]&&(Et[Ee]=De)}}}}var Rt,zt="function"==typeof Uint8Array;function $t(S){return zt&&null!=S&&S instanceof Uint8Array}function jt(S){if(this.L=S,null!==S&&0===S.length)throw Error("ByteString should be constructed with non-empty values")}var Ut="function"==typeof Uint8Array.prototype.slice,Kt=0;function hn(S,z){return Error("Invalid wire type: "+S+" (at position "+z+")")}function bn(){return Error("Failed to read varint, encoding is invalid.")}function En(S,z){z=void 0!==(z=void 0===z?{}:z).v&&z.v,this.h=null,this.g=this.i=this.j=0,this.v=z,S&&jn(this,S)}function jn(S,z){S.h=function(J,ie){if(J.constructor===Uint8Array)return J;if(J.constructor===ArrayBuffer)return new Uint8Array(J);if(J.constructor===Array)return new Uint8Array(J);if(J.constructor===String)return _t(J);if(J.constructor===jt)return!ie&&(ie=J.L)&&ie.constructor===Uint8Array?ie:(ie=null==(ie=J.L)||$t(ie)?ie:"string"==typeof ie?_t(ie):null,(J=J.L=ie)?new Uint8Array(J):Rt||(Rt=new Uint8Array(0)));if(J instanceof Uint8Array)return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, or Array of numbers")}(z,S.v),S.j=0,S.i=S.h.length,S.g=S.j}function In(S){if(S.g>S.i)throw Error("Tried to read past the end of the data "+S.g+" > "+S.i)}function pr(S){var z=S.h,J=z[S.g],ie=127&J;if(128>J)return S.g+=1,In(S),ie;if(ie|=(127&(J=z[S.g+1]))<<7,128>J)return S.g+=2,In(S),ie;if(ie|=(127&(J=z[S.g+2]))<<14,128>J)return S.g+=3,In(S),ie;if(ie|=(127&(J=z[S.g+3]))<<21,128>J)return S.g+=4,In(S),ie;if(J=z[S.g+4],S.g+=5,ie|=(15&J)<<28,128>J)return In(S),ie;if(128<=z[S.g++]&&128<=z[S.g++]&&128<=z[S.g++]&&128<=z[S.g++]&&128<=z[S.g++])throw bn();return In(S),ie}En.prototype.reset=function(){this.g=this.j};var Rr=[];function Or(){this.g=[]}function Er(S,z){for(;127<z;)S.g.push(127&z|128),z>>>=7;S.g.push(z)}function Tr(S){var z={},J=void 0!==z.W&&z.W;this.l={v:void 0!==z.v&&z.v},this.W=J,z=this.l,Rr.length?(J=Rr.pop(),z&&(J.v=z.v),S&&jn(J,S),S=J):S=new En(S,z),this.g=S,this.j=this.g.g,this.h=this.i=-1}function Zr(S){var z=S.g;if(z.g==z.i)return!1;S.j=S.g.g;var J=pr(S.g)>>>0;if(z=J>>>3,!(0<=(J&=7)&&5>=J))throw hn(J,S.j);if(1>z)throw Error("Invalid field number: "+z+" (at position "+S.j+")");return S.i=z,S.h=J,!0}function jr(S){switch(S.h){case 0:if(0!=S.h)jr(S);else e:{for(var z=(S=S.g).g,J=z+10;z<J;)if(!(128&S.h[z++])){S.g=z,In(S);break e}throw bn()}break;case 1:(S=S.g).g+=8,In(S);break;case 2:2!=S.h?jr(S):(z=pr(S.g)>>>0,(S=S.g).g+=z,In(S));break;case 5:(S=S.g).g+=4,In(S);break;case 3:for(z=S.i;;){if(!Zr(S))throw Error("Unmatched start-group tag: stream EOF");if(4==S.h){if(S.i!=z)throw Error("Unmatched end-group tag");break}jr(S)}break;default:throw hn(S.h,S.j)}}Or.prototype.length=function(){return this.g.length},Or.prototype.end=function(){var S=this.g;return this.g=[],S},Tr.prototype.reset=function(){this.g.reset(),this.j=this.g.g,this.h=this.i=-1};var gi=[];function Vs(){this.i=[],this.h=0,this.g=new Or}function Ko(S,z){0!==z.length&&(S.i.push(z),S.h+=z.length)}var so="function"==typeof Symbol&&"symbol"==typeof Symbol()?Symbol(void 0):void 0;function cu(S,z){Object.isFrozen(S)||(so?S[so]|=z:void 0!==S.N?S.N|=z:Object.defineProperties(S,{N:{value:z,configurable:!0,writable:!0,enumerable:!1}}))}function yi(S){var z;return null==(z=so?S[so]:S.N)?0:z}function Xo(S){return cu(S,1),S}function vi(S){return!!Array.isArray(S)&&!!(2&yi(S))}function ca(S){if(!Array.isArray(S))throw Error("cannot mark non-array as immutable");cu(S,2)}function Oa(S){return null!==S&&"object"==typeof S&&!Array.isArray(S)&&S.constructor===Object}var lu=Object.freeze(Xo([]));function Gd(S){if(vi(S.m))throw Error("Cannot mutate an immutable Message")}var Kd,Cg=typeof Symbol<"u"&&void 0!==Symbol.hasInstance;function cl(S){return{value:S,configurable:!1,writable:!1,enumerable:!1}}function Bi(S,z,J){return-1===z?null:z>=S.i?S.g?S.g[z]:void 0:void 0!==J&&J&&S.g&&null!=(J=S.g[z])?J:S.m[z+S.h]}function Rs(S,z,J,ie){ie=void 0!==ie&&ie,Gd(S),z<S.i&&!ie?S.m[z+S.h]=J:(S.g||(S.g=S.m[S.i+S.h]={}))[z]=J}function M_(S,z,J,ie){J=void 0===J||J;var De=Bi(S,z,ie=void 0!==ie&&ie);return null==De&&(De=lu),vi(S.m)?J&&(ca(De),Object.freeze(De)):(De===lu||vi(De))&&Rs(S,z,De=Xo(De.slice()),ie),De}function du(S,z,J){return null==(S=null==(S=Bi(S,z))?S:+S)?void 0===J?0:J:S}function Sg(S,z,J,ie){S.j||(S.j={});var De=vi(S.m),Ee=S.j[J];if(!Ee){ie=M_(S,J,!0,void 0!==ie&&ie),Ee=[],De=De||vi(ie);for(var Te=0;Te<ie.length;Te++)Ee[Te]=new z(ie[Te]),De&&ca(Ee[Te].m);De&&(ca(Ee),Object.freeze(Ee)),S.j[J]=Ee}return Ee}function $_(S,z,J,ie,De){var Ee=void 0!==Ee&&Ee;return Gd(S),Ee=Sg(S,J,z,Ee),J=ie||new J,S=M_(S,z),null!=De?(Ee.splice(De,0,J),S.splice(De,0,J.m)):(Ee.push(J),S.push(J.m)),J}function F_(S,z){return null==(S=Bi(S,z))?0:S}function P_(S,z){return null==(S=Bi(S,z))?"":S}function L_(S){return V_(S,void 0===NZ?kZ:NZ)}function B_(S,z){if(null!=S){if(Array.isArray(S))S=V_(S,z);else if(Oa(S)){var J,ie={};for(J in S)ie[J]=B_(S[J],z);S=ie}else S=z(S);return S}}function V_(S,z){for(var J=S.slice(),ie=0;ie<J.length;ie++)J[ie]=B_(J[ie],z);return Array.isArray(S)&&1&yi(S)&&Xo(J),J}function NZ(S){return S&&"object"==typeof S&&S.toJSON?S.toJSON():(S=function(z){switch(typeof z){case"number":return isFinite(z)?z:String(z);case"object":if(z&&!Array.isArray(z)){if($t(z))return mt(z);if(z instanceof jt){var J=z.L;return J=null==J||"string"==typeof J?J:zt&&J instanceof Uint8Array?mt(J):null,(z.L=J)||""}}}return z}(S),Array.isArray(S)?L_(S):S)}function kZ(S){return $t(S)?new Uint8Array(S):S}function Eg(S,z,J){S||(S=Kd),Kd=null;var ie=this.constructor.h;if(S||(S=ie?[ie]:[]),this.h=(ie?0:-1)-(this.constructor.g||0),this.j=void 0,this.m=S,S=(ie=this.m.length)-1,ie&&Oa(ie=this.m[S])?(this.i=S-this.h,this.g=ie):void 0!==z&&-1<z?(this.i=Math.max(z,S+1-this.h),this.g=void 0):this.i=Number.MAX_VALUE,J)for(z=0;z<J.length;z++)if((S=J[z])<this.i)(ie=this.m[S+=this.h])?Array.isArray(ie)&&Xo(ie):this.m[S]=lu;else{var De=(ie=this.g||(this.g=this.m[this.i+this.h]={}))[S];De?Array.isArray(De)&&Xo(De):ie[S]=lu}}function _g(){Eg.apply(this,arguments)}if(Eg.prototype.toJSON=function(){return L_(this.m)},Eg.prototype.toString=function(){return this.m.toString()},m(_g,Eg),Cg){var U_={};Object.defineProperties(_g,(U_[Symbol.hasInstance]=cl(function(){throw Error("Cannot perform instanceof checks for MutableMessage")}),U_))}function W_(S,z,J){if(J){var ie,De={};for(ie in J){var Ee=J[ie],Te=Ee.ha;Te||(De.F=Ee.la||Ee.fa.P,Ee.aa?(De.U=G_(Ee.aa),Te=function(Qe){return function(Ct,Bt,tn){return Qe.F(Ct,Bt,tn,Qe.U)}}(De)):Ee.ca?(De.T=K_(Ee.X.g,Ee.ca),Te=function(Qe){return function(Ct,Bt,tn){return Qe.F(Ct,Bt,tn,Qe.T)}}(De)):Te=De.F,Ee.ha=Te),Te(z,S,Ee.X),De={F:De.F,U:De.U,T:De.T}}}!function(Qe,Ct){if(Ct=Ct.ba){Ko(Qe,Qe.g.end());for(var Bt=0;Bt<Ct.length;Bt++)Ko(Qe,Ct[Bt])}}(z,S)}var Ig=Symbol();function z_(S,z,J){return S[Ig]||(S[Ig]=function(ie,De){return z(ie,De,J)})}function H_(S){var z=S[Ig];if(!z){var J=Z_(S);S[Ig]=z=function(ie,De){return Q_(ie,De,J)}}return z}function AZ(S){var De,Ee,z=(Ee=(De=S).aa)?H_(Ee):(Ee=De.ka)?z_(De.X.g,Ee,De.ca):void 0,J=S.X,ie=S.fa.O;return z?function(De,Ee){return ie(De,Ee,J,z)}:function(De,Ee){return ie(De,Ee,J)}}function j_(S,z,J,ie,De,Ee){var Te=0;for((S=S()).length&&"number"!=typeof S[0]&&(J(z,S[0]),Te++);Te<S.length;){J=S[Te++];for(var Qe=Te+1;Qe<S.length&&"number"!=typeof S[Qe];)Qe++;var Ct=S[Te++];switch(Qe-=Te){case 0:ie(z,J,Ct);break;case 1:ie(z,J,Ct,S[Te++]);break;case 2:De(z,J,Ct,S[Te++],S[Te++]);break;case 3:Qe=S[Te++];var Bt=S[Te++],tn=S[Te++];Array.isArray(tn)?De(z,J,Ct,Qe,Bt,tn):Ee(z,J,Ct,Qe,Bt,tn);break;case 4:Ee(z,J,Ct,S[Te++],S[Te++],S[Te++],S[Te++]);break;default:throw Error("unexpected number of binary field arguments: "+Qe)}}return z}var Dg=Symbol();function G_(S){var z=S[Dg];if(!z){var J=q_(S);S[Dg]=z=function(ie,De){return J_(ie,De,J)}}return z}function K_(S,z){var J=S[Dg];return J||(S[Dg]=J=function(ie,De){return W_(ie,De,z)}),J}var X_=Symbol();function RZ(S,z){S.push(z)}function OZ(S,z,J){S.push(z,J.P)}function MZ(S,z,J,ie,De){var Ee=G_(De),Te=J.P;S.push(z,function(Qe,Ct,Bt){return Te(Qe,Ct,Bt,ie,Ee)})}function $Z(S,z,J,ie,De,Ee){var Te=K_(ie,Ee),Qe=J.P;S.push(z,function(Ct,Bt,tn){return Qe(Ct,Bt,tn,ie,Te)})}function q_(S){return S[X_]||j_(S,S[X_]=[],RZ,OZ,MZ,$Z)}var Y_=Symbol();function FZ(S,z){S[0]=z}function PZ(S,z,J,ie){var De=J.O;S[z]=ie?function(Ee,Te,Qe){return De(Ee,Te,Qe,ie)}:De}function LZ(S,z,J,ie,De,Ee){var Te=J.O,Qe=H_(De);S[z]=function(Ct,Bt,tn){return Te(Ct,Bt,tn,ie,Qe,Ee)}}function BZ(S,z,J,ie,De,Ee,Te){var Qe=J.O,Ct=z_(ie,De,Ee);S[z]=function(Bt,tn,Dn){return Qe(Bt,tn,Dn,ie,Ct,Te)}}function Z_(S){return S[Y_]||j_(S,S[Y_]={},FZ,PZ,LZ,BZ)}function Q_(S,z,J){for(;Zr(z)&&4!=z.h;){var ie=z.i,De=J[ie];if(!De){var Ee=J[0];Ee&&(Ee=Ee[ie])&&(De=J[ie]=AZ(Ee))}if(!(De&&De(z,S,ie)||(De=z,ie=S,Ee=De.j,jr(De),De.W))){var Te=De.g.h;De=Ee===(De=De.g.g)?Rt||(Rt=new Uint8Array(0)):Ut?Te.slice(Ee,De):new Uint8Array(Te.subarray(Ee,De)),(Ee=ie.ba)?Ee.push(De):ie.ba=[De]}}return S}function K3(S,z,J){if(gi.length){var ie=gi.pop();S&&(jn(ie.g,S),ie.i=-1,ie.h=-1),S=ie}else S=new Tr(S);try{return Q_(new z,S,Z_(J))}finally{(z=S.g).h=null,z.j=0,z.i=0,z.g=0,z.v=!1,S.i=-1,S.h=-1,100>gi.length&&gi.push(S)}}function J_(S,z,J){for(var ie=J.length,De=ie%2==1,Ee=De?1:0;Ee<ie;Ee+=2)(0,J[Ee+1])(z,S,J[Ee]);W_(S,z,De?J[0]:void 0)}function X3(S,z){var J=new Vs;J_(S,J,q_(z)),Ko(J,J.g.end()),S=new Uint8Array(J.h);for(var ie=(z=J.i).length,De=0,Ee=0;Ee<ie;Ee++){var Te=z[Ee];S.set(Te,De),De+=Te.length}return J.i=[S],S}function $f(S,z){return{O:S,P:z}}var Ma=$f(function(S,z,J){if(5!==S.h)return!1;var ie=(S=S.g).h[S.g],De=S.h[S.g+1],Ee=S.h[S.g+2],Te=S.h[S.g+3];return S.g+=4,In(S),S=2*((De=(ie<<0|De<<8|Ee<<16|Te<<24)>>>0)>>31)+1,ie=De>>>23&255,De&=8388607,Rs(z,J,255==ie?De?NaN:1/0*S:0==ie?S*Math.pow(2,-149)*De:S*Math.pow(2,ie-150)*(De+Math.pow(2,23))),!0},function(S,z,J){if(null!=(z=Bi(z,J))){Er(S.g,8*J+5),S=S.g;var ie=z;0===(ie=(J=0>ie?1:0)?-ie:ie)?Kt=0<1/ie?0:2147483648:isNaN(ie)?Kt=2147483647:34028234663852886e22<ie?Kt=(J<<31|2139095040)>>>0:11754943508222875e-54>ie?(ie=Math.round(ie/Math.pow(2,-149)),Kt=(J<<31|ie)>>>0):(z=Math.floor(Math.log(ie)/Math.LN2),ie*=Math.pow(2,-z),16777216<=(ie=Math.round(8388608*ie))&&++z,Kt=(J<<31|z+127<<23|8388607&ie)>>>0),S.g.push((J=Kt)>>>0&255),S.g.push(J>>>8&255),S.g.push(J>>>16&255),S.g.push(J>>>24&255)}}),VZ=$f(function(S,z,J){if(0!==S.h)return!1;for(var ie=S.g,De=128,Ee=0,Te=S=0;4>Te&&128<=De;Te++)De=ie.h[ie.g++],In(ie),Ee|=(127&De)<<7*Te;if(128<=De&&(De=ie.h[ie.g++],In(ie),Ee|=(127&De)<<28,S|=(127&De)>>4),128<=De)for(Te=0;5>Te&&128<=De;Te++)De=ie.h[ie.g++],In(ie),S|=(127&De)<<7*Te+3;if(!(128>De))throw bn();return ie=Ee>>>0,(S=2147483648&(De=S>>>0))&&(De=~De>>>0,0==(ie=1+~ie>>>0)&&(De=De+1>>>0)),ie=4294967296*De+(ie>>>0),Rs(z,J,S?-ie:ie),!0},function(S,z,J){if(null!=(z=Bi(z,J))&&null!=z){Er(S.g,8*J),S=S.g;var ie=z;for(J=0>ie,z=(ie=Math.abs(ie))>>>0,ie=Math.floor((ie-z)/4294967296),ie>>>=0,J&&(ie=~ie>>>0,4294967295<(z=1+(~z>>>0))&&(z=0,4294967295<++ie&&(ie=0))),J=Kt=z,z=ie;0<z||127<J;)S.g.push(127&J|128),J=(J>>>7|z<<25)>>>0,z>>>=7;S.g.push(J)}}),UZ=$f(function(S,z,J){return 0===S.h&&(Rs(z,J,pr(S.g)),!0)},function(S,z,J){if(null!=(z=Bi(z,J))&&null!=z)if(Er(S.g,8*J),S=S.g,0<=(J=z))Er(S,J);else{for(z=0;9>z;z++)S.g.push(127&J|128),J>>=7;S.g.push(1)}}),eI=$f(function(S,z,J){if(2!==S.h)return!1;var ie,De=pr(S.g)>>>0,Ee=(S=S.g).g;if(S.g+=De,In(S),S=S.h,wt)(ie=yt)||(ie=yt=new TextDecoder("utf-8",{fatal:!0})),ie=ie.decode(S.subarray(Ee,Ee+De));else{De=Ee+De;for(var Te,Qe,Ct,Bt=[],tn=null;Ee<De;)128>(Te=S[Ee++])?Bt.push(Te):224>Te?Ee>=De?Ge():(Qe=S[Ee++],194>Te||128!=(192&Qe)?(Ee--,Ge()):Bt.push((31&Te)<<6|63&Qe)):240>Te?Ee>=De-1?Ge():128!=(192&(Qe=S[Ee++]))||224===Te&&160>Qe||237===Te&&160<=Qe||128!=(192&(ie=S[Ee++]))?(Ee--,Ge()):Bt.push((15&Te)<<12|(63&Qe)<<6|63&ie):244>=Te?Ee>=De-2?Ge():128!=(192&(Qe=S[Ee++]))||Qe-144+(Te<<28)>>30||128!=(192&(ie=S[Ee++]))||128!=(192&(Ct=S[Ee++]))?(Ee--,Ge()):(Te=(7&Te)<<18|(63&Qe)<<12|(63&ie)<<6|63&Ct,Bt.push(55296+((Te-=65536)>>10&1023),56320+(1023&Te))):Ge(),8192<=Bt.length&&(tn=ft(tn,Bt),Bt.length=0);ie=ft(tn,Bt)}return Rs(z,J,ie),!0},function(S,z,J){if(null!=(z=Bi(z,J))){var ie=!1;if(ie=void 0!==ie&&ie,vt){if(ie&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(z))throw Error("Found an unpaired surrogate");z=(pt||(pt=new TextEncoder)).encode(z)}else{for(var De=0,Ee=new Uint8Array(3*z.length),Te=0;Te<z.length;Te++){var Qe=z.charCodeAt(Te);if(128>Qe)Ee[De++]=Qe;else{if(2048>Qe)Ee[De++]=Qe>>6|192;else{if(55296<=Qe&&57343>=Qe){if(56319>=Qe&&Te<z.length){var Ct=z.charCodeAt(++Te);if(56320<=Ct&&57343>=Ct){Ee[De++]=(Qe=1024*(Qe-55296)+Ct-56320+65536)>>18|240,Ee[De++]=Qe>>12&63|128,Ee[De++]=Qe>>6&63|128,Ee[De++]=63&Qe|128;continue}Te--}if(ie)throw Error("Found an unpaired surrogate");Qe=65533}Ee[De++]=Qe>>12|224,Ee[De++]=Qe>>6&63|128}Ee[De++]=63&Qe|128}}z=Ee.subarray(0,De)}Er(S.g,8*J+2),Er(S.g,z.length),Ko(S,S.g.end()),Ko(S,z)}}),tI=$f(function(S,z,J,ie,De){if(2!==S.h)return!1;z=$_(z,J,ie),J=S.g.i,ie=pr(S.g)>>>0;var Ee=S.g.g+ie,Te=Ee-J;if(0>=Te&&(S.g.i=Ee,De(z,S),Te=Ee-S.g.g),Te)throw Error("Message parsing ended unexpectedly. Expected to read "+ie+" bytes, instead read "+(ie-Te)+" bytes, either the data ended unexpectedly or the message misreported its own length");return S.g.g=Ee,S.g.i=J,!0},function(S,z,J,ie,De){if(null!=(z=Sg(z,ie,J)))for(ie=0;ie<z.length;ie++){var Ee=S;Er(Ee.g,8*J+2);var Te=Ee.g.end();Ko(Ee,Te),Te.push(Ee.h),Ee=Te,De(z[ie],S),Te=S;var Qe=Ee.pop();for(Qe=Te.h+Te.g.length()-Qe;127<Qe;)Ee.push(127&Qe|128),Qe>>>=7,Te.h++;Ee.push(Qe),Te.h++}});function la(){_g.apply(this,arguments)}if(m(la,_g),Cg){var nI={};Object.defineProperties(la,(nI[Symbol.hasInstance]=cl(Object[Symbol.hasInstance]),nI))}function Ff(S){la.call(this,S)}function rI(){return[1,UZ,2,Ma,3,eI,4,eI]}function q3(S){la.call(this,S,-1,zZ)}function WZ(){return[1,tI,Ff,rI]}m(Ff,la),m(q3,la),q3.prototype.addClassification=function(S,z){return $_(this,1,Ff,S,z),this};var zZ=[1];function Tg(S){la.call(this,S)}function sI(){return[1,Ma,2,Ma,3,Ma,4,Ma,5,Ma]}function oI(S){la.call(this,S,-1,jZ)}function HZ(){return[1,tI,Tg,sI]}m(Tg,la),m(oI,la);var jZ=[1];function Y3(S){la.call(this,S)}function iI(){return[1,Ma,2,Ma,3,Ma,4,Ma,5,Ma,6,VZ]}m(Y3,la);var aI=[[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]],uI=[[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]],cI=[[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]],lI=[[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]],dI=[[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]],hI=[[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]],GZ=[].concat(a(aI),a(uI),a(cI),a(lI),a(dI),a(hI));function fI(S,z,J){if(J=S.createShader(0===J?S.VERTEX_SHADER:S.FRAGMENT_SHADER),S.shaderSource(J,z),S.compileShader(J),!S.getShaderParameter(J,S.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+S.getShaderInfoLog(J));return J}function KZ(S){return Sg(S,Ff,1).map(function(z){return{index:F_(z,1),ga:du(z,2),label:null!=Bi(z,3)?P_(z,3):void 0,displayName:null!=Bi(z,4)?P_(z,4):void 0}})}function XZ(S){return{x:du(S,1),y:du(S,2),z:du(S,3),visibility:null!=Bi(S,4)?du(S,4):void 0}}function Z3(S,z){this.h=S,this.g=z,this.l=0}function pI(S,z,J){return function(ie,De){var Ee=ie.g;if(void 0===ie.o){var Te=fI(Ee,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),Qe=fI(Ee,"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),Ct=Ee.createProgram();if(Ee.attachShader(Ct,Te),Ee.attachShader(Ct,Qe),Ee.linkProgram(Ct),!Ee.getProgramParameter(Ct,Ee.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+Ee.getProgramInfoLog(Ct));Te=ie.o=Ct,Ee.useProgram(Te),Qe=Ee.getUniformLocation(Te,"sampler0"),ie.j={K:Ee.getAttribLocation(Te,"aVertex"),J:Ee.getAttribLocation(Te,"aTex"),ma:Qe},ie.u=Ee.createBuffer(),Ee.bindBuffer(Ee.ARRAY_BUFFER,ie.u),Ee.enableVertexAttribArray(ie.j.K),Ee.vertexAttribPointer(ie.j.K,2,Ee.FLOAT,!1,0,0),Ee.bufferData(Ee.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),Ee.STATIC_DRAW),Ee.bindBuffer(Ee.ARRAY_BUFFER,null),ie.s=Ee.createBuffer(),Ee.bindBuffer(Ee.ARRAY_BUFFER,ie.s),Ee.enableVertexAttribArray(ie.j.J),Ee.vertexAttribPointer(ie.j.J,2,Ee.FLOAT,!1,0,0),Ee.bufferData(Ee.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),Ee.STATIC_DRAW),Ee.bindBuffer(Ee.ARRAY_BUFFER,null),Ee.uniform1i(Qe,0)}Te=ie.j,Ee.useProgram(ie.o),Ee.canvas.width=De.width,Ee.canvas.height=De.height,Ee.viewport(0,0,De.width,De.height),Ee.activeTexture(Ee.TEXTURE0),ie.h.bindTexture2d(De.glName),Ee.enableVertexAttribArray(Te.K),Ee.bindBuffer(Ee.ARRAY_BUFFER,ie.u),Ee.vertexAttribPointer(Te.K,2,Ee.FLOAT,!1,0,0),Ee.enableVertexAttribArray(Te.J),Ee.bindBuffer(Ee.ARRAY_BUFFER,ie.s),Ee.vertexAttribPointer(Te.J,2,Ee.FLOAT,!1,0,0),Ee.bindFramebuffer(Ee.DRAW_FRAMEBUFFER?Ee.DRAW_FRAMEBUFFER:Ee.FRAMEBUFFER,null),Ee.clearColor(0,0,0,0),Ee.clear(Ee.COLOR_BUFFER_BIT),Ee.colorMask(!0,!0,!0,!0),Ee.drawArrays(Ee.TRIANGLE_FAN,0,4),Ee.disableVertexAttribArray(Te.K),Ee.disableVertexAttribArray(Te.J),Ee.bindBuffer(Ee.ARRAY_BUFFER,null),ie.h.bindTexture2d(0)}(S,z),"function"==typeof S.g.canvas.transferToImageBitmap?Promise.resolve(S.g.canvas.transferToImageBitmap()):J?Promise.resolve(S.g.canvas):"function"==typeof createImageBitmap?createImageBitmap(S.g.canvas):(void 0===S.i&&(S.i=document.createElement("canvas")),new Promise(function(ie){S.i.height=S.g.canvas.height,S.i.width=S.g.canvas.width,S.i.getContext("2d",{}).drawImage(S.g.canvas,0,0,S.g.canvas.width,S.g.canvas.height),ie(S.i)}))}function qZ(S){this.g=S}var YZ=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function ZZ(S,z){return z+S}function mI(S,z){window[S]=z}function Q3(S){if(this.g=S,this.listeners={},this.j={},this.H={},this.o={},this.u={},this.I=this.s=this.Z=!0,this.D=Promise.resolve(),this.Y="",this.C={},this.locateFile=S&&S.locateFile||ZZ,"object"==typeof window)var z=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if(typeof location>"u")throw Error("solutions can only be loaded on a web page or in a web worker");z=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.$=z,S.options)for(var J=(z=i(Object.keys(S.options))).next();!J.done;J=z.next()){var ie=S.options[J=J.value].default;void 0!==ie&&(this.j[J]="function"==typeof ie?ie():ie)}}function Ng(S,z){var J,ie;return pe(function(De){return z in S.H?De.return(S.H[z]):(J=S.locateFile(z,""),ie=fetch(J).then(function(Ee){return Ee.arrayBuffer()}),S.H[z]=ie,De.return(ie))})}function eQ(S,z){for(var J=z.name||"$",ie=[].concat(a(z.wants)),De=new S.h.StringList,Ee=i(z.wants),Te=Ee.next();!Te.done;Te=Ee.next())De.push_back(Te.value);Ee=S.h.PacketListener.implement({onResults:function(Qe){for(var Ct={},Bt=0;Bt<z.wants.length;++Bt)Ct[ie[Bt]]=Qe.get(Bt);var tn=S.listeners[J];tn&&(S.D=function JZ(S,z,J){var ie,De,Ee,Te,Ct,Bt,tn,Dn,$n,an,tr,Vr;return pe(function(Qr){switch(Qr.g){case 1:if(!J)return Qr.return(z);for(ie={},De=0,Ee=i(Object.keys(J)),Te=Ee.next();!Te.done;Te=Ee.next())"string"!=typeof(Ct=J[Te.value])&&"texture"===Ct.type&&void 0!==z[Ct.stream]&&++De;1<De&&(S.I=!1),Bt=i(Object.keys(J)),Te=Bt.next();case 2:if(Te.done){Qr.g=4;break}if("string"==typeof(Dn=J[tn=Te.value]))return tr=ie,Vr=tn,D(Qr,(ll=S,yI=tn,Xd=z[Dn],pe(function(J3){return"number"==typeof Xd||Xd instanceof Uint8Array||Xd instanceof ll.h.Uint8BlobList?J3.return(Xd):Xd instanceof ll.h.Texture2dDataOut?((kg=ll.u[yI])||(kg=new Z3(ll.h,ll.G),ll.u[yI]=kg),J3.return(pI(kg,Xd,ll.I))):J3.return(void 0)})),14);if($n=z[Dn.stream],"detection_list"===Dn.type){if($n){for(var qo=$n.getRectList(),da=$n.getLandmarksList(),xi=$n.getClassificationsList(),Nr=[],mo=0;mo<qo.size();++mo){var bc=K3(qo.get(mo),Y3,iI);bc={boundingBox:{xCenter:du(bc,1),yCenter:du(bc,2),height:du(bc,3),width:du(bc,4),rotation:du(bc,5,0),rectId:F_(bc,6)},landmarks:Sg(K3(da.get(mo),oI,HZ),Tg,1).map(XZ),V:KZ(K3(xi.get(mo),q3,WZ))},Nr.push(bc)}qo=Nr}else qo=[];ie[tn]=qo,Qr.g=7;break}if("proto_list"===Dn.type){if($n){for(qo=Array($n.size()),da=0;da<$n.size();da++)qo[da]=$n.get(da);$n.delete()}else qo=[];ie[tn]=qo,Qr.g=7;break}if(void 0===$n){Qr.g=3;break}if("float_list"===Dn.type){ie[tn]=$n,Qr.g=7;break}if("proto"===Dn.type){ie[tn]=$n,Qr.g=7;break}if("texture"!==Dn.type)throw Error("Unknown output config type: '"+Dn.type+"'");return(an=S.u[tn])||(an=new Z3(S.h,S.G),S.u[tn]=an),D(Qr,pI(an,$n,S.I),13);case 13:ie[tn]=Qr.h;case 7:Dn.transform&&ie[tn]&&(ie[tn]=Dn.transform(ie[tn])),Qr.g=3;break;case 14:tr[Vr]=Qr.h;case 3:Te=Bt.next(),Qr.g=2;break;case 4:return Qr.return(ie)}var ll,yI,Xd,kg})}(S,Ct,z.outs).then(function(Dn){Dn=tn(Dn);for(var $n=0;$n<z.wants.length;++$n){var an=Ct[ie[$n]];"object"==typeof an&&an.hasOwnProperty&&an.hasOwnProperty("delete")&&an.delete()}Dn&&(S.D=Dn)}))}}),S.i.attachMultiListener(De,Ee),De.delete()}function gI(S){var z=this,J={url:"face_detection_short.binarypb"},ie={type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}};this.g=new Q3({locateFile:(S=S||{}).locateFile,files:[{data:!0,url:"face_detection_short.binarypb"},{data:!0,url:"face_detection_short_range.tflite"},{simd:!0,url:"face_detection_solution_simd_wasm_bin.js"},{simd:!1,url:"face_detection_solution_wasm_bin.js"}],graph:J,listeners:[{wants:["detections","image_transformed"],outs:{image:"image_transformed",detections:{type:"detection_list",stream:"detections"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"object"==typeof window&&void 0!==window.navigator&&("iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document)},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},model:{type:0,onChange:function(De){var Ee,Te,Qe,Ct;return pe(function(tn){switch(tn.g){case 1:Ee=i("short"===De?["face_detection_short_range.tflite"]:["face_detection_full_range_sparse.tflite"]),Te=Ee.next();case 2:if(Te.done){tn.g=4;break}return Ct="third_party/mediapipe/modules/face_detection/"+(Qe=Te.value),D(tn,Ng(z.g,Qe),5);case 5:z.g.overrideFile(Ct,tn.h),Te=Ee.next(),tn.g=2;break;case 4:return J.url="short"===De?"face_detection_short.binarypb":"face_detection_full.binarypb",ie.graphOptionXref.calculatorName="short"===De?"facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator":"facedetectionfullrangegpu__facedetectionfullrangecommon__TensorsToDetectionsCalculator",tn.return(!0)}})}},minDetectionConfidence:ie}})}(t=Q3.prototype).close=function(){return this.i&&this.i.delete(),Promise.resolve()},t.reset=function(){var S=this;return pe(function(z){S.i&&(S.i.reset(),S.o={},S.u={}),z.g=0})},t.setOptions=function(S,z){var J=this;if(z=z||this.g.options){for(var ie=[],De=[],Ee={},Te=i(Object.keys(S)),Qe=Te.next();!Qe.done;Ee={R:Ee.R,S:Ee.S},Qe=Te.next()){var Ct=Qe.value;Ct in this.j&&this.j[Ct]===S[Ct]||(this.j[Ct]=S[Ct],void 0!==(Qe=z[Ct])&&(Qe.onChange&&(Ee.R=Qe.onChange,Ee.S=S[Ct],ie.push(function(Bt){return function(){return pe(function(tn){if(1==tn.g)return D(tn,Bt.R(Bt.S),2);!0===tn.h&&(J.s=!0),tn.g=0})}}(Ee))),Qe.graphOptionXref&&(Ct={valueNumber:1===Qe.type?S[Ct]:0,valueBoolean:0===Qe.type&&S[Ct],valueString:2===Qe.type?S[Ct]:""},Qe=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),Qe.graphOptionXref),Ct),De.push(Qe))))}0===ie.length&&0===De.length||(this.s=!0,this.B=(void 0===this.B?[]:this.B).concat(De),this.A=(void 0===this.A?[]:this.A).concat(ie))}},t.initialize=function(){var S=this;return pe(function(z){return 1==z.g?D(z,function QZ(S){var z,J,ie,De,Ee,Te,Qe,Ct,Bt,tn,Dn;return pe(function($n){switch($n.g){case 1:return S.Z?(z=void 0===S.g.files?[]:"function"==typeof S.g.files?S.g.files(S.j):S.g.files,D($n,pe(function(an){switch(an.g){case 1:return an.o=2,D(an,WebAssembly.instantiate(YZ),4);case 4:an.g=3,an.o=0;break;case 2:return an.o=0,an.j=null,an.return(!1);case 3:return an.return(!0)}}),2)):$n.return();case 2:if(J=$n.h,"object"==typeof window)return mI("createMediapipeSolutionsWasm",{locateFile:S.locateFile}),mI("createMediapipeSolutionsPackedAssets",{locateFile:S.locateFile}),Te=z.filter(function(an){return void 0!==an.data}),Qe=z.filter(function(an){return void 0===an.data}),Ct=Promise.all(Te.map(function(an){var Gn=Ng(S,an.url);if(void 0!==an.path){var tr=an.path;Gn=Gn.then(function(Vr){return S.overrideFile(tr,Vr),Promise.resolve(Vr)})}return Gn})),Bt=Promise.all(Qe.map(function(an){return void 0===an.simd||an.simd&&J||!an.simd&&!J?(Gn=S.locateFile(an.url,S.$),(tr=document.createElement("script")).setAttribute("src",Gn),tr.setAttribute("crossorigin","anonymous"),new Promise(function(Vr){tr.addEventListener("load",function(){Vr()},!1),tr.addEventListener("error",function(){Vr()},!1),document.body.appendChild(tr)})):Promise.resolve();var Gn,tr})).then(function(){var an,Gn,tr;return pe(function(Vr){if(1==Vr.g)return an=window.createMediapipeSolutionsWasm,Gn=window.createMediapipeSolutionsPackedAssets,tr=S,D(Vr,an(Gn),2);tr.h=Vr.h,Vr.g=0})}),tn=pe(function(an){return S.g.graph&&S.g.graph.url?an=D(an,Ng(S,S.g.graph.url),0):(an.g=0,an=void 0),an}),D($n,Promise.all([Bt,Ct,tn]),7);if("function"!=typeof importScripts)throw Error("solutions can only be loaded on a web page or in a web worker");return ie=z.filter(function(an){return void 0===an.simd||an.simd&&J||!an.simd&&!J}).map(function(an){return S.locateFile(an.url,S.$)}),importScripts.apply(null,a(ie)),De=S,D($n,createMediapipeSolutionsWasm(Module),6);case 6:De.h=$n.h,S.l=new OffscreenCanvas(1,1),S.h.canvas=S.l,Ee=S.h.GL.createContext(S.l,{antialias:!1,alpha:!1,ja:typeof WebGL2RenderingContext<"u"?2:1}),S.h.GL.makeContextCurrent(Ee),$n.g=4;break;case 7:if(S.l=document.createElement("canvas"),!(Dn=S.l.getContext("webgl2",{}))&&!(Dn=S.l.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),$n.return();S.G=Dn,S.h.canvas=S.l,S.h.createContext(S.l,!0,!0,{});case 4:S.i=new S.h.SolutionWasm,S.Z=!1,$n.g=0}})}(S),2):3!=z.g?D(z,(J=S,pe(function(Dn){if(1==Dn.g)return J.g.graph&&J.g.graph.url&&J.Y===J.g.graph.url?Dn.return():(J.s=!0,J.g.graph&&J.g.graph.url?(J.Y=J.g.graph.url,D(Dn,Ng(J,J.g.graph.url),3)):void(Dn.g=2));for(2!=Dn.g&&J.i.loadGraph(Dn.h),De=i(Object.keys(J.C)),Ee=De.next();!Ee.done;Ee=De.next())J.i.overrideFile(Te=Ee.value,J.C[Te]);if(J.C={},J.g.listeners)for(Qe=i(J.g.listeners),Ct=Qe.next();!Ct.done;Ct=Qe.next())eQ(J,Ct.value);tn=J.j,J.j={},J.setOptions(tn),Dn.g=0})),3):D(z,function(J){var ie,De,Ee,Te,Qe;return pe(function(Bt){switch(Bt.g){case 1:if(!J.s)return Bt.return();if(!J.A){Bt.g=2;break}ie=i(J.A),De=ie.next();case 3:if(De.done){Bt.g=5;break}return D(Bt,(0,De.value)(),4);case 4:De=ie.next(),Bt.g=3;break;case 5:J.A=void 0;case 2:if(J.B){for(Ee=new J.h.GraphOptionChangeRequestList,Te=i(J.B),Qe=Te.next();!Qe.done;Qe=Te.next())Ee.push_back(Qe.value);J.i.changeOptions(Ee),Ee.delete(),J.B=void 0}J.s=!1,Bt.g=0}})}(S),0);var J,De,Ee,Te,Qe,Ct,tn})},t.overrideFile=function(S,z){this.i?this.i.overrideFile(S,z):this.C[S]=z},t.clearOverriddenFiles=function(){this.C={},this.i&&this.i.clearOverriddenFiles()},t.send=function(S,z){var J,ie,De,Ee,Te,Qe,Ct,Bt,tn,Dn=this;return pe(function($n){switch($n.g){case 1:return Dn.g.inputs?(J=1e3*(z??performance.now()),D($n,Dn.D,2)):$n.return();case 2:return D($n,Dn.initialize(),3);case 3:for(ie=new Dn.h.PacketDataList,De=i(Object.keys(S)),Ee=De.next();!Ee.done;Ee=De.next())if(Qe=Dn.g.inputs[Te=Ee.value]){e:{var an=S[Te];switch(Qe.type){case"video":var Gn=Dn.o[Qe.stream];if(Gn||(Gn=new Z3(Dn.h,Dn.G),Dn.o[Qe.stream]=Gn),0===Gn.l&&(Gn.l=Gn.h.createTexture()),typeof HTMLVideoElement<"u"&&an instanceof HTMLVideoElement)var tr=an.videoWidth,Vr=an.videoHeight;else typeof HTMLImageElement<"u"&&an instanceof HTMLImageElement?(tr=an.naturalWidth,Vr=an.naturalHeight):(tr=an.width,Vr=an.height);Vr={glName:Gn.l,width:tr,height:Vr},(tr=Gn.g).canvas.width=Vr.width,tr.canvas.height=Vr.height,tr.activeTexture(tr.TEXTURE0),Gn.h.bindTexture2d(Gn.l),tr.texImage2D(tr.TEXTURE_2D,0,tr.RGBA,tr.RGBA,tr.UNSIGNED_BYTE,an),Gn.h.bindTexture2d(0),Gn=Vr;break e;case"detections":for((Gn=Dn.o[Qe.stream])||(Gn=new qZ(Dn.h),Dn.o[Qe.stream]=Gn),Gn.data||(Gn.data=new Gn.g.DetectionListData),Gn.data.reset(an.length),Vr=0;Vr<an.length;++Vr){var Qr=Gn.data,qo=Qr.setBoundingBox,da=Vr,xi=(tr=an[Vr]).boundingBox,Nr=new Y3;if(Rs(Nr,1,xi.xCenter),Rs(Nr,2,xi.yCenter),Rs(Nr,3,xi.height),Rs(Nr,4,xi.width),Rs(Nr,5,xi.rotation),Rs(Nr,6,xi.rectId),xi=X3(Nr,iI),qo.call(Qr,da,xi),tr.landmarks)for(Qr=0;Qr<tr.landmarks.length;++Qr){var mo=!!(Nr=tr.landmarks[Qr]).visibility;da=(qo=Gn.data).addNormalizedLandmark,xi=Vr,Nr=Object.assign(Object.assign({},Nr),{visibility:mo?Nr.visibility:0}),Rs(mo=new Tg,1,Nr.x),Rs(mo,2,Nr.y),Rs(mo,3,Nr.z),Nr.visibility&&Rs(mo,4,Nr.visibility),Nr=X3(mo,sI),da.call(qo,xi,Nr)}if(tr.V)for(Qr=0;Qr<tr.V.length;++Qr)da=(qo=Gn.data).addClassification,xi=Vr,Nr=tr.V[Qr],Rs(mo=new Ff,2,Nr.ga),Nr.index&&Rs(mo,1,Nr.index),Nr.label&&Rs(mo,3,Nr.label),Nr.displayName&&Rs(mo,4,Nr.displayName),Nr=X3(mo,rI),da.call(qo,xi,Nr)}Gn=Gn.data;break e;default:Gn={}}}switch(Ct=Gn,Bt=Qe.stream,Qe.type){case"video":ie.pushTexture2d(Object.assign(Object.assign({},Ct),{stream:Bt,timestamp:J}));break;case"detections":(tn=Ct).stream=Bt,tn.timestamp=J,ie.pushDetectionList(tn);break;default:throw Error("Unknown input config type: '"+Qe.type+"'")}}return Dn.i.send(ie),D($n,Dn.D,4);case 4:ie.delete(),$n.g=0}})},t.onResults=function(S,z){this.listeners[z||"$"]=S},Ke("Solution",Q3),Ke("OptionType",{BOOL:0,NUMBER:1,ia:2,0:"BOOL",1:"NUMBER",2:"STRING"}),(t=gI.prototype).close=function(){return this.g.close(),Promise.resolve()},t.onResults=function(S){this.g.onResults(S)},t.initialize=function(){var S=this;return pe(function(z){return D(z,S.g.initialize(),0)})},t.reset=function(){this.g.reset()},t.send=function(S){var z=this;return pe(function(J){return D(J,z.g.send(S),0)})},t.setOptions=function(S){this.g.setOptions(S)},Ke("FaceDetection",gI),Ke("FACEDETECTION_LIPS",aI),Ke("FACEDETECTION_LEFT_EYE",uI),Ke("FACEDETECTION_LEFT_EYEBROW",cI),Ke("FACEDETECTION_RIGHT_EYE",lI),Ke("FACEDETECTION_RIGHT_EYEBROW",dI),Ke("FACEDETECTION_FACE_OVAL",hI),Ke("FACEDETECTION_CONTOURS",GZ),Ke("FACEDETECTION_TESSELATION",[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]]),Ke("VERSION","0.4.1646425229")}).call(d3);var mc=function(){return mc=Object.assign||function(t){for(var n,e=1,r=arguments.length;e<r;e++)for(var s in n=arguments[e])Object.prototype.hasOwnProperty.call(n,s)&&(t[s]=n[s]);return t},mc.apply(this,arguments)};function Vu(t,n,e,r){return new(e||(e=Promise))(function(s,o){function i(c){try{u(r.next(c))}catch(l){o(l)}}function a(c){try{u(r.throw(c))}catch(l){o(l)}}function u(c){var l;c.done?s(c.value):(l=c.value,l instanceof e?l:new e(function(h){h(l)})).then(i,a)}u((r=r.apply(t,n||[])).next())})}function Uu(t,n){var e,r,s,o,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(u){return function(c){return function(l){if(e)throw new TypeError("Generator is already executing.");for(;i;)try{if(e=1,r&&(s=2&l[0]?r.return:l[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,l[1])).done)return s;switch(r=0,s&&(l=[2&l[0],s.value]),l[0]){case 0:case 1:s=l;break;case 4:return i.label++,{value:l[1],done:!1};case 5:i.label++,r=l[1],l=[0];continue;case 7:l=i.ops.pop(),i.trys.pop();continue;default:if(!((s=(s=i.trys).length>0&&s[s.length-1])||6!==l[0]&&2!==l[0])){i=0;continue}if(3===l[0]&&(!s||l[1]>s[0]&&l[1]<s[3])){i.label=l[1];break}if(6===l[0]&&i.label<s[1]){i.label=s[1],s=l;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(l);break}s[2]&&i.ops.pop(),i.trys.pop();continue}l=n.call(t,i)}catch(h){l=[6,h],r=0}finally{e=s=0}if(5&l[0])throw l[1];return{value:l[0]?l[1]:void 0,done:!0}}([u,c])}}}var BC=["rightEye","leftEye","noseTip","mouthCenter","rightEarTragion","leftEarTragion"],h3={modelType:"short",runtime:"mediapipe",maxFaces:1},DM=function(){function t(n){var e=this;this.width=0,this.height=0,this.selfieMode=!1,this.faceDetectorSolution=new IM.FaceDetection({locateFile:function(r,s){return n.solutionPath?n.solutionPath.replace(/\/+$/,"")+"/"+r:s+"/"+r}}),this.faceDetectorSolution.setOptions({selfieMode:this.selfieMode,model:n.modelType}),this.faceDetectorSolution.onResults(function(r){if(e.height=r.image.height,e.width=r.image.width,e.faces=[],null!==r.detections)for(var s=0,o=r.detections;s<o.length;s++){var i=o[s];e.faces.push(e.normalizedToAbsolute(i.landmarks,{xMin:u=(a=i.boundingBox).xCenter-a.width/2,xMax:u+a.width,yMin:c=a.yCenter-a.height/2,yMax:c+a.height,width:a.width,height:a.height}))}var a,u,c})}return t.prototype.normalizedToAbsolute=function(n,e){var r=this;return{keypoints:n.map(function(s,o){return{x:s.x*r.width,y:s.y*r.height,name:BC[o]}}),box:{xMin:e.xMin*this.width,yMin:e.yMin*this.height,xMax:e.xMax*this.width,yMax:e.yMax*this.height,width:e.width*this.width,height:e.height*this.height}}},t.prototype.estimateFaces=function(n,e){return Vu(this,void 0,void 0,function(){var r,s;return Uu(this,function(o){switch(o.label){case 0:return e&&e.flipHorizontal&&e.flipHorizontal!==this.selfieMode&&(this.selfieMode=e.flipHorizontal,this.faceDetectorSolution.setOptions({selfieMode:this.selfieMode})),n instanceof d.Tensor?(s=ImageData.bind,[4,d.browser.toPixels(n)]):[3,2];case 1:return r=new(s.apply(ImageData,[void 0,o.sent(),n.shape[1],n.shape[0]])),[3,3];case 2:r=n,o.label=3;case 3:return[4,this.faceDetectorSolution.send({image:n=r})];case 4:return o.sent(),[2,this.faces]}})})},t.prototype.dispose=function(){this.faceDetectorSolution.close()},t.prototype.reset=function(){this.faceDetectorSolution.reset(),this.width=0,this.height=0,this.faces=null,this.selfieMode=!1},t.prototype.initialize=function(){return this.faceDetectorSolution.initialize()},t}();function TM(t){return Vu(this,void 0,void 0,function(){var n,e;return Uu(this,function(r){switch(r.label){case 0:return n=function(s){if(null==s)return mc({},h3);var o=mc({},s);return o.runtime="mediapipe",null==o.modelType&&(o.modelType=h3.modelType),null==o.maxFaces&&(o.maxFaces=h3.maxFaces),o}(t),[4,(e=new DM(n)).initialize()];case 1:return r.sent(),[2,e]}})})}function VC(t){return t instanceof d.Tensor?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function UC(t){return t instanceof d.Tensor?t:d.browser.fromPixels(t)}function f3(t,n){d.util.assert(0!==t.width,function(){return n+" width cannot be 0."}),d.util.assert(0!==t.height,function(){return n+" height cannot be 0."})}function WC(t){null==t.reduceBoxesInLowestLayer&&(t.reduceBoxesInLowestLayer=!1),null==t.interpolatedScaleAspectRatio&&(t.interpolatedScaleAspectRatio=1),null==t.fixedAnchorSize&&(t.fixedAnchorSize=!1);for(var n=[],e=0;e<t.numLayers;){for(var r=[],s=[],o=[],i=[],a=e;a<t.strides.length&&t.strides[a]===t.strides[e];){var u=zC(t.minScale,t.maxScale,a,t.strides.length);if(0===a&&t.reduceBoxesInLowestLayer)o.push(1),o.push(2),o.push(.5),i.push(.1),i.push(u),i.push(u);else{for(var c=0;c<t.aspectRatios.length;++c)o.push(t.aspectRatios[c]),i.push(u);if(t.interpolatedScaleAspectRatio>0){var l=a===t.strides.length-1?1:zC(t.minScale,t.maxScale,a+1,t.strides.length);i.push(Math.sqrt(u*l)),o.push(t.interpolatedScaleAspectRatio)}}a++}for(var h=0;h<o.length;++h){var f=Math.sqrt(o[h]);r.push(i[h]/f),s.push(i[h]*f)}var m=0,y=0;if(t.featureMapHeight.length>0)m=t.featureMapHeight[e],y=t.featureMapWidth[e];else{var w=t.strides[e];m=Math.ceil(t.inputSizeHeight/w),y=Math.ceil(t.inputSizeWidth/w)}for(var E=0;E<m;++E)for(var D=0;D<y;++D)for(var O=0;O<r.length;++O){var W={xCenter:(D+t.anchorOffsetX)/y,yCenter:(E+t.anchorOffsetY)/m,width:0,height:0};t.fixedAnchorSize?(W.width=1,W.height=1):(W.width=s[O],W.height=r[O]),n.push(W)}e=a}return n}function zC(t,n,e,r){return 1===r?.5*(t+n):t+(n-t)*e/(r-1)}function HC(t,n){var e=n[0],r=n[1];return[e*t[0]+r*t[1]+t[3],e*t[4]+r*t[5]+t[7]]}function kM(t,n,e,r){return Vu(this,void 0,void 0,function(){var s,o,i,a,u;return Uu(this,function(c){switch(c.label){case 0:return t.sort(function(l,h){return Math.max.apply(Math,h.score)-Math.max.apply(Math,l.score)}),s=(0,d.tensor2d)(t.map(function(l){return[l.locationData.relativeBoundingBox.yMin,l.locationData.relativeBoundingBox.xMin,l.locationData.relativeBoundingBox.yMax,l.locationData.relativeBoundingBox.xMax]})),o=(0,d.tensor1d)(t.map(function(l){return l.score[0]})),[4,d.image.nonMaxSuppressionAsync(s,o,n,e)];case 1:return[4,(i=c.sent()).array()];case 2:return a=c.sent(),u=t.filter(function(l,h){return a.indexOf(h)>-1}),(0,d.dispose)([s,o,i]),[2,u]}})})}function AM(t,n,e){return Vu(this,void 0,void 0,function(){var r,o,i,a;return Uu(this,function(u){switch(u.label){case 0:return r=t[0],c=t[1],l=n,h=e,o=(0,d.tidy)(function(){var f,m,y,w;h.reverseOutputOrder?(m=(0,d.squeeze)((0,d.slice)(c,[0,h.boxCoordOffset+0],[-1,1])),f=(0,d.squeeze)((0,d.slice)(c,[0,h.boxCoordOffset+1],[-1,1])),w=(0,d.squeeze)((0,d.slice)(c,[0,h.boxCoordOffset+2],[-1,1])),y=(0,d.squeeze)((0,d.slice)(c,[0,h.boxCoordOffset+3],[-1,1]))):(f=(0,d.squeeze)((0,d.slice)(c,[0,h.boxCoordOffset+0],[-1,1])),m=(0,d.squeeze)((0,d.slice)(c,[0,h.boxCoordOffset+1],[-1,1])),y=(0,d.squeeze)((0,d.slice)(c,[0,h.boxCoordOffset+2],[-1,1])),w=(0,d.squeeze)((0,d.slice)(c,[0,h.boxCoordOffset+3],[-1,1]))),m=(0,d.add)((0,d.mul)((0,d.div)(m,h.xScale),l.w),l.x),f=(0,d.add)((0,d.mul)((0,d.div)(f,h.yScale),l.h),l.y),h.applyExponentialOnBoxSize?(y=(0,d.mul)((0,d.exp)((0,d.div)(y,h.hScale)),l.h),w=(0,d.mul)((0,d.exp)((0,d.div)(w,h.wScale)),l.w)):(y=(0,d.mul)((0,d.div)(y,h.hScale),l.h),w=(0,d.mul)((0,d.div)(w,h.wScale),l.h));var E=(0,d.sub)(f,(0,d.div)(y,2)),D=(0,d.sub)(m,(0,d.div)(w,2)),O=(0,d.add)(f,(0,d.div)(y,2)),W=(0,d.add)(m,(0,d.div)(w,2)),q=(0,d.concat)([(0,d.reshape)(E,[h.numBoxes,1]),(0,d.reshape)(D,[h.numBoxes,1]),(0,d.reshape)(O,[h.numBoxes,1]),(0,d.reshape)(W,[h.numBoxes,1])],1);if(h.numKeypoints)for(var re=0;re<h.numKeypoints;++re){var pe=h.keypointCoordOffset+re*h.numValuesPerKeypoint,Ae=void 0,Be=void 0;h.reverseOutputOrder?(Ae=(0,d.squeeze)((0,d.slice)(c,[0,pe],[-1,1])),Be=(0,d.squeeze)((0,d.slice)(c,[0,pe+1],[-1,1]))):(Be=(0,d.squeeze)((0,d.slice)(c,[0,pe],[-1,1])),Ae=(0,d.squeeze)((0,d.slice)(c,[0,pe+1],[-1,1])));var Ke=(0,d.add)((0,d.mul)((0,d.div)(Ae,h.xScale),l.w),l.x),Ge=(0,d.add)((0,d.mul)((0,d.div)(Be,h.yScale),l.h),l.y);q=(0,d.concat)([q,(0,d.reshape)(Ke,[h.numBoxes,1]),(0,d.reshape)(Ge,[h.numBoxes,1])],1)}return q}),i=(0,d.tidy)(function(){var c=r;return e.sigmoidScore?(null!=e.scoreClippingThresh&&(c=(0,d.clipByValue)(r,-e.scoreClippingThresh,e.scoreClippingThresh)),c=(0,d.sigmoid)(c)):c}),[4,RM(o,i,e)];case 1:return a=u.sent(),(0,d.dispose)([o,i]),[2,a]}var c,l,h})})}function RM(t,n,e){return Vu(this,void 0,void 0,function(){var r,s,o,i,a,u,c,l,h,f,m;return Uu(this,function(w){switch(w.label){case 0:return r=[],[4,t.data()];case 1:return s=w.sent(),[4,n.data()];case 2:for(o=w.sent(),i=0;i<e.numBoxes;++i)if(!(null!=e.minScoreThresh&&o[i]<e.minScoreThresh||(a=i*e.numCoords,u=OM(s[a+0],s[a+1],s[a+2],s[a+3],o[i],e.flipVertically,i),(c=u.locationData.relativeBoundingBox).width<0||c.height<0))){if(e.numKeypoints>0)for((l=u.locationData).relativeKeypoints=[],h=e.numKeypoints*e.numValuesPerKeypoint,f=0;f<h;f+=e.numValuesPerKeypoint)l.relativeKeypoints.push({x:s[(m=a+e.keypointCoordOffset+f)+0],y:e.flipVertically?1-s[m+1]:s[m+1]});r.push(u)}return[2,r]}})})}function OM(t,n,e,r,s,o,i){return{score:[s],ind:i,locationData:{relativeBoundingBox:{xMin:n,yMin:o?1-e:t,xMax:r,yMax:o?1-t:e,width:r-n,height:e-t}}}}var qm,MM={reduceBoxesInLowestLayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:4,minScale:.1484375,maxScale:.75,inputSizeHeight:128,inputSizeWidth:128,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,16,16],aspectRatios:[1],fixedAnchorSize:!0},$M={reduceBoxesInLowestLayer:!1,interpolatedScaleAspectRatio:0,featureMapHeight:[],featureMapWidth:[],numLayers:1,minScale:.1484375,maxScale:.75,inputSizeHeight:192,inputSizeWidth:192,anchorOffsetX:.5,anchorOffsetY:.5,strides:[4],aspectRatios:[1],fixedAnchorSize:!0},p3={runtime:"tfjs",modelType:"short",maxFaces:1,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1"},FM={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:896,numCoords:16,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:6,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:128,yScale:128,hScale:128,wScale:128,minScoreThresh:.5},PM={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2304,numCoords:16,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:6,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:192,yScale:192,hScale:192,wScale:192,minScoreThresh:.6},LM={outputTensorSize:{width:128,height:128},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},BM={outputTensorSize:{width:192,height:192},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},VM=function(){function t(n,e,r){this.detectorModel=e,this.maxFaces=r,"full"===n?(this.imageToTensorConfig=BM,this.tensorsToDetectionConfig=PM,this.anchors=WC($M)):(this.imageToTensorConfig=LM,this.tensorsToDetectionConfig=FM,this.anchors=WC(MM));var s=(0,d.tensor1d)(this.anchors.map(function(u){return u.width})),o=(0,d.tensor1d)(this.anchors.map(function(u){return u.height})),i=(0,d.tensor1d)(this.anchors.map(function(u){return u.xCenter})),a=(0,d.tensor1d)(this.anchors.map(function(u){return u.yCenter}));this.anchorTensor={x:i,y:a,w:s,h:o}}return t.prototype.dispose=function(){this.detectorModel.dispose(),(0,d.dispose)([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h])},t.prototype.reset=function(){},t.prototype.detectFaces=function(n,e){return void 0===e&&(e=!1),Vu(this,void 0,void 0,function(){var r,s,o,i,a,u,c,l,h,f,m;return Uu(this,function(y){switch(y.label){case 0:return null==n?(this.reset(),[2,[]]):(r=(0,d.tidy)(function(){var w=(0,d.cast)(UC(n),"float32");return e&&(w=(0,d.squeeze)(d.image.flipLeftRight((0,d.expandDims)(w,0)),[0])),w}),s=function NM(t,n,e){var f,m,r=n.outputTensorSize,s=n.keepAspectRatio,o=n.borderMode,i=n.outputTensorFloatRange,a=VC(t),u=(f=a,(m=e)?{xCenter:m.xCenter*f.width,yCenter:m.yCenter*f.height,width:m.width*f.width,height:m.height*f.height,rotation:m.rotation}:{xCenter:.5*f.width,yCenter:.5*f.height,width:f.width,height:f.height,rotation:0}),c=function(f,m,y){if(void 0===y&&(y=!1),!y)return{top:0,left:0,right:0,bottom:0};var w=m.height,E=m.width;f3(m,"targetSize"),f3(f,"roi");var D,O,W=w/E,q=f.height/f.width,re=0,pe=0;return W>q?(D=f.width,O=f.width*W,pe=(1-q/W)/2):(D=f.height/W,O=f.height,re=(1-W/q)/2),f.width=D,f.height=O,{top:pe,left:re,right:re,bottom:pe}}(u,r,s),l=function(f,m,y,w){var E=f.width,D=f.height,W=Math.cos(f.rotation),q=Math.sin(f.rotation),re=f.xCenter,pe=f.yCenter,Ae=1/m,Be=1/y,Ke=new Array(16);return Ke[0]=E*W*1*Ae,Ke[1]=-D*q*Ae,Ke[2]=0,Ke[3]=(-.5*E*W*1+.5*D*q+re)*Ae,Ke[4]=E*q*1*Be,Ke[5]=D*W*Be,Ke[6]=0,Ke[7]=(-.5*D*W-.5*E*q*1+pe)*Be,Ke[8]=0,Ke[9]=0,Ke[10]=E*Ae,Ke[11]=0,Ke[12]=0,Ke[13]=0,Ke[14]=0,Ke[15]=1,function(Ge){if(16!==Ge.length)throw new Error("Array length must be 16 but got "+Ge.length);return[[Ge[0],Ge[1],Ge[2],Ge[3]],[Ge[4],Ge[5],Ge[6],Ge[7]],[Ge[8],Ge[9],Ge[10],Ge[11]],[Ge[12],Ge[13],Ge[14],Ge[15]]]}(Ke)}(u,a.width,a.height),h=(0,d.tidy)(function(){var E,D,O,f=UC(t),m=(0,d.tensor2d)((E=l,D=a,f3(O=r,"inputResolution"),[1/O.width*E[0][0]*D.width,1/O.height*E[0][1]*D.width,E[0][3]*D.width,1/O.width*E[1][0]*D.height,1/O.height*E[1][1]*D.height,E[1][3]*D.height,0,0]),[1,8]),y="zero"===o?"constant":"nearest",w=d.image.transform((0,d.expandDims)((0,d.cast)(f,"float32")),m,"bilinear",y,0,[r.height,r.width]);return null!=i?function(E,D){var re,Ae,O={scale:Ae=(D[1]-(re=D[0]))/255,offset:re-0*Ae};return(0,d.tidy)(function(){return(0,d.add)((0,d.mul)(E,O.scale),O.offset)})}(w,i):w});return{imageTensor:h,padding:c,transformationMatrix:l}}(r,this.imageToTensorConfig),i=s.transformationMatrix,a=this.detectorModel.execute(o=s.imageTensor,"Identity:0"),w=a,u=(0,d.tidy)(function(){var W,E=(W=w,(0,d.tidy)(function(){return[(0,d.slice)(W,[0,0,0],[1,-1,1]),(0,d.slice)(W,[0,0,1],[1,-1,-1])]})),D=E[0];return{boxes:(0,d.squeeze)(E[1]),logits:(0,d.squeeze)(D)}}),[4,AM([l=u.logits,c=u.boxes],this.anchorTensor,this.tensorsToDetectionConfig)]);case 1:return 0===(h=y.sent()).length?((0,d.dispose)([r,o,a,l,c]),[2,h]):[4,kM(h,this.maxFaces,.3)];case 2:return f=y.sent(),m=function(w,E){void 0===w&&(w=[]);var O=[].concat.apply([],E);return w.forEach(function(W){var q=W.locationData;q.relativeKeypoints.forEach(function(Ge){var ft=HC(O,[Ge.x,Ge.y]),pt=ft[1];Ge.x=ft[0],Ge.y=pt});var re=q.relativeBoundingBox,pe=Number.MAX_VALUE,Ae=Number.MAX_VALUE,Be=Number.MIN_VALUE,Ke=Number.MIN_VALUE;[[re.xMin,re.yMin],[re.xMin+re.width,re.yMin],[re.xMin+re.width,re.yMin+re.height],[re.xMin,re.yMin+re.height]].forEach(function(Ge){var ft=HC(O,Ge),yt=ft[0],pt=ft[1];pe=Math.min(pe,yt),Be=Math.max(Be,yt),Ae=Math.min(Ae,pt),Ke=Math.max(Ke,pt)}),q.relativeBoundingBox={xMin:pe,xMax:Be,yMin:Ae,yMax:Ke,width:Be-pe,height:Ke-Ae}}),w}(f,i),(0,d.dispose)([r,o,a,l,c]),[2,m]}var w})})},t.prototype.estimateFaces=function(n,e){return Vu(this,void 0,void 0,function(){var r;return Uu(this,function(o){return r=VC(n),[2,this.detectFaces(n,!!e&&e.flipHorizontal).then(function(i){return i.map(function(a){for(var u=a.locationData.relativeKeypoints.map(function(y,w){return mc(mc({},y),{x:y.x*r.width,y:y.y*r.height,name:BC[w]})}),c=a.locationData.relativeBoundingBox,l=0,h=["width","xMax","xMin"];l<h.length;l++)c[h[l]]*=r.width;for(var f=0,m=["height","yMax","yMin"];f<m.length;f++)c[m[f]]*=r.height;return{keypoints:u,box:c}})})]})})},t}();function UM(t){return Vu(this,void 0,void 0,function(){var n,e,r;return Uu(this,function(s){switch(s.label){case 0:return n=function(o){if(null==o)return mc({},p3);var i=mc({},o);return null==i.modelType&&(i.modelType=p3.modelType),null==i.maxFaces&&(i.maxFaces=p3.maxFaces),null==i.detectorModelUrl&&(i.detectorModelUrl="full"===i.modelType?"https://tfhub.dev/mediapipe/tfjs-model/face_detection/full/1":"https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1"),i}(t),e="string"==typeof n.detectorModelUrl&&n.detectorModelUrl.indexOf("https://tfhub.dev")>-1,[4,(0,FC.loadGraphModel)(n.detectorModelUrl,{fromTFHub:e})];case 1:return r=s.sent(),[2,new VM(n.modelType,r,n.maxFaces)]}})})}function WM(t,n){return Vu(this,void 0,void 0,function(){var e,r;return Uu(this,function(s){if(t===qm.MediaPipeFaceDetector){if(r=void 0,null!=(e=n)){if("tfjs"===e.runtime)return[2,UM(e)];if("mediapipe"===e.runtime)return[2,TM(e)];r=e.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+r)}throw new Error(t+" is not a supported model name.")})})}function m3(t){return t.width*t.height}function jC(t){var n=t.xCenter-t.width/2,r=t.yCenter-t.height/2;return{xMin:n,xMax:n+t.width,yMin:r,yMax:r+t.height,width:t.width,height:t.height}}function GC(t){return t instanceof d.Tensor?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function KC(t){return t-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function XC(t){return t instanceof d.Tensor?t:d.browser.fromPixels(t)}function g3(t,n){d.util.assert(0!==t.width,function(){return n+" width cannot be 0."}),d.util.assert(0!==t.height,function(){return n+" height cannot be 0."})}function qC(t){return{xCenter:t.xMin+t.width/2,yCenter:t.yMin+t.height/2,width:t.width,height:t.height}}function YC(t){var n=t.relativeKeypoints;if(n.length<=1)throw new Error("2 or more keypoints required to calculate a rect.");var e=Number.MAX_VALUE,r=Number.MAX_VALUE,s=Number.MIN_VALUE,o=Number.MIN_VALUE;return n.forEach(function(i){e=Math.min(e,i.x),s=Math.max(s,i.x),r=Math.min(r,i.y),o=Math.max(o,i.y)}),{xCenter:(e+s)/2,yCenter:(r+o)/2,width:s-e,height:o-r}}function ZC(t,n,e,r,s){var u,o="rect"===e?function(i,a,u){var c,l=i.locationData;if("boundingbox"===a)c=qC(l.boundingBox);else{c=YC(l);var h=u.width,f=u.height;c.xCenter=Math.round(c.xCenter*h),c.yCenter=Math.round(c.yCenter*f),c.width=Math.round(c.width*h),c.height=Math.round(c.height*f)}return c}(t,n,r):(u=t.locationData,"boundingbox"===n?qC(u.relativeBoundingBox):YC(u));return s&&(o.rotation=function(i,a,u){var l=i.locationData,h=u.rotationVectorStartKeypointIndex,f=u.rotationVectorEndKeypointIndex;return KC((u.rotationVectorTargetAngle?u.rotationVectorTargetAngle:Math.PI*u.rotationVectorTargetAngleDegree/180)-Math.atan2(-(l.relativeKeypoints[f].y*a.height-l.relativeKeypoints[h].y*a.height),l.relativeKeypoints[f].x*a.width-l.relativeKeypoints[h].x*a.width))}(t,r,s)),o}function KM(t,n,e){for(var r=0;r<n.length;++r){var s=n[r],o=e[t[r]];o.x=s.x,o.y=s.y}}function XM(t,n,e,r){if("string"==typeof n){if("copy"===n)for(var s=0;s<e.length;++s)r[t[s]].z=e[s].z}else{var o=function(i,a){for(var u=0,c=0;c<a.length;++c)u+=i[a[c]].z;return u/a.length}(r,n);for(s=0;s<t.length;++s)r[t[s]].z=o}}function qM(t,n){for(var e=function(a){var u=[].concat.apply([],a.map(function(m){return m.indexesMapping}));if(0===u.length)throw new Error("There should be at least one landmark in indexes mapping");var c=u[0],l=u[0],h=new Set(u);h.forEach(function(m){c=Math.min(c,m),l=Math.max(l,m)});var f=h.size;if(0!==c)throw new Error("Indexes are expected to start with 0 instead of "+c);if(l+1!==f)throw new Error("Indexes should have no gaps but "+(l-f+1)+" indexes are missing");return f}(n),r=new Array(e).fill(null).map(Object),s=0;s<t.length;++s){var o=t[s],i=n[s];if(o.length!==i.indexesMapping.length)throw new Error("There are "+o.length+" refinement landmarks while mapping has "+i.indexesMapping.length);KM(i.indexesMapping,o,r),XM(i.indexesMapping,i.zRefinement,o,r)}return r}function YM(t,n){return t.map(function(e){var r=Aa(Aa({},e),{x:e.x*n.width,y:e.y*n.height});return null!=e.z&&(r.z=e.z*n.width),r})}function ZM(t,n){return"none"===t?n:1/(1+Math.exp(-n))}function tl(t,n,e,r){return Lu(this,void 0,void 0,function(){var o,i,a,u,c,l,h;return Bu(this,function(f){switch(f.label){case 0:return e=e||n.flipHorizontally||!1,r=r||n.flipVertically||!1,o=t.size/n.numLandmarks,[4,t.data()];case 1:for(i=f.sent(),a=[],u=0;u<n.numLandmarks;++u)c=u*o,(h={x:0,y:0}).x=e?n.inputImageWidth-i[c]:i[c],o>1&&(h.y=r?n.inputImageHeight-i[c+1]:i[c+1]),o>2&&(h.z=i[c+2]),o>3&&(h.score=ZM(n.visibilityActivation,i[c+3])),a.push(h);for(l=0;l<a.length;++l)(h=a[l]).x=h.x/n.inputImageWidth,h.y=h.y/n.inputImageHeight,h.z=h.z/n.inputImageWidth/(n.normalizeZ||1);return[2,a]}})})}function QC(t,n,e){var l,h,r=t.width,s=t.height,o=t.rotation;if(null==e.rotation&&null==e.rotationDegree||(l=o,null!=(h=e).rotation?l+=h.rotation:null!=h.rotationDegree&&(l+=Math.PI*h.rotationDegree/180),o=KC(l)),0===o)t.xCenter=t.xCenter+r*e.shiftX,t.yCenter=t.yCenter+s*e.shiftY;else{var i=(n.width*r*e.shiftX*Math.cos(o)-n.height*s*e.shiftY*Math.sin(o))/n.width,a=(n.width*r*e.shiftX*Math.sin(o)+n.height*s*e.shiftY*Math.cos(o))/n.height;t.xCenter=t.xCenter+i,t.yCenter=t.yCenter+a}if(e.squareLong){var u=Math.max(r*n.width,s*n.height);r=u/n.width,s=u/n.height}else if(e.squareShort){var c=Math.min(r*n.width,s*n.height);r=c/n.width,s=c/n.height}return t.width=r*e.scaleX,t.height=s*e.scaleY,t}(qm||(qm={})).MediaPipeFaceDetector="MediaPipeFaceDetector";var Id,y3={runtime:"tfjs",maxFaces:1,refineLandmarks:!1,landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/face_landmarks_detection/face_mesh/1"},v3={flipHorizontal:!1,staticImageMode:!1},JC={shiftX:0,shiftY:0,scaleX:1.5,scaleY:1.5,squareLong:!0},QM={outputTensorSize:{width:192,height:192},outputTensorFloatRange:[0,1],borderMode:"replicate"},eS={numLandmarks:468,inputImageWidth:192,inputImageHeight:192,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},JM={numLandmarks:80,inputImageWidth:192,inputImageHeight:192,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},tS={numLandmarks:71,inputImageWidth:192,inputImageHeight:192,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},nS={numLandmarks:5,inputImageWidth:192,inputImageHeight:192,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},e$={indexesMapping:Array.from(Array(468).keys()),zRefinement:"copy"},t$={indexesMapping:[61,146,91,181,84,17,314,405,321,375,291,185,40,39,37,0,267,269,270,409,78,95,88,178,87,14,317,402,318,324,308,191,80,81,82,13,312,311,310,415,76,77,90,180,85,16,315,404,320,307,306,184,74,73,72,11,302,303,304,408,62,96,89,179,86,15,316,403,319,325,292,183,42,41,38,12,268,271,272,407],zRefinement:"none"},n$={indexesMapping:[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173,130,25,110,24,23,22,26,112,243,247,30,29,27,28,56,190,226,31,228,229,230,231,232,233,244,113,225,224,223,222,221,189,35,124,46,53,52,65,143,111,117,118,119,120,121,128,245,156,70,63,105,66,107,55,193],zRefinement:"none"},r$={indexesMapping:[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398,359,255,339,254,253,252,256,341,463,467,260,259,257,258,286,414,446,261,448,449,450,451,452,453,464,342,445,444,443,442,441,413,265,353,276,283,282,295,372,340,346,347,348,349,350,357,465,383,300,293,334,296,336,285,417],zRefinement:"none"},s$={indexesMapping:[468,469,470,471,472],zRefinement:[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173]},o$={indexesMapping:[473,474,475,476,477],zRefinement:[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398]},i$=function(){function t(n,e,r,s){this.detector=n,this.landmarkModel=e,this.maxFaces=r,this.withAttention=s,this.prevFaceRectsFromLandmarks=null}return t.prototype.estimateFaces=function(n,e){return Lu(this,void 0,void 0,function(){var r,s,o,i,a,u,l,h,f,m,y,w,E=this;return Bu(this,function(D){switch(D.label){case 0:return r=function(q){if(null==q)return Aa({},v3);var re=Aa({},q);return null==re.flipHorizontal&&(re.flipHorizontal=v3.flipHorizontal),null==re.staticImageMode&&(re.staticImageMode=v3.staticImageMode),re}(e),null==n?(this.reset(),[2,[]]):(s=GC(n),o=d.tidy(function(){var q=d.cast(XC(n),"float32");return r.flipHorizontal&&(q=d.squeeze(d.image.flipLeftRight(d.expandDims(q,0)),[0])),q}),i=this.prevFaceRectsFromLandmarks,r.staticImageMode||null==i||i.length<this.maxFaces?[4,this.detector.detectFaces(o,!1)]:[3,2]);case 1:return 0===(u=D.sent()).length?(this.reset(),o.dispose(),[2,[]]):(a=u.map(function(q){return E.faceDetectionFrontDetectionToRoi(q,s)}),[3,3]);case 2:a=[],D.label=3;case 3:return W=[],[a,i||[]].forEach(function(q){return q.forEach(function(re){(W=W.filter(function(pe){return function zM(t,n){var i,a,e=jC(t),r=jC(n);if((i=e).xMax<(a=r).xMin||a.xMax<i.xMin||i.yMax<a.yMin||a.yMax<i.yMin)return 0;var s=m3(function(i,a){var u=Math.max(i.xMin,a.xMin),c=Math.min(i.xMax,a.xMax),l=Math.max(i.yMin,a.yMin),h=Math.min(i.yMax,a.yMax);return{xMin:u,xMax:c,yMin:l,yMax:h,width:Math.max(c-u,0),height:Math.max(h-l,0)}}(e,r)),o=m3(e)+m3(r)-s;return o>0?s/o:0}(re,pe)<=.5})).push(re)})}),[4,Promise.all(W.map(function(q){return E.faceLandmark(q,o)}))];case 4:for(l=D.sent(),h=[],this.prevFaceRectsFromLandmarks=[],f=0;f<l.length;++f)null!=(m=l[f])&&(this.prevFaceRectsFromLandmarks.push(this.faceLandmarksToRoi(m,s)),null!=(y=YM(m,s))&&y.forEach(function(q,re){var pe=LC.get(re);null!=pe&&(q.name=pe)}),w=c3(y),h.push({keypoints:y,box:w.locationData.relativeBoundingBox}));return o.dispose(),[2,h]}var W})})},t.prototype.dispose=function(){this.detector.dispose(),this.landmarkModel.dispose()},t.prototype.reset=function(){this.detector.reset(),this.prevFaceRectsFromLandmarks=null},t.prototype.faceDetectionFrontDetectionToRoi=function(n,e){return QC(ZC(n,"boundingbox","normRect",e,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:0}),e,JC)},t.prototype.faceLandmark=function(n,e){return Lu(this,void 0,void 0,function(){var r,s,o,i,a,u,c;return Bu(this,function(l){switch(l.label){case 0:return r=function GM(t,n,e){var f,m,r=n.outputTensorSize,s=n.keepAspectRatio,o=n.borderMode,i=n.outputTensorFloatRange,a=GC(t),u=(f=a,(m=e)?{xCenter:m.xCenter*f.width,yCenter:m.yCenter*f.height,width:m.width*f.width,height:m.height*f.height,rotation:m.rotation}:{xCenter:.5*f.width,yCenter:.5*f.height,width:f.width,height:f.height,rotation:0}),c=function(f,m,y){if(void 0===y&&(y=!1),!y)return{top:0,left:0,right:0,bottom:0};var w=m.height,E=m.width;g3(m,"targetSize"),g3(f,"roi");var D,O,W=w/E,q=f.height/f.width,re=0,pe=0;return W>q?(D=f.width,O=f.width*W,pe=(1-q/W)/2):(D=f.height/W,O=f.height,re=(1-W/q)/2),f.width=D,f.height=O,{top:pe,left:re,right:re,bottom:pe}}(u,r,s),l=function HM(t,n,e,r){var s=t.width,o=t.height,i=r?-1:1,a=Math.cos(t.rotation),u=Math.sin(t.rotation),c=t.xCenter,l=t.yCenter,h=1/n,f=1/e,m=new Array(16);return m[0]=s*a*i*h,m[1]=-o*u*h,m[2]=0,m[3]=(-.5*s*a*i+.5*o*u+c)*h,m[4]=s*u*i*f,m[5]=o*a*f,m[6]=0,m[7]=(-.5*o*a-.5*s*u*i+l)*f,m[8]=0,m[9]=0,m[10]=s*h,m[11]=0,m[12]=0,m[13]=0,m[14]=0,m[15]=1,function(y){if(16!==y.length)throw new Error("Array length must be 16 but got "+y.length);return[[y[0],y[1],y[2],y[3]],[y[4],y[5],y[6],y[7]],[y[8],y[9],y[10],y[11]],[y[12],y[13],y[14],y[15]]]}(m)}(u,a.width,a.height,!1),h=d.tidy(function(){var E,D,O,f=XC(t),m=d.tensor2d((E=l,D=a,g3(O=r,"inputResolution"),[1/O.width*E[0][0]*D.width,1/O.height*E[0][1]*D.width,E[0][3]*D.width,1/O.width*E[1][0]*D.height,1/O.height*E[1][1]*D.height,E[1][3]*D.height,0,0]),[1,8]),y="zero"===o?"constant":"nearest",w=d.image.transform(d.expandDims(d.cast(f,"float32")),m,"bilinear",y,0,[r.height,r.width]);return null!=i?function jM(t,n){var o,c,e={scale:c=(n[1]-(o=n[0]))/255,offset:o-0*c};return d.tidy(function(){return d.add(d.mul(t,e.scale),e.offset)})}(w,i):w});return{imageTensor:h,padding:c,transformationMatrix:l}}(e,QM,n).imageTensor,s=["output_faceflag"].concat(this.withAttention?["output_mesh_identity","output_lips","Identity_6:0","Identity_1:0","Identity_2:0","Identity_5:0"]:["output_mesh"]),o=this.landmarkModel.execute(r,s),i=o[0],a=o.slice(1),[4,i.data()];case 1:return l.sent()[0]<.5?(d.dispose(o),d.dispose(r),[2,null]):this.withAttention?[4,this.tensorsToFaceLandmarksWithAttention(a)]:[3,3];case 2:return u=l.sent(),[3,5];case 3:return[4,this.tensorsToFaceLandmarks(a)];case 4:u=l.sent(),l.label=5;case 5:return c=function(h,f,m){void 0===m&&(m={ignoreRotation:!1});for(var y=[],w=0,E=h;w<E.length;w++){var D=E[w],O=D.x-.5,W=D.y-.5,q=m.ignoreRotation?0:f.rotation,re=Math.cos(q)*O-Math.sin(q)*W,pe=Math.sin(q)*O+Math.cos(q)*W;re=re*f.width+f.xCenter,pe=pe*f.height+f.yCenter;var Ae=D.z*f.width,Be=Aa({},D);Be.x=re,Be.y=pe,Be.z=Ae,y.push(Be)}return y}(u,n),d.dispose(o),d.dispose(r),[2,c]}})})},t.prototype.tensorsToFaceLandmarks=function(n){return Lu(this,void 0,void 0,function(){return Bu(this,function(e){return[2,tl(n[0],eS)]})})},t.prototype.tensorsToFaceLandmarksWithAttention=function(n){return Lu(this,void 0,void 0,function(){var e,r,s,o,i,a;return Bu(this,function(u){switch(u.label){case 0:return[4,tl(n[0],eS)];case 1:return e=u.sent(),[4,tl(n[1],JM)];case 2:return r=u.sent(),[4,tl(n[3],tS)];case 3:return s=u.sent(),[4,tl(n[5],tS)];case 4:return o=u.sent(),[4,tl(n[4],nS)];case 5:return i=u.sent(),[4,tl(n[2],nS)];case 6:return a=u.sent(),[2,qM([e,r,s,o,i,a],[e$,t$,n$,r$,s$,o$])]}})})},t.prototype.faceLandmarksToRoi=function(n,e){return QC(ZC(c3(n),"boundingbox","normRect",e,{rotationVectorStartKeypointIndex:33,rotationVectorEndKeypointIndex:263,rotationVectorTargetAngleDegree:0}),e,JC)},t}();function a$(t){return Lu(this,void 0,void 0,function(){var n,e,r,s;return Bu(this,function(o){switch(o.label){case 0:return n=function(i){if(null==i)return Aa({},y3);var a=Aa({},i);return a.runtime="tfjs",null==a.maxFaces&&(a.maxFaces=y3.maxFaces),null==a.refineLandmarks&&(a.refineLandmarks=y3.refineLandmarks),null==a.landmarkModelUrl&&(a.landmarkModelUrl=a.refineLandmarks?"https://tfhub.dev/mediapipe/tfjs-model/face_landmarks_detection/attention_mesh/1":"https://tfhub.dev/mediapipe/tfjs-model/face_landmarks_detection/face_mesh/1"),a}(t),e="string"==typeof n.landmarkModelUrl&&n.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,FC.loadGraphModel(n.landmarkModelUrl,{fromTFHub:e})];case 1:return r=o.sent(),[4,WM(qm.MediaPipeFaceDetector,{modelType:"short",maxFaces:n.maxFaces,detectorModelUrl:n.detectorModelUrl,runtime:n.runtime})];case 2:return s=o.sent(),[2,new i$(s,r,n.maxFaces,n.refineLandmarks)]}})})}!function(t){t.MediaPipeFaceMesh="MediaPipeFaceMesh"}(Id||(Id={})),Object.freeze({__proto__:null,getKeypointIndexByContour:function(t){if(t===Id.MediaPipeFaceMesh)return PC;throw new Error("Model "+t+" is not supported.")},getAdjacentPairs:function(t){if(t===Id.MediaPipeFaceMesh)return CM;throw new Error("Model "+t+" is not supported.")}});let Ym=(()=>{class t{}return t.TriangulationTable=[127,34,139,11,0,37,232,231,120,72,37,39,128,121,47,232,121,128,104,69,67,175,171,148,157,154,155,118,50,101,73,39,40,9,151,108,48,115,131,194,204,211,74,40,185,80,42,183,40,92,186,230,229,118,202,212,214,83,18,17,76,61,146,160,29,30,56,157,173,106,204,194,135,214,192,203,165,98,21,71,68,51,45,4,144,24,23,77,146,91,205,50,187,201,200,18,91,106,182,90,91,181,85,84,17,206,203,36,148,171,140,92,40,39,193,189,244,159,158,28,247,246,161,236,3,196,54,68,104,193,168,8,117,228,31,189,193,55,98,97,99,126,47,100,166,79,218,155,154,26,209,49,131,135,136,150,47,126,217,223,52,53,45,51,134,211,170,140,67,69,108,43,106,91,230,119,120,226,130,247,63,53,52,238,20,242,46,70,156,78,62,96,46,53,63,143,34,227,173,155,133,123,117,111,44,125,19,236,134,51,216,206,205,154,153,22,39,37,167,200,201,208,36,142,100,57,212,202,20,60,99,28,158,157,35,226,113,160,159,27,204,202,210,113,225,46,43,202,204,62,76,77,137,123,116,41,38,72,203,129,142,64,98,240,49,102,64,41,73,74,212,216,207,42,74,184,169,170,211,170,149,176,105,66,69,122,6,168,123,147,187,96,77,90,65,55,107,89,90,180,101,100,120,63,105,104,93,137,227,15,86,85,129,102,49,14,87,86,55,8,9,100,47,121,145,23,22,88,89,179,6,122,196,88,95,96,138,172,136,215,58,172,115,48,219,42,80,81,195,3,51,43,146,61,171,175,199,81,82,38,53,46,225,144,163,110,246,33,7,52,65,66,229,228,117,34,127,234,107,108,69,109,108,151,48,64,235,62,78,191,129,209,126,111,35,143,163,161,246,117,123,50,222,65,52,19,125,141,221,55,65,3,195,197,25,7,33,220,237,44,70,71,139,122,193,245,247,130,33,71,21,162,153,158,159,170,169,150,188,174,196,216,186,92,144,160,161,2,97,167,141,125,241,164,167,37,72,38,12,145,159,160,38,82,13,63,68,71,226,35,111,158,153,154,101,50,205,206,92,165,209,198,217,165,167,97,220,115,218,133,112,243,239,238,241,214,135,169,190,173,133,171,208,32,125,44,237,86,87,178,85,86,179,84,85,180,83,84,181,201,83,182,137,93,132,76,62,183,61,76,184,57,61,185,212,57,186,214,207,187,34,143,156,79,239,237,123,137,177,44,1,4,201,194,32,64,102,129,213,215,138,59,166,219,242,99,97,2,94,141,75,59,235,24,110,228,25,130,226,23,24,229,22,23,230,26,22,231,112,26,232,189,190,243,221,56,190,28,56,221,27,28,222,29,27,223,30,29,224,247,30,225,238,79,20,166,59,75,60,75,240,147,177,215,20,79,166,187,147,213,112,233,244,233,128,245,128,114,188,114,217,174,131,115,220,217,198,236,198,131,134,177,132,58,143,35,124,110,163,7,228,110,25,356,389,368,11,302,267,452,350,349,302,303,269,357,343,277,452,453,357,333,332,297,175,152,377,384,398,382,347,348,330,303,304,270,9,336,337,278,279,360,418,262,431,304,408,409,310,415,407,270,409,410,450,348,347,422,430,434,313,314,17,306,307,375,387,388,260,286,414,398,335,406,418,364,367,416,423,358,327,251,284,298,281,5,4,373,374,253,307,320,321,425,427,411,421,313,18,321,405,406,320,404,405,315,16,17,426,425,266,377,400,369,322,391,269,417,465,464,386,257,258,466,260,388,456,399,419,284,332,333,417,285,8,346,340,261,413,441,285,327,460,328,355,371,329,392,439,438,382,341,256,429,420,360,364,394,379,277,343,437,443,444,283,275,440,363,431,262,369,297,338,337,273,375,321,450,451,349,446,342,467,293,334,282,458,461,462,276,353,383,308,324,325,276,300,293,372,345,447,382,398,362,352,345,340,274,1,19,456,248,281,436,427,425,381,256,252,269,391,393,200,199,428,266,330,329,287,273,422,250,462,328,258,286,384,265,353,342,387,259,257,424,431,430,342,353,276,273,335,424,292,325,307,366,447,345,271,303,302,423,266,371,294,455,460,279,278,294,271,272,304,432,434,427,272,407,408,394,430,431,395,369,400,334,333,299,351,417,168,352,280,411,325,319,320,295,296,336,319,403,404,330,348,349,293,298,333,323,454,447,15,16,315,358,429,279,14,15,316,285,336,9,329,349,350,374,380,252,318,402,403,6,197,419,318,319,325,367,364,365,435,367,397,344,438,439,272,271,311,195,5,281,273,287,291,396,428,199,311,271,268,283,444,445,373,254,339,263,466,249,282,334,296,449,347,346,264,447,454,336,296,299,338,10,151,278,439,455,292,407,415,358,371,355,340,345,372,390,249,466,346,347,280,442,443,282,19,94,370,441,442,295,248,419,197,263,255,359,440,275,274,300,383,368,351,412,465,263,467,466,301,368,389,380,374,386,395,378,379,412,351,419,436,426,322,373,390,388,2,164,393,370,462,461,164,0,267,302,11,12,374,373,387,268,12,13,293,300,301,446,261,340,385,384,381,330,266,425,426,423,391,429,355,437,391,327,326,440,457,438,341,382,362,459,457,461,434,430,394,414,463,362,396,369,262,354,461,457,316,403,402,315,404,403,314,405,404,313,406,405,421,418,406,366,401,361,306,408,407,291,409,408,287,410,409,432,436,410,434,416,411,264,368,383,309,438,457,352,376,401,274,275,4,421,428,262,294,327,358,433,416,367,289,455,439,462,370,326,2,326,370,305,460,455,254,449,448,255,261,446,253,450,449,252,451,450,256,452,451,341,453,452,413,464,463,441,413,414,258,442,441,257,443,442,259,444,443,260,445,444,467,342,445,459,458,250,289,392,290,290,328,460,376,433,435,250,290,392,411,416,433,341,463,464,453,464,465,357,465,412,343,412,399,360,363,440,437,399,456,420,456,363,401,435,288,372,383,353,339,255,249,448,261,255,133,243,190,133,155,112,33,246,247,33,130,25,398,384,286,362,398,414,362,463,341,263,359,467,263,249,255,466,467,260,75,60,166,238,239,79,162,127,139,72,11,37,121,232,120,73,72,39,114,128,47,233,232,128,103,104,67,152,175,148,173,157,155,119,118,101,74,73,40,107,9,108,49,48,131,32,194,211,184,74,185,191,80,183,185,40,186,119,230,118,210,202,214,84,83,17,77,76,146,161,160,30,190,56,173,182,106,194,138,135,192,129,203,98,54,21,68,5,51,4,145,144,23,90,77,91,207,205,187,83,201,18,181,91,182,180,90,181,16,85,17,205,206,36,176,148,140,165,92,39,245,193,244,27,159,28,30,247,161,174,236,196,103,54,104,55,193,8,111,117,31,221,189,55,240,98,99,142,126,100,219,166,218,112,155,26,198,209,131,169,135,150,114,47,217,224,223,53,220,45,134,32,211,140,109,67,108,146,43,91,231,230,120,113,226,247,105,63,52,241,238,242,124,46,156,95,78,96,70,46,63,116,143,227,116,123,111,1,44,19,3,236,51,207,216,205,26,154,22,165,39,167,199,200,208,101,36,100,43,57,202,242,20,99,56,28,157,124,35,113,29,160,27,211,204,210,124,113,46,106,43,204,96,62,77,227,137,116,73,41,72,36,203,142,235,64,240,48,49,64,42,41,74,214,212,207,183,42,184,210,169,211,140,170,176,104,105,69,193,122,168,50,123,187,89,96,90,66,65,107,179,89,180,119,101,120,68,63,104,234,93,227,16,15,85,209,129,49,15,14,86,107,55,9,120,100,121,153,145,22,178,88,179,197,6,196,89,88,96,135,138,136,138,215,172,218,115,219,41,42,81,5,195,51,57,43,61,208,171,199,41,81,38,224,53,225,24,144,110,105,52,66,118,229,117,227,34,234,66,107,69,10,109,151,219,48,235,183,62,191,142,129,126,116,111,143,7,163,246,118,117,50,223,222,52,94,19,141,222,221,65,196,3,197,45,220,44,156,70,139,188,122,245,139,71,162,145,153,159,149,170,150,122,188,196,206,216,92,163,144,161,164,2,167,242,141,241,0,164,37,11,72,12,144,145,160,12,38,13,70,63,71,31,226,111,157,158,154,36,101,205,203,206,165,126,209,217,98,165,97,237,220,218,237,239,241,210,214,169,140,171,32,241,125,237,179,86,178,180,85,179,181,84,180,182,83,181,194,201,182,177,137,132,184,76,183,185,61,184,186,57,185,216,212,186,192,214,187,139,34,156,218,79,237,147,123,177,45,44,4,208,201,32,98,64,129,192,213,138,235,59,219,141,242,97,97,2,141,240,75,235,229,24,228,31,25,226,230,23,229,231,22,230,232,26,231,233,112,232,244,189,243,189,221,190,222,28,221,223,27,222,224,29,223,225,30,224,113,247,225,99,60,240,213,147,215,60,20,166,192,187,213,243,112,244,244,233,245,245,128,188,188,114,174,134,131,220,174,217,236,236,198,134,215,177,58,156,143,124,25,110,7,31,228,25,264,356,368,0,11,267,451,452,349,267,302,269,350,357,277,350,452,357,299,333,297,396,175,377,381,384,382,280,347,330,269,303,270,151,9,337,344,278,360,424,418,431,270,304,409,272,310,407,322,270,410,449,450,347,432,422,434,18,313,17,291,306,375,259,387,260,424,335,418,434,364,416,391,423,327,301,251,298,275,281,4,254,373,253,375,307,321,280,425,411,200,421,18,335,321,406,321,320,405,314,315,17,423,426,266,396,377,369,270,322,269,413,417,464,385,386,258,248,456,419,298,284,333,168,417,8,448,346,261,417,413,285,326,327,328,277,355,329,309,392,438,381,382,256,279,429,360,365,364,379,355,277,437,282,443,283,281,275,363,395,431,369,299,297,337,335,273,321,348,450,349,359,446,467,283,293,282,250,458,462,300,276,383,292,308,325,283,276,293,264,372,447,346,352,340,354,274,19,363,456,281,426,436,425,380,381,252,267,269,393,421,200,428,371,266,329,432,287,422,290,250,328,385,258,384,446,265,342,386,387,257,422,424,430,445,342,276,422,273,424,306,292,307,352,366,345,268,271,302,358,423,371,327,294,460,331,279,294,303,271,304,436,432,427,304,272,408,395,394,431,378,395,400,296,334,299,6,351,168,376,352,411,307,325,320,285,295,336,320,319,404,329,330,349,334,293,333,366,323,447,316,15,315,331,358,279,317,14,316,8,285,9,277,329,350,253,374,252,319,318,403,351,6,419,324,318,325,397,367,365,288,435,397,278,344,439,310,272,311,248,195,281,375,273,291,175,396,199,312,311,268,276,283,445,390,373,339,295,282,296,448,449,346,356,264,454,337,336,299,337,338,151,294,278,455,308,292,415,429,358,355,265,340,372,388,390,466,352,346,280,295,442,282,354,19,370,285,441,295,195,248,197,457,440,274,301,300,368,417,351,465,251,301,389,385,380,386,394,395,379,399,412,419,410,436,322,387,373,388,326,2,393,354,370,461,393,164,267,268,302,12,386,374,387,312,268,13,298,293,301,265,446,340,380,385,381,280,330,425,322,426,391,420,429,437,393,391,326,344,440,438,458,459,461,364,434,394,428,396,262,274,354,457,317,316,402,316,315,403,315,314,404,314,313,405,313,421,406,323,366,361,292,306,407,306,291,408,291,287,409,287,432,410,427,434,411,372,264,383,459,309,457,366,352,401,1,274,4,418,421,262,331,294,358,435,433,367,392,289,439,328,462,326,94,2,370,289,305,455,339,254,448,359,255,446,254,253,449,253,252,450,252,256,451,256,341,452,414,413,463,286,441,414,286,258,441,258,257,442,257,259,443,259,260,444,260,467,445,309,459,250,305,289,290,305,290,460,401,376,435,309,250,392,376,411,433,453,341,464,357,453,465,343,357,412,437,343,399,344,360,440,420,437,456,360,420,363,361,401,288,265,372,353,390,339,249,339,448,255],t})();const c$=["video"],l$=["canvasElement"];function d$(t,n){1&t&&(yr(0,"div",9),li(1,"div",10),Mr())}const h$=function(){return["/home"]};let f$=(()=>{class t{constructor(e){this.elRef=e,this.viewModel=new bM,this.devicesList=null,this.canvasRef=null,this.video=null}ngOnInit(){var e=this;return(0,bs.Z)(function*(){yield e.startWebCam(),yield e.runFacemesh(),e.startDetectFaces()})()}get cameraWidth(){return this.viewModel.cameraWidth}get cameraHeight(){return this.viewModel.cameraHeight}get isVertical(){return window.innerHeight>window.innerWidth}startWebCam(){var e=this;return(0,bs.Z)(function*(){e.devicesList=yield navigator.mediaDevices.enumerateDevices(),e.video&&(e.videoInput=e.video.nativeElement),yield navigator.mediaDevices.getUserMedia({video:{facingMode:"user"},audio:!1}).then(r=>{e.videoInput.srcObject=r;let{width:s,height:o}=r.getTracks()[0].getSettings();e.viewModel.cameraWidth=s??1,e.viewModel.cameraHeight=o??1}).catch(r=>console.log(r)),e.viewModel.isCameraLoaded=!0})()}runFacemesh(){var e=this;return(0,bs.Z)(function*(){e.detectorModel=Id.MediaPipeFaceMesh,e.detectorConfig={runtime:"tfjs",refineLandmarks:!0},yield function u$(t,n){return Lu(this,void 0,void 0,function(){var e,r;return Bu(this,function(s){if(t===Id.MediaPipeFaceMesh){if(r=void 0,null!=(e=n)){if("tfjs"===e.runtime)return[2,a$(e)];if("mediapipe"===e.runtime)return[2,_M(e)];r=e.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+r)}throw new Error(t+" is not a supported model name.")})})}(e.detectorModel,e.detectorConfig).then(r=>{e.detector=r})})()}startDetectFaces(){var e=this;return(0,bs.Z)(function*(){e.canvasRef?.nativeElement.setAttribute("width",e.viewModel.cameraWidth.toString()),e.canvasRef?.nativeElement.setAttribute("height",e.viewModel.cameraHeight.toString());let r=e.canvasRef?.nativeElement.getContext("2d");setInterval((0,bs.Z)(function*(){r&&e.detectFaces(r)}),150)})()}detectFaces(e){var r=this;return(0,bs.Z)(function*(){e.clearRect(0,0,r.canvasRef?.nativeElement.width??0,r.canvasRef?.nativeElement.height??0);let s=[];r.video?.nativeElement&&(yield r.detector?.estimateFaces(r.video?.nativeElement).then(o=>{s=o})),s.forEach(o=>{for(let i=0;i<Ym.TriangulationTable.length/3;i++){let a=[Ym.TriangulationTable[3*i],Ym.TriangulationTable[3*i+1],Ym.TriangulationTable[3*i+2]].map(u=>o.keypoints[u]);r.drawPath(e,a,!0)}o.keypoints.forEach(i=>{e.beginPath(),e.arc(i.x,i.y,1,0,3*Math.PI),e.fillStyle="aqua",e.fill()})})})()}drawPath(e,r,s){let o=new Path2D;o.moveTo(r[0].x,r[0].y),r.forEach(i=>{o.lineTo(i.x,i.y)}),s&&o.closePath(),e.strokeStyle="teal",e.stroke(o)}}return t.\u0275fac=function(e){return new(e||t)(Rn(eu))},t.\u0275cmp=ns({type:t,selectors:[["app-face-detector"]],viewQuery:function(e,r){if(1&e&&(Kh(c$,7),Kh(l$,7)),2&e){let s;ld(s=dd())&&(r.video=s.first),ld(s=dd())&&(r.canvasRef=s.first)}},decls:10,vars:5,consts:[[1,"camera-displayer"],["class","loader-container",4,"ngIf"],[1,"back-container",3,"routerLink"],["id","webcam","autoplay","","muted","","playsinline","",1,"video-placeholder",3,"width","height"],["video",""],[1,"canvas-container"],["canvas",""],["id","canvas",1,"canvas-main"],["canvasElement",""],[1,"loader-container"],[1,"loader"]],template:function(e,r){1&e&&(yr(0,"div",0),Wc(1,d$,2,0,"div",1),yr(2,"div",2),Ps(3,"Back"),Mr(),li(4,"video",3,4),yr(6,"div",5,6),li(8,"canvas",7,8),Mr()()),2&e&&(Eo(1),$i("ngIf",!r.viewModel.isCameraLoaded),Eo(1),$i("routerLink",D0(4,h$)),Eo(2),$i("width",r.cameraWidth)("height",r.cameraHeight))},dependencies:[Jh,Ed],styles:[".video-placeholder[_ngcontent-%COMP%]{background-color:#000;position:relative;top:0}.devices[_ngcontent-%COMP%]{color:#fff}.camera-displayer[_ngcontent-%COMP%]{display:flex;flex-direction:row;justify-content:center}.canvas-container[_ngcontent-%COMP%]{position:absolute;top:0}.loader-container[_ngcontent-%COMP%]{position:absolute;top:calc(50vh - 120px);z-index:5}.back-container[_ngcontent-%COMP%]{color:#f5f5f5;font-family:Chakra Petch,sans-serif;font-size:x-large;text-align:center;padding-top:10px;padding-bottom:10px;background:rgba(0,0,0,.434);border-radius:5px;position:absolute;bottom:10vh;z-index:5;margin-left:auto;margin-right:auto;width:90vw;max-width:300px}.canvas-main[_ngcontent-%COMP%]{position:relative;top:8px;left:0}.loader[_ngcontent-%COMP%]{border:16px solid #2828284c;border-top:16px solid #212121;border-radius:50%;width:120px;height:120px;animation:_ngcontent-%COMP%_spin 2s linear infinite}@keyframes _ngcontent-%COMP%_spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}"]}),t})();class p${constructor(){this.cameraHeight=1,this.cameraWidth=1,this.isCameraLoaded=!1}}function cn(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{null!=e&&d.util.assert("complex64"!==e.dtype,()=>`${n} does not support complex64 tensors in the CPU backend.`)})}const m$=d.kernel_impls.whereImpl;let g$=(()=>{class t extends d.KernelBackend{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new d.DataStorage(this,(0,d.engine)())}nextDataId(){return t.nextDataId++}write(e,r,s){this.firstUse&&(this.firstUse=!1,(0,d.env)().get("IS_NODE")&&d.backend_util.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:s,refCount:1}),o}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&d.util.isString(s[0])){const i=s.map(a=>d.util.encodeString(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return{dataId:o,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,s,o,i){this.data.set(e,{values:r,dtype:o,refCount:i})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return(0,bs.Z)(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:s}=this.data.get(e);if("complex64"===r){const o=this.readSync(s.real.dataId),i=this.readSync(s.imag.dataId);return d.backend_util.mergeRealAndImagArrays(o,i)}return this.data.get(e).values}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(o=>d.util.decodeString(o));return(0,d.buffer)(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,d.buffer)(e.shape,e.dtype,r)}makeOutput(e,r,s){return(0,d.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(r,s,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);null!=s&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return(0,bs.Z)(function*(){const r=d.util.now();return e(),{kernelMs:d.util.now()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){cn([e],"where");const r=this.readSync(e.dataId);return m$(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return t.nextDataId=0,t})();function Ar(t,n,e){return({inputs:r,attrs:s,backend:o})=>{const{x:i}=r;if(cn(i,t),"string"===i.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=o,u=a.data.get(i.dataId).values,c=d.util.sizeFromShape(i.shape),l=e||i.dtype,h=d.util.getArrayFromDType(l,c);for(let f=0;f<c;++f)h[f]=n(u[f],s);return a.makeTensorInfo(i.shape,l,h)}}function Dd(t,n,e){return({inputs:r,attrs:s,backend:o})=>{const{x:i}=r;if(cn(i,t),"string"===i.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=o,u=a.data.get(i.dataId).values,c=e||i.dtype,l=n(u,c,s);return a.makeTensorInfo(i.shape,c,l)}}(0,d.registerBackend)("cpu",()=>new g$,1);const rS=Ar(d.Elu,t=>t>=0?t:Math.exp(t)-1),y$={kernelName:d.Elu,backendName:"cpu",kernelFunc:rS};function uu(t){const{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const v$={kernelName:d.Identity,backendName:"cpu",kernelFunc:uu};function sS(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{alpha:o}=r;cn([s],"leakyRelu");const i=d.util.sizeFromShape(s.shape),a=e.data.get(s.dataId).values,u=d.util.getTypedArrayFromDType("float32",i);for(let c=0;c<a.length;c++)u[c]=a[c]<0?o*a[c]:a[c];return e.makeTensorInfo(s.shape,"float32",u)}const x$={kernelName:d.LeakyRelu,backendName:"cpu",kernelFunc:sS};function As(t){return(n,e,r,s,o)=>{const i=d.backend_util.assertAndGetBroadcastShape(n,e),a=i.length,u=d.util.computeStrides(i),c=d.util.sizeFromShape(i),l=d.util.getTypedArrayFromDType(o,c),h=n.length,f=e.length,m=d.util.computeStrides(n),y=d.util.computeStrides(e),w=d.backend_util.getBroadcastDims(n,i),E=d.backend_util.getBroadcastDims(e,i);if(w.length+E.length===0)for(let D=0;D<l.length;++D)l[D]=t(r[D%r.length],s[D%s.length]);else for(let D=0;D<l.length;++D){const O=d.util.indexToLoc(D,a,u),W=O.slice(-h);w.forEach(Ae=>W[Ae]=0);const q=d.util.locToIndex(W,h,m),re=O.slice(-f);E.forEach(Ae=>re[Ae]=0);const pe=d.util.locToIndex(re,f,y);l[D]=t(r[q],s[pe])}return[l,i]}}const b$=As((t,n)=>t<0?n*t:t);function oS(t){const{inputs:n,backend:e}=t,{x:r,alpha:s}=n;cn([r,s],"prelu");const o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,[a,u]=b$(r.shape,s.shape,o,i,"float32");return e.makeTensorInfo(u,"float32",a)}const w$={kernelName:d.Prelu,backendName:"cpu",kernelFunc:oS},iS=Ar(d.Relu,t=>Math.max(0,t)),C$={kernelName:d.Relu,backendName:"cpu",kernelFunc:iS},aS=Ar(d.Relu6,t=>Math.min(Math.max(0,t),6)),S$={kernelName:d.Relu6,backendName:"cpu",kernelFunc:aS};function gc(t){return(n,e,r)=>{const s=d.util.getTypedArrayFromDType(e,n.length);for(let o=0;o<n.length;++o)s[o]=t(n[o],r);return s}}const E$=gc(t=>1/(1+Math.exp(-t))),uS=Ar(d.Sigmoid,t=>1/(1+Math.exp(-t))),_$={kernelName:d.Sigmoid,backendName:"cpu",kernelFunc:uS};function Zm(t,n,e,r,s){if("linear"===e)return uu({inputs:{x:n},backend:t});if("relu"===e)return iS({inputs:{x:n},backend:t});if("elu"===e)return rS({inputs:{x:n},backend:t});if("relu6"===e)return aS({inputs:{x:n},backend:t});if("prelu"===e)return oS({inputs:{x:n,alpha:r},backend:t});if("leakyrelu"===e)return sS({inputs:{x:n},backend:t,attrs:{alpha:s}});if("sigmoid"===e)return uS({inputs:{x:n},backend:t});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function fi(t){const{inputs:n,backend:e}=t,{real:r,imag:s}=n,o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",o),imag:e.makeTensorInfo(s.shape,"float32",i)},a}const I$={kernelName:d.Complex,backendName:"cpu",kernelFunc:fi};function Qm(t,n,e="float32"){if("complex64"===e)return fi({inputs:{real:Qm(t,n,"float32"),imag:Qm(t,n,"float32")},backend:t});const r=d.util.makeZerosTypedArray(d.util.sizeFromShape(n),e);return t.makeTensorInfo(n,e,r)}function nl(t){const{inputs:n,backend:e}=t,{input:r}=n,s=e.data.get(r.dataId).complexTensorInfos.real,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const D$={kernelName:d.Real,backendName:"cpu",kernelFunc:nl};function cS(t,n,e,r){if("int32"===r)return[n,"int32",Int32Array.from(t)];if("bool"===r){const s=d.util.toTypedArray([0],e),[o,i]=As((a,u)=>a!==u?1:0)(n,[],t,s,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function yc(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return uu({inputs:{x:s},backend:e});const l=Qm(e,s.shape,s.dtype),h=yc({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),f=fi({inputs:{real:h,imag:l},backend:e});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(h),f}if("complex64"===s.dtype){const l=nl({inputs:{input:s},backend:e}),h=yc({inputs:{x:l},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(l),h}if(!d.util.hasEncodingLoss(s.dtype,o)){const l=uu({inputs:{x:s},backend:e});return{dataId:l.dataId,shape:l.shape,dtype:o}}const i=e.data.get(s.dataId).values,[a,u,c]=cS(i,s.shape,s.dtype,o);return e.makeTensorInfo(a,u,c)}const T$={kernelName:d.Cast,backendName:"cpu",kernelFunc:yc};function Ks(t,n,e,r){return null==e?({inputs:s,backend:o})=>{const{a:i,b:a}=s,u=o;cn([i,a],t);const c=u.data.get(i.dataId).values,l=u.data.get(a.dataId).values,h="string"===i.dtype?d.backend_util.fromUint8ToStringArray(c):c,f="string"===i.dtype?d.backend_util.fromUint8ToStringArray(l):l,m=r||i.dtype,[y,w]=n(i.shape,a.shape,h,f,m);return u.makeTensorInfo(w,m,y)}:({inputs:s,backend:o})=>{const{a:i,b:a}=s,u=o;if("complex64"===i.dtype||"complex64"===a.dtype){const c=yc({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),l=u.data.get(c.dataId),f=l.complexTensorInfos.imag,m=u.data.get(l.complexTensorInfos.real.dataId).values,y=u.data.get(f.dataId).values,w=yc({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),E=u.data.get(w.dataId),O=E.complexTensorInfos.imag,W=u.data.get(E.complexTensorInfos.real.dataId).values,q=u.data.get(O.dataId).values,[re,pe,Ae]=e(i.shape,a.shape,m,y,W,q),Be=u.makeTensorInfo(Ae,"float32",re),Ke=u.makeTensorInfo(Ae,"float32",pe),Ge=fi({inputs:{real:Be,imag:Ke},backend:u});return u.disposeIntermediateTensorInfo(c),u.disposeIntermediateTensorInfo(w),u.disposeIntermediateTensorInfo(Be),u.disposeIntermediateTensorInfo(Ke),Ge}{const c=u.data.get(i.dataId).values,l=u.data.get(a.dataId).values,h=r||i.dtype,[f,m]=n(i.shape,a.shape,c,l,h);return u.makeTensorInfo(m,h,f)}}}function x3(t){return(n,e,r,s,o,i)=>{const a=d.backend_util.assertAndGetBroadcastShape(n,e),u=d.util.sizeFromShape(a),c=a.length,l=d.util.computeStrides(a),h=d.util.getTypedArrayFromDType("float32",u),f=d.util.getTypedArrayFromDType("float32",u),m=d.backend_util.getBroadcastDims(n,a),y=d.backend_util.getBroadcastDims(e,a),w=d.backend_util.mergeRealAndImagArrays(r,s),E=d.backend_util.mergeRealAndImagArrays(o,i),D=n.length,O=d.util.computeStrides(n),W=e.length,q=d.util.computeStrides(e);if(m.length+y.length===0)for(let re=0;re<h.length;re++){const pe=re%w.length,Ae=re%E.length,Be=t(w[2*pe],w[2*pe+1],E[2*Ae],E[2*Ae+1]);h[re]=Be.real,f[re]=Be.imag}else for(let re=0;re<h.length;re++){const pe=d.util.indexToLoc(re,c,l),Ae=pe.slice(-D);m.forEach(yt=>Ae[yt]=0);const Be=d.util.locToIndex(Ae,D,O),Ke=pe.slice(-W);y.forEach(yt=>Ke[yt]=0);const Ge=d.util.locToIndex(Ke,W,q),ft=t(w[2*Be],w[2*Be+1],E[2*Ge],E[2*Ge+1]);h[re]=ft.real,f[re]=ft.imag}return[h,f,a]}}const lS=As((t,n)=>t+n),N$=x3((t,n,e,r)=>({real:t+e,imag:n+r})),Td=Ks(d.Add,lS,N$),k$={kernelName:d.Add,backendName:"cpu",kernelFunc:Td};function zr(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{shape:o}=r,i=d.util.sizeFromShape(s.shape),a=d.util.inferFromImplicitShape(o,i),u=d.util.sizeFromShape(a);d.util.assert(i===u,()=>`The new shape (${a}) has ${u} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);const c=e.data.get(s.dataId);if(null!=c.complexTensorInfos){const h=c.complexTensorInfos.imag;c.complexTensorInfos.real.shape=a,h.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const A$={kernelName:d.Reshape,backendName:"cpu",kernelFunc:zr};function dS(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o}=n,{transposeA:i,transposeB:a}=r;cn([s,o],"matMul");const u=s.shape.length,c=o.shape.length,l=i?s.shape[u-2]:s.shape[u-1],h=a?o.shape[c-1]:o.shape[c-2],f=i?s.shape[u-1]:s.shape[u-2],m=a?o.shape[c-2]:o.shape[c-1],y=s.shape.slice(0,-2),w=o.shape.slice(0,-2),E=d.util.sizeFromShape(y),D=d.util.sizeFromShape(w),W=d.broadcast_util.assertAndGetBroadcastShape(s.shape.slice(0,-2),o.shape.slice(0,-2)).concat([f,m]);d.util.assert(l===h,()=>`Error in matMul: inner shapes (${l}) and (${h}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${i} and transposeB=${a} must match.`);const re=a?[D,m,h]:[D,h,m],pe=zr({inputs:{x:s},backend:e,attrs:{shape:i?[E,l,f]:[E,f,l]}}),Ae=zr({inputs:{x:o},backend:e,attrs:{shape:re}}),Be=i?pe.shape[1]:pe.shape[2],Ke=i?pe.shape[2]:pe.shape[1],Ge=a?Ae.shape[1]:Ae.shape[2],ft=Math.max(E,D),yt=e.data.get(pe.dataId).values,pt=e.data.get(Ae.dataId).values,wt=d.util.computeStrides(pe.shape),vt=d.util.computeStrides(Ae.shape),[xt,Et,mt]=i?[wt[0],1,wt[1]]:[wt[0],wt[1],1],[_t,Ot,Rt]=a?[1,vt[1],vt[0]]:[vt[1],1,vt[0]],zt=Ke*Ge,$t=(0,d.buffer)([ft,Ke,Ge],pe.dtype),jt=$t.values,Ut=e.blockSize;for(let Kt=0;Kt<ft;Kt++)for(let hn=0;hn<Ke;hn+=Ut)for(let bn=0;bn<Ge;bn+=Ut)for(let En=0;En<Be;En+=Ut){const jn=Math.min(hn+Ut,Ke),In=Math.min(bn+Ut,Ge),pr=Math.min(En+Ut,Be);for(let Rr=hn;Rr<jn;Rr++)for(let Or=bn;Or<In;Or++){let Er=0;for(let Tr=En;Tr<pr;Tr++){const Zr=Math.min(Kt,E-1)*xt,jr=Math.min(Kt,D-1)*Rt;Er+=yt[Zr+Rr*Et+Tr*mt]*pt[Tr*_t+Or*Ot+jr]}jt[Kt*zt+(Rr*Ge+Or)]+=Er}}return e.disposeIntermediateTensorInfo(pe),e.disposeIntermediateTensorInfo(Ae),e.makeTensorInfo(W,$t.dtype,$t.values)}const R$={kernelName:d.BatchMatMul,backendName:"cpu",kernelFunc:dS},M$={kernelName:d._FusedMatMul,backendName:"cpu",kernelFunc:function O$(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=n,{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:h}=r;let f,m,y;const w=[];f=dS({inputs:{a:s,b:o},attrs:{transposeA:u,transposeB:c},backend:e}),i&&(m=Td({inputs:{a:f,b:i},backend:e}),w.push(f),f=m),l&&(y=Zm(e,f,l,a,h),w.push(f),f=y);for(const D of w)e.disposeIntermediateTensorInfo(D);return f}};function hS(t){const n=new Float32Array(t.length);for(let e=0;e<t.length;++e)n[e]=Math.abs(t[e]);return n}const F$={kernelName:d.Abs,backendName:"cpu",kernelFunc:t=>{const{x:n}=t.inputs,e=t.backend;cn(n,"abs");let r=new Float32Array(d.util.sizeFromShape(n.shape));return r=hS(e.data.get(n.dataId).values),e.makeOutput(r,n.shape,n.dtype)}},P$=Ar(d.Acos,t=>Math.acos(t)),L$={kernelName:d.Acos,backendName:"cpu",kernelFunc:P$},B$=Ar(d.Acosh,t=>Math.acosh(t)),V$={kernelName:d.Acosh,backendName:"cpu",kernelFunc:B$},W$={kernelName:d.AddN,backendName:"cpu",kernelFunc:function U$(t){const{inputs:n,backend:e}=t,r=n;cn(n,"addN");const s=r.map(a=>e.data.get(a.dataId).values),o=(0,d.buffer)(r[0].shape,r[0].dtype),i=o.values;for(let a=0;a<r.length;a++){const u=s[a];for(let c=0;c<i.length;c++)i[c]+=u[c]}return e.makeTensorInfo(o.shape,o.dtype,o.values)}};function b3(t,n,e,r,s){const o=n.length,i=d.util.sizeFromShape(n),a=d.util.computeStrides(n),u=d.util.computeStrides(s),c=d.util.getTypedArrayFromDType(e,d.util.sizeFromShape(s));for(let l=0;l<i;++l){const h=d.util.indexToLoc(l,o,a),f=new Array(h.length);for(let y=0;y<f.length;y++)f[y]=h[r[y]];c[d.util.locToIndex(f,o,u)]=t[l]}return c}function Go(t){const{inputs:n,attrs:e,backend:r}=t,{x:s}=n,{perm:o}=e;cn(s,"transpose");const a=new Array(s.shape.length);for(let h=0;h<a.length;h++)a[h]=s.shape[o[h]];const c=b3(r.data.get(s.dataId).values,s.shape,s.dtype,o,a);return{dataId:r.write(c,a,s.dtype),shape:a,dtype:s.dtype}}const z$={kernelName:d.Transpose,backendName:"cpu",kernelFunc:Go},j$={kernelName:d.All,backendName:"cpu",kernelFunc:function H$(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;cn(s,"all");const a=d.util.parseAxisParam(o,s.shape);let u=a;const c=d.backend_util.getAxesPermutation(u,s.shape.length);let l=s;null!=c&&(l=Go({inputs:{x:s},backend:e,attrs:{perm:c}}),u=d.backend_util.getInnerMostAxes(u.length,s.shape.length)),d.backend_util.assertAxesAreInnerMostDims("all",u,l.shape.length);const[h,f]=d.backend_util.computeOutAndReduceShapes(l.shape,u),m=d.util.sizeFromShape(f),y=d.util.makeZerosTypedArray(d.util.sizeFromShape(h),l.dtype),w=e.data.get(l.dataId).values;for(let D=0;D<y.length;++D){const O=D*m;let W=w[O];for(let q=0;q<m;++q)W=W&&w[O+q];y[D]=W}null!=c&&e.disposeIntermediateTensorInfo(l);const E=e.makeTensorInfo(h,l.dtype,y);if(i){const O=zr({inputs:{x:E},backend:e,attrs:{shape:d.backend_util.expandShapeToKeepDim(h,a)}});return e.disposeIntermediateTensorInfo(E),O}return E}},K$={kernelName:d.Any,backendName:"cpu",kernelFunc:function G$(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;cn(s,"any");const a=d.util.parseAxisParam(o,s.shape);let u=a;const c=d.backend_util.getAxesPermutation(u,s.shape.length);let l=s;null!=c&&(l=Go({inputs:{x:s},backend:e,attrs:{perm:c}}),u=d.backend_util.getInnerMostAxes(u.length,s.shape.length)),d.backend_util.assertAxesAreInnerMostDims("any",u,l.shape.length);const[h,f]=d.backend_util.computeOutAndReduceShapes(l.shape,u),m=d.util.sizeFromShape(f),y=d.util.makeZerosTypedArray(d.util.sizeFromShape(h),l.dtype),w=e.data.get(l.dataId).values;for(let D=0;D<y.length;++D){const O=D*m;let W=w[O];for(let q=0;q<m;++q)W=W||w[O+q];y[D]=W}null!=c&&e.disposeIntermediateTensorInfo(l);const E=e.makeTensorInfo(h,l.dtype,y);if(i){const O=zr({inputs:{x:E},backend:e,attrs:{shape:d.backend_util.expandShapeToKeepDim(h,a)}});return e.disposeIntermediateTensorInfo(E),O}return E}},q$={kernelName:d.ArgMax,backendName:"cpu",kernelFunc:function X$(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;cn(s,"argMax");let i=d.util.parseAxisParam(o,s.shape);const a=d.backend_util.getAxesPermutation(i,s.shape.length);let u=s;const c=[];null!=a&&(u=Go({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(u),i=d.backend_util.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],d.backend_util.assertAxesAreInnerMostDims("argMax",i,u.shape.length);const[l,h]=d.backend_util.computeOutAndReduceShapes(u.shape,i),f=d.util.sizeFromShape(l),m=d.util.makeZerosTypedArray(f,"int32"),y=d.util.sizeFromShape(h),w=e.data.get(u.dataId).values;for(let E=0;E<m.length;++E){const D=E*y;let O=w[D],W=0;for(let q=0;q<y;++q){const re=w[D+q];re>O&&(O=re,W=q)}m[E]=W}return c.forEach(E=>e.disposeIntermediateTensorInfo(E)),e.makeTensorInfo(l,"int32",m)}},Z$={kernelName:d.ArgMin,backendName:"cpu",kernelFunc:function Y$(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;cn(s,"argMin");let i=d.util.parseAxisParam(o,s.shape);const a=d.backend_util.getAxesPermutation(i,s.shape.length);let u=s;const c=[];null!=a&&(u=Go({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(u),i=d.backend_util.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],d.backend_util.assertAxesAreInnerMostDims("argMin",i,u.shape.length);const[l,h]=d.backend_util.computeOutAndReduceShapes(u.shape,i),f=d.util.sizeFromShape(l),m=d.util.makeZerosTypedArray(f,"int32"),y=d.util.sizeFromShape(h),w=e.data.get(u.dataId).values;for(let E=0;E<m.length;++E){const D=E*y;let O=w[D],W=0;for(let q=0;q<y;++q){const re=w[D+q];re<O&&(O=re,W=q)}m[E]=W}return c.forEach(E=>e.disposeIntermediateTensorInfo(E)),e.makeTensorInfo(l,"int32",m)}},Q$=Ar(d.Asin,t=>Math.asin(t)),J$={kernelName:d.Asin,backendName:"cpu",kernelFunc:Q$},e9=Ar(d.Asinh,t=>Math.asinh(t)),t9={kernelName:d.Asinh,backendName:"cpu",kernelFunc:e9},n9=Ar(d.Atan,t=>Math.atan(t)),r9={kernelName:d.Atan,backendName:"cpu",kernelFunc:n9},s9=As((t,n)=>Math.atan2(t,n)),o9=Ks(d.Atan2,s9),i9={kernelName:d.Atan2,backendName:"cpu",kernelFunc:o9},a9=Ar(d.Atanh,t=>Math.atanh(t)),u9={kernelName:d.Atanh,backendName:"cpu",kernelFunc:a9};function w3(t,n,e,r,s,o){const i=s.strideHeight,a=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,l=s.effectiveFilterHeight,h=s.effectiveFilterWidth,f=s.padInfo.top,m=s.padInfo.left,y="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=(0,d.buffer)(s.outShape,e),E=w.values,D=s.outShape[1]*s.outShape[2]*s.outShape[3],O=s.outShape[2]*s.outShape[3],W=s.outShape[3];for(let q=0;q<s.batchSize;++q){const re=q*D,pe=q*r[0];for(let Ae=0;Ae<s.inChannels;++Ae)for(let Be=0;Be<s.outHeight;++Be){const Ke=Be*i-f,Ge=Math.max(0,Ke),ft=Math.min(s.inHeight,l+Ke),yt=re+Be*O;for(let pt=0;pt<s.outWidth;++pt){const wt=pt*a-m,vt=Math.max(0,wt),xt=Math.min(s.inWidth,h+wt);let Et=y,mt=0,_t=0;for(let Rt=Ge;Rt<ft;Rt+=u){const zt=pe+Rt*r[1];for(let $t=vt;$t<xt;$t+=c){const Ut=t[zt+$t*r[2]+Ae];"max"===o&&Ut>Et?Et=Ut:"avg"===o&&(mt+=Ut,_t++)}if(isNaN(Et))break}E[yt+pt*W+Ae]="avg"===o?mt/_t:Et}}}return w}function fS(t,n,e,r,s=!1,o=!1){const i=(0,d.buffer)(r.outShape,"int32"),a=r.strideHeight,u=r.strideWidth,c=r.dilationHeight,l=r.dilationWidth,h=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.top,y=r.padInfo.left,w=(0,d.buffer)(n,e,t);for(let E=0;E<r.batchSize;++E)for(let D=0;D<r.inChannels;++D)for(let O=0;O<r.outHeight;++O){const W=O*a-m;let q=W;for(;q<0;)q+=c;const re=Math.min(r.inHeight,h+W);for(let pe=0;pe<r.outWidth;++pe){const Ae=pe*u-y;let Be=Ae;for(;Be<0;)Be+=l;const Ke=Math.min(r.inWidth,f+Ae);let Ge=Number.NEGATIVE_INFINITY,ft=-1;for(let yt=q;yt<re;yt+=c){const pt=yt-W;for(let wt=Be;wt<Ke;wt+=l){const vt=wt-Ae,xt=w.get(E,yt,wt,D);xt>Ge&&(Ge=xt,ft=s?o?((E*r.inHeight+yt)*r.inWidth+wt)*r.inChannels+D:(yt*r.inWidth+wt)*r.inChannels+D:pt*f+vt)}}i.set(ft,E,O,pe,D)}}return i}function pS(t,n,e,r,s,o){const i=s.strideDepth,a=s.strideHeight,u=s.strideWidth,c=s.dilationDepth,l=s.dilationHeight,h=s.dilationWidth,f=s.effectiveFilterDepth,m=s.effectiveFilterHeight,y=s.effectiveFilterWidth,w=s.padInfo.front,E=s.padInfo.top,D=s.padInfo.left,O="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,W=(0,d.buffer)(s.outShape,e),q=W.values,re=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],pe=s.outShape[2]*s.outShape[3]*s.outShape[4],Ae=s.outShape[3]*s.outShape[4],Be=s.outShape[4];for(let Ke=0;Ke<s.batchSize;++Ke){const Ge=Ke*re,ft=Ke*r[0];for(let yt=0;yt<s.inChannels;++yt)for(let pt=0;pt<s.outDepth;++pt){const wt=pt*i-w;let vt=wt;for(;vt<0;)vt+=c;const xt=Math.min(s.inDepth,f+wt),Et=Ge+pt*pe;for(let mt=0;mt<s.outHeight;++mt){const _t=mt*a-E;let Ot=_t;for(;Ot<0;)Ot+=l;const Rt=Math.min(s.inHeight,m+_t),zt=Et+mt*Ae;for(let $t=0;$t<s.outWidth;++$t){const jt=$t*u-D;let Ut=jt;for(;Ut<0;)Ut+=h;const Kt=Math.min(s.inWidth,y+jt),hn=zt+$t*Be;let bn=O,En=0,jn=0;for(let pr=vt;pr<xt;pr+=c){const Rr=ft+pr*r[1];for(let Or=Ot;Or<Rt;Or+=l){const Er=Rr+Or*r[2];for(let Tr=Ut;Tr<Kt;Tr+=h){const jr=t[Er+Tr*r[3]+yt];if("max"===o&&jr>bn?bn=jr:"avg"===o&&(En+=jr,jn++),isNaN(bn))break}if(isNaN(bn))break}if(isNaN(bn))break}q[hn+yt]="avg"===o?En/jn:bn}}}}return W}const d9={kernelName:d.AvgPool,backendName:"cpu",kernelFunc:function l9(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;cn(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=r;d.util.assert(d.backend_util.eitherStridesOrDilationsAreOne(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=d.backend_util.computePool2DInfo(s.shape,o,i,1,a,u);let h;if(1===l.filterWidth&&1===l.filterHeight&&d.util.arraysEqual(l.inShape,l.outShape))h=uu({inputs:{x:s},backend:e});else{const f=e.data.get(s.dataId).values,m=d.util.computeStrides(s.shape),y=w3(f,0,s.dtype,m,l,"avg");h=e.makeTensorInfo(l.outShape,s.dtype,y.values)}return h}},f9={kernelName:d.AvgPool3D,backendName:"cpu",kernelFunc:function h9(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:u,dataFormat:c}=r;cn(s,"avgPool3d");const l=d.backend_util.computePool3DInfo(s.shape,o,i,1,a,u,c),f=pS(e.data.get(s.dataId).values,0,s.dtype,d.util.computeStrides(s.shape),l,"avg");return e.makeTensorInfo(f.shape,"float32",f.values)}},m9={kernelName:d.AvgPool3DGrad,backendName:"cpu",kernelFunc:function p9(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,{filterSize:i,strides:a,pad:u,dimRoundingMode:c}=r;cn([s,o],"avgPool3DGrad");const l=d.backend_util.computePool3DInfo(o.shape,i,a,1,u,c),h=l.strideDepth,f=l.strideHeight,m=l.strideWidth,y=l.filterDepth,w=l.filterHeight,E=l.filterWidth,D=l.dilationDepth,O=l.dilationHeight,W=l.dilationWidth,q=l.effectiveFilterDepth,re=l.effectiveFilterHeight,pe=l.effectiveFilterWidth,Ae=q-1-l.padInfo.front,Be=pe-1-l.padInfo.left,Ke=re-1-l.padInfo.top,Ge=(0,d.buffer)(o.shape,"float32"),ft=1/(y*w*E),yt=e.bufferSync(s);for(let pt=0;pt<l.batchSize;++pt)for(let wt=0;wt<l.inChannels;++wt)for(let vt=0;vt<l.inDepth;++vt)for(let xt=0;xt<l.inHeight;++xt)for(let Et=0;Et<l.inWidth;++Et){const mt=vt-Ae,_t=xt-Ke,Ot=Et-Be;let Rt=0;for(let zt=0;zt<q;zt+=D){const $t=(mt+zt)/h;if(!($t<0||$t>=l.outDepth||Math.floor($t)!==$t))for(let jt=0;jt<re;jt+=O){const Ut=(_t+jt)/f;if(!(Ut<0||Ut>=l.outHeight||Math.floor(Ut)!==Ut))for(let Kt=0;Kt<pe;Kt+=W){const hn=(Ot+Kt)/m;hn<0||hn>=l.outWidth||Math.floor(hn)!==hn||(Rt+=yt.get(pt,$t,Ut,hn,wt))}}}Ge.set(Rt*ft,pt,vt,xt,Et,wt)}return e.makeTensorInfo(Ge.shape,Ge.dtype,Ge.values)}},y9={kernelName:d.AvgPoolGrad,backendName:"cpu",kernelFunc:function g9(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o;cn([s,o],"avgPoolGrad");const{filterSize:a,strides:u,pad:c}=r,l=d.backend_util.computePool2DInfo(i.shape,a,u,1,c),h=l.strideHeight,f=l.strideWidth,m=l.filterHeight,y=l.filterWidth,w=l.dilationHeight,E=l.dilationWidth,D=l.effectiveFilterHeight,O=l.effectiveFilterWidth,W=O-1-l.padInfo.left,q=D-1-l.padInfo.top,re=(0,d.buffer)(i.shape,"float32"),pe=1/(m*y),Ae=e.data.get(s.dataId).values,Be=(0,d.buffer)(s.shape,"float32",Ae);for(let Ke=0;Ke<l.batchSize;++Ke)for(let Ge=0;Ge<l.inChannels;++Ge)for(let ft=0;ft<l.inHeight;++ft)for(let yt=0;yt<l.inWidth;++yt){const pt=ft-q,wt=yt-W;let vt=0;for(let xt=0;xt<D;xt+=w){const Et=(pt+xt)/h;if(!(Et<0||Et>=l.outHeight||Math.floor(Et)!==Et))for(let mt=0;mt<O;mt+=E){const _t=(wt+mt)/f;_t<0||_t>=l.outWidth||Math.floor(_t)!==_t||(vt+=Be.get(Ke,Et,_t,Ge))}}re.set(vt*pe,Ke,ft,yt,Ge)}return e.makeTensorInfo(re.shape,re.dtype,re.values)}},x9={kernelName:d.FusedBatchNorm,backendName:"cpu",kernelFunc:function v9(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,scale:o,offset:i,mean:a,variance:u}=n;d.util.assert(a.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),d.util.assert(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),d.util.assert(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),cn([s,a,u,o,i],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const l=e.data.get(s.dataId).values,h=e.data.get(a.dataId).values,f=e.data.get(u.dataId).values,m=o?e.data.get(o.dataId).values:new Float32Array([1]),y=i?e.data.get(i.dataId).values:new Float32Array([0]),w=new Float32Array(l.length),E=y.length,D=m.length,O=f.length,W=h.length;let q=0,re=0,pe=0,Ae=0;for(let Be=0;Be<l.length;++Be)w[Be]=y[q++]+(l[Be]-h[re++])*m[pe++]/Math.sqrt(f[Ae++]+c),q>=E&&(q=0),re>=W&&(re=0),pe>=D&&(pe=0),Ae>=O&&(Ae=0);return e.makeTensorInfo(s.shape,s.dtype,w)}};function mS(t,n,e,r,s){const o=d.slice_util.isSliceContinous(r,n,e),i=d.util.sizeFromShape(e),a=d.util.computeStrides(r);if(o){const h=d.slice_util.computeFlatOffset(n,a);return"string"===s?t.slice(h,h+i):t.subarray(h,h+i)}const u="string"===s?d.backend_util.fromUint8ToStringArray(t):t,c=(0,d.buffer)(r,s,u),l=(0,d.buffer)(e,s);for(let h=0;h<l.size;++h){const f=l.indexToLoc(h),m=f.map((y,w)=>y+n[w]);l.set(c.get(...m),...f)}return"string"===s?d.backend_util.fromStringArrayToUint8(l.values):l.values}function rl(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,size:i}=r;cn(s,"slice");const[a,u]=d.slice_util.parseSliceParams(s,o,i);d.slice_util.assertParamsValid(s,a,u);const l=mS(e.data.get(s.dataId).values,a,u,s.shape,s.dtype);return e.makeTensorInfo(u,s.dtype,l)}const b9={kernelName:d.Slice,backendName:"cpu",kernelFunc:rl},C9={kernelName:d.BatchToSpaceND,backendName:"cpu",kernelFunc:function w9(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,crops:i}=r;cn([s],"batchToSpaceND");const a=o.reduce((D,O)=>D*O),u=d.backend_util.getReshaped(s.shape,o,a),c=d.backend_util.getPermuted(u.length,o.length),l=d.backend_util.getReshapedPermuted(s.shape,o,a),h=d.backend_util.getSliceBeginCoords(i,o.length),f=d.backend_util.getSliceSize(l,i,o.length),m=zr({inputs:{x:s},backend:e,attrs:{shape:u}}),y=Go({inputs:{x:m},backend:e,attrs:{perm:c}}),w=zr({inputs:{x:y},backend:e,attrs:{shape:l}}),E=rl({inputs:{x:w},backend:e,attrs:{begin:h,size:f}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(w),E}};function C3(t,n,e,r,s){const o=d.util.sizeFromShape(r),i=d.util.makeZerosTypedArray(s,e);for(let a=0;a<t.length;a++){const u=t[a];if(u<0)throw new Error("Input x must be non-negative!");u>=s||(i[u]+=o>0?n[a]:1)}return i}function gS(t,n,e,r=!1){const s=t.shape[0],o=t.shape[1],i=(0,d.buffer)([s,e],n.dtype);for(let a=0;a<s;a++)for(let u=0;u<o;u++){const c=t.get(a,u);if(c<0)throw new Error("Input x must be non-negative!");c>=e||i.set(r?1:n.size>0?i.get(a,c)+n.get(a,u):i.get(a,c)+1,a,c)}return i}const E9={kernelName:d.Bincount,backendName:"cpu",kernelFunc:function S9(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i}=r,c=C3(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}},I9={kernelName:d.BroadcastArgs,backendName:"cpu",kernelFunc:function _9(t){const{inputs:n,backend:e}=t,{s0:r,s1:s}=n,o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values,a=d.backend_util.assertAndGetBroadcastShape(Array.from(o),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},yS=gc(t=>Math.ceil(t)),D9=Dd(d.Ceil,yS),T9={kernelName:d.Ceil,backendName:"cpu",kernelFunc:D9},N9=Ar(d.ClipByValue,(t,n)=>t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t),k9={kernelName:d.ClipByValue,backendName:"cpu",kernelFunc:N9},R9={kernelName:d.ComplexAbs,backendName:"cpu",kernelFunc:t=>{const{x:n}=t.inputs,e=t.backend,r=new Float32Array(d.util.sizeFromShape(n.shape)),s=e.data.get(n.dataId),i=s.complexTensorInfos.imag,a=e.data.get(s.complexTensorInfos.real.dataId).values,u=e.data.get(i.dataId).values;for(let c=0;c<a.length;c++)r[c]=Math.hypot(a[c],u[c]);return e.makeOutput(r,n.shape,"float32")}};function vS(t,n,e,r){const s=d.util.getArrayFromDType(e,d.util.sizeFromShape(n));if(r&&"string"!==e){let o=0;t.forEach(i=>{const a=d.util.sizeFromShape(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;t.forEach(i=>{const a="string"===e?d.backend_util.fromUint8ToStringArray(i.vals):i.vals;let u=0;for(let c=0;c<i.shape[0];++c){const l=c*n[1]+o;for(let h=0;h<i.shape[1];++h)s[l+h]=a[u++]}o+=i.shape[1]})}return s}function Nd(t){const{inputs:n,backend:e}=t,{input:r}=n,s=e.data.get(r.dataId).complexTensorInfos.imag,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}const O9={kernelName:d.Imag,backendName:"cpu",kernelFunc:Nd};function kd(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r,o=d.util.parseAxisParam(s,n[0].shape)[0],i=n.map(w=>w.shape);d.backend_util.assertParamsConsistent(i,o);let a=d.backend_util.computeOutShape(n.map(w=>w.shape),o);if(0===d.util.sizeFromShape(a))return e.makeTensorInfo(a,n[0].dtype,[]);const u=n.filter(w=>d.util.sizeFromShape(w.shape)>0);if(1===u.length)return uu({inputs:{x:u[0]},backend:e});if("complex64"===u[0].dtype){const w=u.map(q=>nl({inputs:{input:q},backend:e})),E=u.map(q=>Nd({inputs:{input:q},backend:e})),D=kd({inputs:w,backend:e,attrs:{axis:o}}),O=kd({inputs:E,backend:e,attrs:{axis:o}}),W=fi({inputs:{real:D,imag:O},backend:e});return w.forEach(q=>e.disposeIntermediateTensorInfo(q)),E.forEach(q=>e.disposeIntermediateTensorInfo(q)),e.disposeIntermediateTensorInfo(D),e.disposeIntermediateTensorInfo(O),W}const c=u.map(w=>{const D=[-1,d.util.sizeFromShape(w.shape.slice(o))];return zr({inputs:{x:w},backend:e,attrs:{shape:D}})}),l=c.map(w=>({vals:e.data.get(w.dataId).values,shape:w.shape}));a=d.backend_util.computeOutShape(c.map(w=>w.shape),1);const f=vS(l,a,n[0].dtype,1===c[0].shape[0]),m=d.backend_util.computeOutShape(u.map(w=>w.shape),o),y=e.makeTensorInfo(m,n[0].dtype,f);return c.forEach(w=>e.disposeIntermediateTensorInfo(w)),y}const M9={kernelName:d.Concat,backendName:"cpu",kernelFunc:kd};function xS(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dataFormat:u,dilations:c,dimRoundingMode:l}=r;cn([s,o],"conv2d");const h=d.backend_util.convertConv2DDataFormat(u),f=d.backend_util.computeConv2DInfo(s.shape,o.shape,i,c,a,l,!1,h),m=f.filterHeight,y=f.filterWidth,w=f.dilationHeight,E=f.dilationWidth,D=f.padInfo.left,O=f.padInfo.top,W="channelsLast"===f.dataFormat,q=new d.TensorBuffer(f.outShape,s.dtype),re=d.util.computeStrides(s.shape),pe=d.util.computeStrides(o.shape),Ae=re[0],Be=W?re[1]:re[2],Ke=W?re[2]:1,Ge=W?1:re[1],ft=q.strides[0],yt=W?q.strides[1]:q.strides[2],pt=W?q.strides[2]:1,wt=W?1:q.strides[1],vt=e.data.get(s.dataId).values,xt=e.data.get(o.dataId).values,Et=q.values;for(let mt=0;mt<f.batchSize;++mt){const _t=mt*Ae,Ot=mt*ft;for(let Rt=0;Rt<f.outHeight;++Rt){const zt=Ot+Rt*yt,$t=Rt*f.strideHeight-O;for(let jt=0;jt<m;++jt){const Ut=$t+jt*w;if(Ut<0||Ut>=f.inHeight)continue;const Kt=jt*pe[0],hn=_t+Ut*Be;for(let bn=0;bn<f.outWidth;++bn){const En=zt+bn*pt,jn=bn*f.strideWidth-D;for(let In=0;In<y;++In){const pr=jn+In*E;if(pr<0||pr>=f.inWidth)continue;const Or=hn+pr*Ke;let Er=Kt+In*pe[1];for(let Tr=0;Tr<f.inChannels;++Tr){const Zr=vt[Or+Tr*Ge];for(let jr=0;jr<f.outChannels;++jr)Et[En+jr*wt]+=Zr*xt[Er+jr];Er+=f.outChannels}}}}}}return e.makeTensorInfo(q.shape,q.dtype,Et)}const $9={kernelName:d.Conv2D,backendName:"cpu",kernelFunc:xS},P9={kernelName:d.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function F9(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,dataFormat:u,dimRoundingMode:c,filterShape:l}=r;cn([s,o],"conv2dBackpropFilter");const h=d.backend_util.convertConv2DDataFormat(u),f=d.backend_util.computeConv2DInfo(s.shape,l,i,1,a,c,!1,h),{strideHeight:m,strideWidth:y,filterHeight:w,filterWidth:E}=f,D="channelsLast"===f.dataFormat,O=new d.TensorBuffer(f.filterShape,"float32"),W=f.padInfo.left,q=f.padInfo.top,re=e.data.get(s.dataId).values,pe=e.data.get(o.dataId).values,Ae=new d.TensorBuffer(s.shape,s.dtype,re),Be=new d.TensorBuffer(o.shape,o.dtype,pe);for(let Ke=0;Ke<w;++Ke){const Ge=Math.max(0,Math.ceil((q-Ke)/m)),ft=Math.min(f.outHeight,(f.inHeight+q-Ke)/m);for(let yt=0;yt<E;++yt){const pt=Math.max(0,Math.ceil((W-yt)/y)),wt=Math.min(f.outWidth,(f.inWidth+W-yt)/y);for(let vt=0;vt<f.inChannels;++vt)for(let xt=0;xt<f.outChannels;++xt){let Et=0;for(let mt=0;mt<f.batchSize;++mt)for(let _t=Ge;_t<ft;++_t){const Ot=Ke+_t*m-q;for(let Rt=pt;Rt<wt;++Rt){const zt=yt+Rt*y-W;Et+=D?Ae.get(mt,Ot,zt,vt)*Be.get(mt,_t,Rt,xt):Ae.get(mt,vt,Ot,zt)*Be.get(mt,xt,_t,Rt)}}O.set(Et,Ke,yt,vt,xt)}}}return e.makeTensorInfo(O.shape,O.dtype,O.values)}},B9={kernelName:d.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function L9(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{inputShape:i,strides:a,pad:u,dataFormat:c,dimRoundingMode:l}=r;cn([s,o],"conv2dBackpropInput");const h=d.util.computeStrides(o.shape),f=d.util.computeStrides(s.shape);let m=d.backend_util.convertConv2DDataFormat(c);const y=d.backend_util.computeConv2DInfo(i,o.shape,a,1,u,l,!1,m),w=new d.TensorBuffer(y.inShape,"float32"),E=w.values,D=e.data.get(s.dataId).values,O=e.data.get(o.dataId).values,[W,q,re]=h,{batchSize:pe,filterHeight:Ae,filterWidth:Be,inChannels:Ke,inHeight:Ge,inWidth:ft,outChannels:yt,outHeight:pt,outWidth:wt,strideHeight:vt,strideWidth:xt}=y;m=y.dataFormat;const Et=Ae-1-y.padInfo.top,mt=Be-1-y.padInfo.left,_t="channelsLast"===m,Ot=w.strides[0],Rt=_t?w.strides[1]:w.strides[2],zt=_t?w.strides[2]:1,$t=_t?1:w.strides[1],jt=f[0],Ut=_t?f[1]:f[2],Kt=_t?f[2]:1,hn=_t?1:f[1];for(let bn=0;bn<pe;++bn)for(let En=0;En<Ke;++En)for(let jn=0;jn<Ge;++jn){const In=jn-Et,pr=Math.max(0,Math.ceil(In/vt)),Rr=Math.min(pt,(Ae+In)/vt);for(let Or=0;Or<ft;++Or){const Er=Or-mt,Tr=Math.max(0,Math.ceil(Er/xt)),Zr=Math.min(wt,(Be+Er)/xt);let jr=0;for(let Vs=pr;Vs<Rr;++Vs){const Ko=Vs*vt-In;for(let so=Tr;so<Zr;++so){const yi=jt*bn+Ut*Vs+Kt*so,Xo=W*(Ae-1-Ko)+q*(Be-1-(so*xt-Er))+re*En;for(let vi=0;vi<yt;++vi)jr+=D[yi+hn*vi]*O[Xo+vi]}}E[Ot*bn+Rt*jn+zt*Or+$t*En]=jr}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}},U9={kernelName:d.Conv3D,backendName:"cpu",kernelFunc:function V9(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:u}=r;cn([s,o],"conv3d");const c=d.backend_util.computeConv3DInfo(s.shape,o.shape,i,u,a),{filterDepth:l,filterHeight:h,filterWidth:f,dilationDepth:m,dilationHeight:y,dilationWidth:w,padInfo:E}=c,D=E.front,O=E.left,W=E.top,q=new d.TensorBuffer(c.outShape,s.dtype),re=e.data.get(s.dataId).values,pe=e.data.get(o.dataId).values,Ae=q.values,Be=d.util.computeStrides(s.shape),Ke=d.util.computeStrides(o.shape);for(let Ge=0;Ge<c.batchSize;++Ge){const ft=Ge*Be[0],yt=Ge*q.strides[0];for(let pt=0;pt<c.outDepth;++pt){const wt=yt+pt*q.strides[1],vt=pt*c.strideDepth-D;for(let xt=0;xt<l;++xt){const Et=vt+xt*m;if(Et<0||Et>=c.inDepth)continue;const mt=xt*Ke[0],_t=ft+Et*Be[1];for(let Ot=0;Ot<c.outHeight;++Ot){const Rt=wt+Ot*q.strides[2],zt=Ot*c.strideHeight-W;for(let $t=0;$t<h;++$t){const jt=zt+$t*y;if(jt<0||jt>=c.inHeight)continue;const Ut=mt+$t*Ke[1],Kt=_t+jt*Be[2];for(let hn=0;hn<c.outWidth;++hn){const bn=Rt+hn*c.outChannels,En=hn*c.strideWidth-O;for(let jn=0;jn<f;++jn){const In=En+jn*w;if(In<0||In>=c.inWidth)continue;const Rr=Kt+In*c.inChannels;let Or=Ut+jn*Ke[2];for(let Er=0;Er<c.inChannels;++Er){const Tr=re[Rr+Er];for(let Zr=0;Zr<c.outChannels;++Zr)Ae[bn+Zr]+=Tr*pe[Or+Zr];Or+=c.outChannels}}}}}}}}return e.makeTensorInfo(q.shape,q.dtype,q.values)}},z9={kernelName:d.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function W9(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,filterShape:u}=r;cn([s,o],"conv3dBackpropFilterV2");const c=d.util.computeStrides(s.shape),l=d.util.computeStrides(o.shape),h=d.backend_util.computeConv3DInfo(s.shape,u,i,1,a),f=h.strideDepth,m=h.strideHeight,y=h.strideWidth,w=h.filterDepth,E=h.filterHeight,D=h.filterWidth,O=new d.TensorBuffer(h.filterShape,"float32"),W=O.values,[q,re,pe,Ae]=O.strides,Be=e.data.get(o.dataId).values,[Ke,Ge,ft,yt]=l,pt=e.data.get(s.dataId).values,[wt,vt,xt,Et]=c,mt=h.padInfo.front,_t=h.padInfo.left,Ot=h.padInfo.top;for(let Rt=0;Rt<w;++Rt){const zt=Math.max(0,Math.ceil((mt-Rt)/f)),$t=Math.min(h.outDepth,(h.inDepth+mt-Rt)/f),jt=Rt*q;for(let Ut=0;Ut<E;++Ut){const Kt=Math.max(0,Math.ceil((Ot-Ut)/m)),hn=Math.min(h.outHeight,(h.inHeight+Ot-Ut)/m),bn=Ut*re+jt;for(let En=0;En<D;++En){const jn=Math.max(0,Math.ceil((_t-En)/y)),In=Math.min(h.outWidth,(h.inWidth+_t-En)/y),pr=En*pe+bn;for(let Rr=0;Rr<h.inChannels;++Rr){const Or=Rr*Ae+pr;for(let Er=0;Er<h.outChannels;++Er){let Tr=0;for(let Zr=0;Zr<h.batchSize;++Zr){const jr=Zr*wt,gi=Zr*Ke;for(let Vs=zt;Vs<$t;++Vs){const so=(Rt+Vs*f-mt)*vt+jr,cu=Vs*Ge+gi;for(let yi=Kt;yi<hn;++yi){const vi=(Ut+yi*m-Ot)*xt+so,ca=yi*ft+cu;for(let Oa=jn;Oa<In;++Oa)Tr+=pt[(En+Oa*y-_t)*Et+vi+Rr]*Be[Oa*yt+ca+Er]}}}W[Or+Er]=Tr}}}}}return e.makeTensorInfo(O.shape,O.dtype,O.values)}},j9={kernelName:d.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function H9(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{pad:i,strides:a,inputShape:u}=r;cn([s],"conv3dBackpropInputV2");const c=d.util.computeStrides(s.shape),l=d.util.computeStrides(o.shape),h=d.backend_util.computeConv3DInfo(u,o.shape,a,1,i),f=new d.TensorBuffer(h.inShape,"float32"),m=f.values,[y,w,E,D]=f.strides,O=e.data.get(s.dataId).values,[W,q,re,pe]=c,Ae=e.data.get(o.dataId).values,[Be,Ke,Ge,ft]=l,{batchSize:yt,filterDepth:pt,filterHeight:wt,filterWidth:vt,inChannels:xt,inDepth:Et,inHeight:mt,inWidth:_t,outChannels:Ot,outDepth:Rt,outHeight:zt,outWidth:$t,strideDepth:jt,strideHeight:Ut,strideWidth:Kt}=h,hn=pt-1-h.padInfo.front,bn=wt-1-h.padInfo.top,En=vt-1-h.padInfo.left;for(let jn=0;jn<yt;++jn)for(let In=0;In<xt;++In)for(let pr=0;pr<Et;++pr){const Rr=pr-hn,Or=Math.max(0,Math.ceil(Rr/jt)),Er=Math.min(Rt,(pt+Rr)/jt);for(let Tr=0;Tr<mt;++Tr){const Zr=Tr-bn,jr=Math.max(0,Math.ceil(Zr/Ut)),gi=Math.min(zt,(wt+Zr)/Ut);for(let Vs=0;Vs<_t;++Vs){const Ko=Vs-En,so=Math.max(0,Math.ceil(Ko/Kt)),cu=Math.min($t,(vt+Ko)/Kt);let yi=0;for(let Xo=Or;Xo<Er;++Xo){const vi=Xo*jt-Rr;for(let ca=jr;ca<gi;++ca){const Oa=ca*Ut-Zr;for(let lu=so;lu<cu;++lu){const Kd=W*jn+q*Xo+re*ca+pe*lu,Cg=Be*(pt-1-vi)+Ke*(wt-1-Oa)+Ge*(vt-1-(lu*Kt-Ko))+ft*In;for(let cl=0;cl<Ot;++cl)yi+=O[Kd+cl]*Ae[Cg+cl]}}}m[y*jn+w*pr+E*Tr+D*Vs+In]=yi}}}return e.makeTensorInfo(f.shape,f.dtype,f.values)}},G9=Ar(d.Cos,t=>Math.cos(t)),K9={kernelName:d.Cos,backendName:"cpu",kernelFunc:G9},X9=Ar(d.Cosh,t=>Math.cosh(t)),q9={kernelName:d.Cosh,backendName:"cpu",kernelFunc:X9},Z9={kernelName:d.CropAndResize,backendName:"cpu",kernelFunc:function Y9(t){const{inputs:n,backend:e,attrs:r}=t,{image:s,boxes:o,boxInd:i}=n,{cropSize:a,method:u,extrapolationValue:c}=r,[l,h,f,m]=s.shape,y=o.shape[0],[w,E]=a,D=(0,d.buffer)([y,w,E,m],"float32"),O=e.data.get(o.dataId).values,W=e.data.get(i.dataId).values,q=e.data.get(s.dataId).values,re=d.util.computeStrides(s.shape),pe=d.util.computeStrides(D.shape);for(let Ae=0;Ae<y;Ae++){const Be=4*Ae,Ke=O[Be],Ge=O[Be+1],ft=O[Be+2],yt=O[Be+3],pt=W[Ae];if(pt>=l)continue;const wt=w>1?(ft-Ke)*(h-1)/(w-1):0,vt=E>1?(yt-Ge)*(f-1)/(E-1):0;for(let xt=0;xt<w;xt++){const Et=w>1?Ke*(h-1)+xt*wt:.5*(Ke+ft)*(h-1);if(Et<0||Et>h-1)for(let mt=0;mt<E;mt++)for(let _t=0;_t<m;_t++)D.values[_t+mt*pe[2]+xt*pe[1]+Ae*pe[0]]=c;else if("bilinear"===u){const mt=Math.floor(Et),_t=Math.ceil(Et),Ot=Et-mt;for(let Rt=0;Rt<E;Rt++){const zt=E>1?Ge*(f-1)+Rt*vt:.5*(Ge+yt)*(f-1);if(zt<0||zt>f-1){for(let Kt=0;Kt<m;Kt++)D.values[Kt+Rt*pe[2]+xt*pe[1]+Ae*pe[0]]=c;continue}const $t=Math.floor(zt),jt=Math.ceil(zt),Ut=zt-$t;for(let Kt=0;Kt<m;Kt++){let hn=Kt+$t*re[2]+mt*re[1]+pt*re[0];const bn=q[hn];hn=Kt+jt*re[2]+mt*re[1]+pt*re[0];const En=q[hn];hn=Kt+$t*re[2]+_t*re[1]+pt*re[0];const jn=q[hn];hn=Kt+jt*re[2]+_t*re[1]+pt*re[0];const In=q[hn],pr=bn+(En-bn)*Ut;hn=Kt+Rt*pe[2]+xt*pe[1]+Ae*pe[0],D.values[hn]=pr+(jn+(In-jn)*Ut-pr)*Ot}}}else for(let mt=0;mt<E;++mt){const _t=E>1?Ge*(f-1)+mt*vt:.5*(Ge+yt)*(f-1);if(_t<0||_t>f-1){for(let zt=0;zt<m;zt++)D.values[zt+mt*pe[2]+xt*pe[1]+Ae*pe[0]]=c;continue}const Ot=Math.round(_t),Rt=Math.round(Et);for(let zt=0;zt<m;zt++)D.values[zt+mt*pe[2]+xt*pe[1]+Ae*pe[0]]=q[zt+Ot*re[2]+Rt*re[1]+pt*re[0]]}}}return e.makeTensorInfo(D.shape,D.dtype,D.values)}},J9={kernelName:d.Cumprod,backendName:"cpu",kernelFunc:function Q9(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;cn(s,"cumprod");const u=d.backend_util.getAxesPermutation([o],s.shape.length);let c=s;null!=u&&(c=Go({inputs:{x:s},backend:e,attrs:{perm:u}}));const l=d.backend_util.getInnerMostAxes(1,s.shape.length)[0];if(l!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${l}`);const h=(0,d.upcastType)(c.dtype,"int32"),f=d.util.makeOnesTypedArray(d.util.sizeFromShape(c.shape),h),m=e.data.get(c.dataId).values,y=c.shape[c.shape.length-1],w=a?(D,O)=>D+y-O-1:(D,O)=>D+O;for(let D=0;D<m.length;D+=y)for(let O=0;O<y;O++){const W=w(D,O);if(0===O)f[W]=i?1:m[W];else{const q=w(D,O-1);f[W]=i?m[q]*f[q]:m[W]*f[q]}}const E=e.makeTensorInfo(c.shape,h,f);if(null!=u){const O=Go({inputs:{x:E},backend:e,attrs:{perm:d.backend_util.getUndoAxesPermutation(u)}});return e.disposeIntermediateTensorInfo(E),e.disposeIntermediateTensorInfo(c),O}return E}},tF={kernelName:d.Cumsum,backendName:"cpu",kernelFunc:function eF(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;cn(s,"cumsum");const u=d.backend_util.getAxesPermutation([o],s.shape.length);let c=s;null!=u&&(c=Go({inputs:{x:s},backend:e,attrs:{perm:u}}));const l=d.backend_util.getInnerMostAxes(1,s.shape.length)[0];if(l!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${l}`);const h=(0,d.upcastType)(c.dtype,"int32"),f=d.util.makeZerosTypedArray(d.util.sizeFromShape(c.shape),h),m=e.data.get(c.dataId).values,y=c.shape[c.shape.length-1],w=a?(D,O)=>D+y-O-1:(D,O)=>D+O;for(let D=0;D<m.length;D+=y)for(let O=0;O<y;O++){const W=w(D,O);if(0===O)f[W]=i?0:m[W];else{const q=w(D,O-1);f[W]=i?m[q]+f[q]:m[W]+f[q]}}const E=e.makeTensorInfo(c.shape,h,f);if(null!=u){const O=Go({inputs:{x:E},backend:e,attrs:{perm:d.backend_util.getUndoAxesPermutation(u)}});return e.disposeIntermediateTensorInfo(E),e.disposeIntermediateTensorInfo(c),O}return E}},rF={kernelName:d.DenseBincount,backendName:"cpu",kernelFunc:function nF(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const l=C3(e.data.get(s.dataId).values,e.data.get(o.dataId).values,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,l)}if(2===s.shape.length){const l=gS(e.bufferSync(s),e.bufferSync(o),i,a);return e.makeTensorInfo(l.shape,o.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},oF={kernelName:d.DepthToSpace,backendName:"cpu",kernelFunc:function sF(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockSize:o,dataFormat:i}=r;d.util.assert("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const a=s.shape[0],u=s.shape[1],c=s.shape[2],l=s.shape[3],h=u*o,f=c*o,m=l/(o*o),y=e.data.get(s.dataId).values,w=new Float32Array(a*h*f*m);let E=0;for(let D=0;D<a;++D)for(let O=0;O<h;++O){const W=Math.floor(O/o),q=O%o;for(let re=0;re<f;++re){const pe=Math.floor(re/o),Be=(q*o+re%o)*m;for(let Ke=0;Ke<m;++Ke)w[E++]=y[Ke+Be+l*(pe+c*(W+u*D))]}}return e.makeTensorInfo([a,h,f,m],s.dtype,w)}};function bS(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:u,dimRoundingMode:c}=r;cn([s,o],"depthwiseConv2DNative");const l=d.util.computeStrides(s.shape),h=d.util.computeStrides(o.shape);let f=u;null==f&&(f=[1,1]),d.util.assert(d.backend_util.eitherStridesOrDilationsAreOne(i,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${f}'`);const m=d.backend_util.computeConv2DInfo(s.shape,o.shape,i,f,a,c,!0),{filterHeight:y,filterWidth:w,dilationHeight:E,dilationWidth:D,padInfo:O}=m,W=O.left,q=O.top,re=m.outChannels/m.inChannels,pe=new d.TensorBuffer(m.outShape,s.dtype),Ae=e.data.get(s.dataId).values,Be=e.data.get(o.dataId).values,Ke=pe.values;for(let Ge=0;Ge<m.batchSize;++Ge){const ft=Ge*l[0],yt=Ge*pe.strides[0];for(let pt=0;pt<m.outHeight;++pt){const wt=yt+pt*pe.strides[1],vt=pt*m.strideHeight-q;for(let xt=0;xt<y;++xt){const Et=vt+xt*E;if(Et<0||Et>=m.inHeight)continue;const mt=xt*h[0],_t=ft+Et*l[1];for(let Ot=0;Ot<m.outWidth;++Ot){const Rt=wt+Ot*pe.strides[2],zt=Ot*m.strideWidth-W;for(let $t=0;$t<w;++$t){const jt=zt+$t*D;if(jt<0||jt>=m.inWidth)continue;const Kt=_t+jt*m.inChannels;let hn=Rt,bn=mt+$t*h[1];for(let En=0;En<m.inChannels;++En){const jn=Ae[Kt+En];for(let In=0;In<re;++In)Ke[hn+In]+=jn*Be[bn+In];hn+=re,bn+=re}}}}}}return e.makeTensorInfo(pe.shape,pe.dtype,pe.values)}const iF={kernelName:d.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:bS},uF={kernelName:d.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function aF(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,dilations:a,pad:u,dimRoundingMode:c,filterShape:l}=r;cn([s,o],"depthwiseConv2dNativeBackpropFilter");const h=d.backend_util.computeConv2DInfo(s.shape,l,i,a,u,c,!0),{strideHeight:f,strideWidth:m,filterHeight:y,filterWidth:w}=h,E=new d.TensorBuffer(h.filterShape,"float32"),D=h.padInfo.left,O=h.padInfo.top,W=h.outChannels/h.inChannels,q=e.data.get(s.dataId).values,re=new d.TensorBuffer(s.shape,s.dtype,q),pe=e.data.get(o.dataId).values,Ae=new d.TensorBuffer(o.shape,o.dtype,pe);for(let Be=0;Be<y;++Be){const Ke=Math.max(0,Math.ceil((O-Be)/f)),Ge=Math.min(h.outHeight,(h.inHeight+O-Be)/f);for(let ft=0;ft<w;++ft){const yt=Math.max(0,Math.ceil((D-ft)/m)),pt=Math.min(h.outWidth,(h.inWidth+D-ft)/m);for(let wt=0;wt<h.outChannels;++wt){const vt=Math.trunc(wt/W),xt=wt%W;let Et=0;for(let mt=0;mt<h.batchSize;++mt)for(let _t=Ke;_t<Ge;++_t){const Ot=Be+_t*f-O;for(let Rt=yt;Rt<pt;++Rt)Et+=re.get(mt,Ot,ft+Rt*m-D,vt)*Ae.get(mt,_t,Rt,wt)}E.set(Et,Be,ft,vt,xt)}}}return e.makeTensorInfo(E.shape,E.dtype,E.values)}},lF={kernelName:d.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function cF(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{strides:i,dilations:a,pad:u,dimRoundingMode:c,inputShape:l}=r;cn([s,o],"depthwiseConv2DNativeBackpropInput");const h=d.util.computeStrides(s.shape),f=d.util.computeStrides(o.shape),m=d.backend_util.computeConv2DInfo(l,o.shape,i,a,u,c,!0),y=new d.TensorBuffer(m.inShape,"float32"),w=y.values,[E,D,O]=y.strides,W=e.data.get(s.dataId).values,[q,re,pe]=h,Ae=e.data.get(o.dataId).values,[Be,Ke,Ge]=f,{batchSize:ft,filterHeight:yt,filterWidth:pt,inChannels:wt,inHeight:vt,inWidth:xt,outChannels:Et,outHeight:mt,outWidth:_t,strideHeight:Ot,strideWidth:Rt}=m,zt=yt-1-m.padInfo.top,$t=pt-1-m.padInfo.left,jt=Et/wt;for(let Ut=0;Ut<ft;++Ut)for(let Kt=0;Kt<wt;++Kt)for(let hn=0;hn<vt;++hn){const bn=hn-zt,En=Math.max(0,Math.ceil(bn/Ot)),jn=Math.min(mt,(yt+bn)/Ot);for(let In=0;In<xt;++In){const pr=In-$t,Rr=Math.max(0,Math.ceil(pr/Rt)),Or=Math.min(_t,(pt+pr)/Rt);let Er=0;for(let Tr=En;Tr<jn;++Tr){const Zr=Tr*Ot-bn;for(let jr=Rr;jr<Or;++jr){const Vs=q*Ut+re*Tr+pe*jr,Ko=Be*(yt-1-Zr)+Ke*(pt-1-(jr*Rt-pr))+Ge*Kt;for(let so=0;so<jt;++so)Er+=W[Vs+(Kt*jt+so)]*Ae[Ko+so]}}w[E*Ut+D*hn+O*In+Kt]=Er}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},hF={kernelName:d.Diag,backendName:"cpu",kernelFunc:function dF(t){const{inputs:n,backend:e}=t,{x:r}=n,s=d.util.sizeFromShape(r.shape),o=e.data.get(r.dataId).values,i=(0,d.buffer)([s,s],r.dtype),a=i.values;for(let c=0;c<o.length;c++)a[c*s+c]=o[c];const u=[...r.shape,...r.shape];return e.makeTensorInfo(u,i.dtype,i.values)}},fF={kernelName:d.Dilation2D,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:s}=t,{strides:o,pad:i,dilations:a}=e,u=n,c=u.data.get(r.dataId).values,l=r.shape.length,h=u.data.get(s.dataId).values,f=s.shape.length,{batchSize:m,inHeight:y,inWidth:w,inChannels:E,outHeight:D,outWidth:O,padInfo:W,strideHeight:q,strideWidth:re,filterHeight:pe,filterWidth:Ae,dilationHeight:Be,dilationWidth:Ke,outShape:Ge}=d.backend_util.computeDilation2DInfo(r.shape,s.shape,o,i,"NHWC",a),ft=d.util.sizeFromShape(Ge),yt=Ge.length,pt=d.util.getArrayFromDType(r.dtype,ft);for(let vt=0;vt<m;++vt)for(let xt=0;xt<D;++xt){const Et=xt*q-W.top;for(let mt=0;mt<O;++mt){const _t=mt*re-W.left;for(let Ot=0;Ot<E;++Ot){let Rt=Number.MIN_SAFE_INTEGER;for(let $t=0;$t<pe;++$t){const jt=Et+$t*Be;if(jt>=0&&jt<y)for(let Ut=0;Ut<Ae;++Ut){const Kt=_t+Ut*Ke;if(Kt>=0&&Kt<w){const hn=d.util.locToIndex([vt,jt,Kt,Ot],l,d.util.computeStrides(r.shape)),bn=d.util.locToIndex([$t,Ut,Ot],f,d.util.computeStrides(s.shape)),En=c[hn]+h[bn];En>Rt&&(Rt=En)}}}pt[d.util.locToIndex([vt,xt,mt,Ot],yt,d.util.computeStrides(Ge))]=Rt}}}return{dataId:u.write(d.util.toTypedArray(pt,r.dtype),Ge,r.dtype),shape:Ge,dtype:r.dtype}}},pF={kernelName:d.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:s,dy:o}=t,{strides:i,pad:a,dilations:u}=e,c=n,l=d.util.toNestedArray(r.shape,c.data.get(r.dataId).values),h=d.util.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:f,inHeight:m,inWidth:y,inChannels:w,outHeight:E,outWidth:D,padInfo:O,strideHeight:W,strideWidth:q,filterHeight:re,filterWidth:pe,dilationHeight:Ae,dilationWidth:Be,outShape:Ke}=d.backend_util.computeDilation2DInfo(r.shape,s.shape,i,a,"NHWC",u);d.util.assert(o.rank===Ke.length,()=>`Error in ${d.Dilation2DBackpropFilter}, dy must have the same rank as output ${Ke.length}, but got ${o.rank}`);const Ge=d.util.toNestedArray(Ke,c.data.get(o.dataId).values),ft=d.util.makeZerosNestedTypedArray(s.shape,s.dtype);for(let pt=0;pt<f;++pt)for(let wt=0;wt<E;++wt){const vt=wt*W-O.top;for(let xt=0;xt<D;++xt){const Et=xt*q-O.left;for(let mt=0;mt<w;++mt){let _t=Number.MIN_SAFE_INTEGER,Ot=0,Rt=0;for(let zt=0;zt<re;++zt){const $t=vt+zt*Ae;if($t>=0&&$t<m)for(let jt=0;jt<pe;++jt){const Ut=Et+jt*Be;if(Ut>=0&&Ut<y){const Kt=l[pt][$t][Ut][mt]+h[zt][jt][mt];Kt>_t&&(_t=Kt,Ot=zt,Rt=jt)}}}ft[Ot][Rt][mt]+=Ge[pt][wt][xt][mt]}}}return{dataId:c.write(d.util.toTypedArray(ft,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},mF={kernelName:d.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,filter:s,dy:o}=t,{strides:i,pad:a,dilations:u}=e,c=n,l=d.util.toNestedArray(r.shape,c.data.get(r.dataId).values),h=d.util.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:f,inHeight:m,inWidth:y,inChannels:w,outHeight:E,outWidth:D,padInfo:O,strideHeight:W,strideWidth:q,filterHeight:re,filterWidth:pe,dilationHeight:Ae,dilationWidth:Be,outShape:Ke}=d.backend_util.computeDilation2DInfo(r.shape,s.shape,i,a,"NHWC",u);d.util.assert(o.rank===Ke.length,()=>`Error in ${d.Dilation2DBackpropInput}, dy must have the same rank as output ${Ke.length}, but got ${o.rank}`);const Ge=d.util.toNestedArray(Ke,c.data.get(o.dataId).values),ft=d.util.makeZerosNestedTypedArray(r.shape,r.dtype);for(let pt=0;pt<f;++pt)for(let wt=0;wt<E;++wt){const vt=wt*W-O.top;for(let xt=0;xt<D;++xt){const Et=xt*q-O.left;for(let mt=0;mt<w;++mt){let _t=Number.MIN_SAFE_INTEGER,Ot=vt<0?0:vt,Rt=Et<0?0:Et;for(let zt=0;zt<re;++zt){const $t=vt+zt*Ae;if($t>=0&&$t<m)for(let jt=0;jt<pe;++jt){const Ut=Et+jt*Be;if(Ut>=0&&Ut<y){const Kt=l[pt][$t][Ut][mt]+h[zt][jt][mt];Kt>_t&&(_t=Kt,Ot=$t,Rt=Ut)}}}ft[pt][Ot][Rt][mt]+=Ge[pt][wt][xt][mt]}}}return{dataId:c.write(d.util.toTypedArray(ft,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},S3=As((t,n)=>t*n),gF=x3((t,n,e,r)=>({real:t*e-n*r,imag:t*r+n*e})),Jm=Ks(d.Multiply,S3,gF),yF={kernelName:d.Multiply,backendName:"cpu",kernelFunc:Jm};function Cf(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;let a;cn(s,"sum"),a="bool"===s.dtype?yc({inputs:{x:s},backend:e,attrs:{dtype:"int32"}}):uu({inputs:{x:s},backend:e});const u=a.shape.length,c=d.util.parseAxisParam(o,a.shape),l=d.backend_util.getAxesPermutation(c,u);let h=c,f=a;null!=l&&(f=Go({inputs:{x:a},backend:e,attrs:{perm:l}}),h=d.backend_util.getInnerMostAxes(h.length,u)),d.backend_util.assertAxesAreInnerMostDims("sum",h,f.shape.length);const[m,y]=d.backend_util.computeOutAndReduceShapes(f.shape,h);let E=Qm(e,m,d.backend_util.upcastType(f.dtype,"int32"));const D=d.util.sizeFromShape(y),O=e.data.get(E.dataId).values,W=e.data.get(f.dataId).values;for(let q=0;q<O.length;++q){const re=q*D;let pe=0;for(let Ae=0;Ae<D;++Ae)pe+=W[re+Ae];O[q]=pe}if(i){const re=E;E=zr({inputs:{x:E},backend:e,attrs:{shape:d.backend_util.expandShapeToKeepDim(E.shape,c)}}),e.disposeIntermediateTensorInfo(re)}return e.disposeIntermediateTensorInfo(a),null!=l&&e.disposeIntermediateTensorInfo(f),E}const vF={kernelName:d.Sum,backendName:"cpu",kernelFunc:Cf},bF={kernelName:d.Einsum,backendName:"cpu",kernelFunc:function xF(t){const{inputs:n,backend:e,attrs:r}=t,{equation:s}=r,o=n,{allDims:i,summedDims:a,idDims:u}=d.backend_util.decodeEinsumEquation(s,o.length);d.backend_util.checkEinsumDimSizes(i.length,u,o);const{path:c,steps:l}=d.backend_util.getEinsumComputePath(a,u),h=l.length;let f=null,m=i.length;const y=[];for(let w=0;w<h;++w){for(const E of l[w]){const{permutationIndices:D,expandDims:O}=d.backend_util.getEinsumPermutation(m,u[E]);let W;d.backend_util.isIdentityPermutation(D)?W=o[E]:(W=Go({inputs:{x:o[E]},backend:e,attrs:{perm:D}}),y.push(W));const q=W.shape.slice();for(let re=0;re<O.length;++re)q.splice(O[re],0,1);d.util.arraysEqual(W.shape,q)||(W=zr({inputs:{x:W},backend:e,attrs:{shape:q}}),y.push(W)),null===f?f=W:(f=Jm({inputs:{a:W,b:f},backend:e}),y.push(f))}w<h-1&&(c[w]>=0&&(f=Cf({inputs:{x:f},backend:e,attrs:{axis:c[w]-(i.length-m),keepDims:!1}}),y.push(f)),m--)}for(const w of y)w!==f&&e.disposeIntermediateTensorInfo(w);return f}},CF={kernelName:d.EluGrad,backendName:"cpu",kernelFunc:function wF(t){const{inputs:n,backend:e}=t,{dy:r,y:s}=n;cn([r,s],"eluGrad");const o=new Float32Array(d.util.sizeFromShape(s.shape)),i=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values;for(let u=0;u<i.length;++u){const c=i[u];o[u]=c>=1?a[u]:a[u]*(c+1)}return e.makeTensorInfo(s.shape,"float32",o)}},wS=As((t,n)=>t===n?1:0),CS=Ks(d.Equal,wS,null,"bool"),SF={kernelName:d.Equal,backendName:"cpu",kernelFunc:CS},EF=d.backend_util.ERF_P,_F=d.backend_util.ERF_A1,IF=d.backend_util.ERF_A2,DF=d.backend_util.ERF_A3,TF=d.backend_util.ERF_A4,NF=d.backend_util.ERF_A5,kF=Ar(d.Erf,t=>{const n=Math.sign(t),e=Math.abs(t),r=1/(1+EF*e);return n*(1-((((NF*r+TF)*r+DF)*r+IF)*r+_F)*r*Math.exp(-e*e))}),AF={kernelName:d.Erf,backendName:"cpu",kernelFunc:kF},SS=gc(t=>Math.exp(t)),ES=Dd(d.Exp,SS,"float32"),RF={kernelName:d.Exp,backendName:"cpu",kernelFunc:ES};function eg(t){const{inputs:n,backend:e,attrs:r}=t,{input:s}=n,{dim:o}=r,i=s.shape.length,a=s.shape.slice();let u=o;return o<0&&(d.util.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+o+1),a.splice(u,0,1),zr({inputs:{x:s},backend:e,attrs:{shape:a}})}const OF={kernelName:d.ExpandDims,backendName:"cpu",kernelFunc:eg},_S=gc(t=>Math.expm1(t)),MF=Dd(d.Expm1,_S),$F={kernelName:d.Expm1,backendName:"cpu",kernelFunc:MF},FF=As((t,n)=>t/n),E3=Ks(d.RealDiv,FF),_3={kernelName:d.RealDiv,backendName:"cpu",kernelFunc:E3},IS=As((t,n)=>t-n),PF=x3((t,n,e,r)=>({real:t-e,imag:n-r})),I3=Ks(d.Sub,IS,PF),LF={kernelName:d.Sub,backendName:"cpu",kernelFunc:I3};function DS(t,n,e){const r=t.shape,s=r[0],o=r[1],i=e.data.get(t.dataId),a=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,c=[s,o],l=d.util.sizeFromShape(c),h=d.util.getTypedArrayFromDType("float32",l),f=d.util.getTypedArrayFromDType("float32",l);for(let E=0;E<s;E++){const D=rl({inputs:{x:a},backend:e,attrs:{begin:[E,0],size:[1,o]}}),O=rl({inputs:{x:u},backend:e,attrs:{begin:[E,0],size:[1,o]}}),W=fi({inputs:{real:D,imag:O},backend:e}),{real:q,imag:re}=BF(W,n,e),pe=d.backend_util.mergeRealAndImagArrays(q,re);for(let Ae=0;Ae<o;Ae++){const Be=d.backend_util.getComplexWithIndex(pe,Ae);h[E*o+Ae]=Be.real,f[E*o+Ae]=Be.imag}e.disposeIntermediateTensorInfo(D),e.disposeIntermediateTensorInfo(O),e.disposeIntermediateTensorInfo(W)}const m=e.makeTensorInfo(c,"float32",h),y=e.makeTensorInfo(c,"float32",f),w=fi({inputs:{real:m,imag:y},backend:e});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),w}function BF(t,n,e){const r=d.util.sizeFromShape(t.shape),s=e.data.get(t.dataId),o=e.data.get(s.complexTensorInfos.real.dataId).values,i=e.data.get(s.complexTensorInfos.imag.dataId).values;if(function VF(t){return 0==(t&t-1)}(r)){const a=D3(o,i,r,n,e),u=[t.shape[0],t.shape[1]];if(n){const c=e.makeTensorInfo(u,"float32",a.real),l=e.makeTensorInfo(u,"float32",a.imag),h=e.makeTensorInfo([],"float32",d.util.createScalarValue(r,"float32")),f=uu({inputs:{x:h},backend:e}),m=_3.kernelFunc({inputs:{a:c,b:h},backend:e}),y=_3.kernelFunc({inputs:{a:l,b:f},backend:e}),w=e.data.get(m.dataId).values,E=e.data.get(y.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),{real:w,imag:E}}return a}{const u=function UF(t,n,e){const r=new Float32Array(2*n);for(let s=0;s<n;s++){let o=0,i=0;for(let a=0;a<n;a++){const u=d.backend_util.exponent(s*a,n,e),c=d.backend_util.getComplexWithIndex(t,a);o+=c.real*u.real-c.imag*u.imag,i+=c.real*u.imag+c.imag*u.real}e&&(o/=n,i/=n),d.backend_util.assignToTypedArray(r,o,i,s)}return r}(d.backend_util.mergeRealAndImagArrays(o,i),r,n);return d.backend_util.splitRealAndImagArrays(u)}}function D3(t,n,e,r,s){if(1===e)return{real:t,imag:n};const o=d.backend_util.mergeRealAndImagArrays(t,n),i=e/2,a=d.backend_util.complexWithEvenIndex(o),u=a.real,c=a.imag,l=[u.length],h=s.makeTensorInfo(l,"float32",u),f=s.makeTensorInfo(l,"float32",c),m=fi({inputs:{real:h,imag:f},backend:s}),y=d.backend_util.complexWithOddIndex(o),w=y.real,E=y.imag,D=[w.length],O=s.makeTensorInfo(D,"float32",w),W=s.makeTensorInfo(D,"float32",E),q=fi({inputs:{real:O,imag:W},backend:s}),re=D3(u,c,i,r,s),pe=re.real,Ae=re.imag,Be=[pe.length],Ke=s.makeTensorInfo(Be,"float32",pe),Ge=s.makeTensorInfo(Be,"float32",Ae),ft=fi({inputs:{real:Ke,imag:Ge},backend:s}),yt=D3(w,E,i,r,s),pt=yt.real,wt=yt.imag,vt=[pt.length],xt=s.makeTensorInfo(vt,"float32",pt),Et=s.makeTensorInfo(vt,"float32",wt),mt=fi({inputs:{real:xt,imag:Et},backend:s}),_t=d.backend_util.exponents(e,r),Ot=[_t.real.length],Rt=s.makeTensorInfo(Ot,"float32",_t.real),zt=s.makeTensorInfo(Ot,"float32",_t.imag),$t=fi({inputs:{real:Rt,imag:zt},backend:s}),jt=Jm({inputs:{a:$t,b:mt},backend:s}),Ut=Td({inputs:{a:ft,b:jt},backend:s}),Kt=I3({inputs:{a:ft,b:jt},backend:s}),hn=nl({inputs:{input:Ut},backend:s}),bn=nl({inputs:{input:Kt},backend:s}),En=Nd({inputs:{input:Ut},backend:s}),jn=Nd({inputs:{input:Kt},backend:s}),In=kd({inputs:[hn,bn],backend:s,attrs:{axis:0}}),pr=kd({inputs:[En,jn],backend:s,attrs:{axis:0}}),Rr=s.data.get(In.dataId).values,Or=s.data.get(pr.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(m),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(Ke),s.disposeIntermediateTensorInfo(Ge),s.disposeIntermediateTensorInfo(ft),s.disposeIntermediateTensorInfo(xt),s.disposeIntermediateTensorInfo(Et),s.disposeIntermediateTensorInfo(mt),s.disposeIntermediateTensorInfo(Rt),s.disposeIntermediateTensorInfo(zt),s.disposeIntermediateTensorInfo($t),s.disposeIntermediateTensorInfo(jt),s.disposeIntermediateTensorInfo(Ut),s.disposeIntermediateTensorInfo(Kt),s.disposeIntermediateTensorInfo(hn),s.disposeIntermediateTensorInfo(En),s.disposeIntermediateTensorInfo(bn),s.disposeIntermediateTensorInfo(jn),s.disposeIntermediateTensorInfo(In),s.disposeIntermediateTensorInfo(pr),{real:Rr,imag:Or}}const zF={kernelName:d.FFT,backendName:"cpu",kernelFunc:function WF(t){const{inputs:n,backend:e}=t,{input:r}=n,s=d.util.sizeFromShape(r.shape),o=r.shape[r.shape.length-1],a=zr({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),u=DS(a,!1,e),c=zr({inputs:{x:u},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),c}};function T3(t){const{backend:n,attrs:e}=t,{shape:r,value:s,dtype:o}=e,i=o||d.util.inferDtype(s),a=d.util.getArrayFromDType(i,d.util.sizeFromShape(r));return function jF(t,n,e){t.fill(n)}(a,s),n.makeTensorInfo(r,i,a)}const HF={kernelName:d.Fill,backendName:"cpu",kernelFunc:T3},GF={kernelName:d.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{image:r}=t,s=e,o=d.util.getTypedArrayFromDType(r.dtype,d.util.sizeFromShape(r.shape)),[i,a,u,c]=r.shape,l=s.data.get(r.dataId).values;for(let f=0;f<i;f++){const m=f*u*a*c;for(let y=0;y<a;y++){const w=y*(u*c);for(let E=0;E<u;E++){const D=E*c;for(let O=0;O<c;O++){const W=Math.round(u-E-1),q=m+w+D+O;let re=l[q];W>=0&&W<u&&(re=l[m+w+W*c+O]),o[q]=re}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},TS=gc(t=>Math.floor(t)),KF=Dd(d.Floor,TS),XF={kernelName:d.Floor,backendName:"cpu",kernelFunc:KF},qF=As((t,n)=>Math.floor(t/n)),YF=Ks(d.FloorDiv,qF,null,"int32"),ZF={kernelName:d.FloorDiv,backendName:"cpu",kernelFunc:YF},JF={kernelName:d.FusedConv2D,backendName:"cpu",kernelFunc:function QF(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:u,pad:c,dataFormat:l,dilations:h,dimRoundingMode:f,activation:m,leakyreluAlpha:y}=r;let w=xS({inputs:{x:s,filter:o},backend:e,attrs:{strides:u,pad:c,dataFormat:l,dilations:h,dimRoundingMode:f}});if(i){const E=w;if("NCHW"===l&&1===i.shape.length&&1!==i.shape[0]){const D=zr({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});w=Td({inputs:{a:w,b:D},backend:e}),e.disposeIntermediateTensorInfo(D)}else w=Td({inputs:{a:w,b:i},backend:e});e.disposeIntermediateTensorInfo(E)}if(m){const E=w;if("NCHW"===l&&"prelu"===m&&1===a.shape.length&&1!==a.shape[0]){const D=zr({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});w=Zm(e,w,m,D,y),e.disposeIntermediateTensorInfo(D)}else w=Zm(e,w,m,a,y);e.disposeIntermediateTensorInfo(E)}return w}},tP={kernelName:d.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function eP(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:u,pad:c,dataFormat:l,dilations:h,dimRoundingMode:f,activation:m,leakyreluAlpha:y}=r;let w=bS({inputs:{x:s,filter:o},backend:e,attrs:{strides:u,pad:c,dataFormat:l,dilations:h,dimRoundingMode:f}});if(i){const E=w;w=Td({inputs:{a:w,b:i},backend:e}),e.disposeIntermediateTensorInfo(E)}if(m){const E=w;w=Zm(e,w,m,a,y),e.disposeIntermediateTensorInfo(E)}return w}};function NS(t,n,e,r,s,o,i,a,u){const c=(0,d.buffer)([r,o],e);for(let l=0;l<r;l++){const h=[];let f=0;for(let m=0;m<s;m++){const y=t[l*s+m];f+=y*i[m],h.push(y)}if(f<0||f>=u/o)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let m=0;m<o;m++)c.values[l*o+m]=n.get(...n.indexToLoc(f*o+m))}return c}const rP={kernelName:d.GatherNd,backendName:"cpu",kernelFunc:function nP(t){const{inputs:n,backend:e}=t,{params:r,indices:s}=n,o=d.util.sizeFromShape(r.shape),i=s.shape,a=i[i.length-1],[u,c,l,h]=d.backend_util.prepareAndValidate(r,s);if(0===c)return e.makeTensorInfo(u,r.dtype,[]);const y=NS(e.data.get(s.dataId).values,e.bufferSync(r),r.dtype,c,a,l,h,r.shape,o);return e.makeTensorInfo(u,r.dtype,y.values)}};function kS(t,n,e){const r=(0,d.buffer)(e,t.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),c=n.locToIndex([i[0],i[2]]);i[2]=n.values[c];const l=t.locToIndex(i);0<=l&&l<t.values.length&&(r.values[s]=t.values[l])}return r}const oP={kernelName:d.GatherV2,backendName:"cpu",kernelFunc:function sP(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,indices:o}=n,{axis:i,batchDims:a}=r;cn([s,o],"gatherV2");const u=d.util.parseAxisParam(i,s.shape)[0],c=e.data.get(o.dataId).values,l=s.shape[u];for(let q=0;q<c.length;++q){const re=c[q];d.util.assert(re<=l-1&&re>=0,()=>`GatherV2: the index value ${re} is not in [0, ${l-1}]`)}let h=a;null==a&&(h=0);const f=d.util.sizeFromShape(o.shape),m=d.backend_util.segment_util.collectGatherOpShapeInfo(s,o,u,h),y=zr({inputs:{x:s},backend:e,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),w=zr({inputs:{x:o},backend:e,attrs:{shape:[m.batchSize,f/m.batchSize]}}),E=[m.batchSize,m.outerSize,f/m.batchSize,m.sliceSize],D=e.bufferSync(w),W=kS(e.bufferSync(y),D,E);return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(w),e.makeTensorInfo(m.outputShape,W.dtype,W.values)}},AS=As((t,n)=>t>n?1:0),iP=Ks(d.Greater,AS,null,"bool"),aP={kernelName:d.Greater,backendName:"cpu",kernelFunc:iP},RS=As((t,n)=>t>=n?1:0),uP=Ks(d.GreaterEqual,RS,null,"bool"),cP={kernelName:d.GreaterEqual,backendName:"cpu",kernelFunc:uP},dP={kernelName:d.IFFT,backendName:"cpu",kernelFunc:function lP(t){const{inputs:n,backend:e}=t,{input:r}=n,s=d.util.sizeFromShape(r.shape),o=r.shape[r.shape.length-1],a=zr({inputs:{x:r},backend:e,attrs:{shape:[s/o,o]}}),u=DS(a,!0,e),c=zr({inputs:{x:u},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),c}},hP=Ar(d.IsFinite,t=>Number.isFinite(t)?1:0,"bool"),fP={kernelName:d.IsFinite,backendName:"cpu",kernelFunc:hP},pP=Ar(d.IsInf,t=>Math.abs(t)===1/0?1:0,"bool"),mP={kernelName:d.IsInf,backendName:"cpu",kernelFunc:pP},gP=Ar(d.IsNan,t=>Number.isNaN(t)?1:0,"bool"),yP={kernelName:d.IsNan,backendName:"cpu",kernelFunc:gP},OS=As((t,n)=>t<n?1:0),vP=Ks(d.Less,OS,null,"bool"),xP={kernelName:d.Less,backendName:"cpu",kernelFunc:vP},MS=As((t,n)=>t<=n?1:0),bP=Ks(d.LessEqual,MS,null,"bool"),wP={kernelName:d.LessEqual,backendName:"cpu",kernelFunc:bP};function $S(t,n,e){const r=(n-t)/(e-1),s=d.util.makeZerosTypedArray(e,"float32");s[0]=t;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}const SP={kernelName:d.LinSpace,backendName:"cpu",kernelFunc:function CP(t){const{backend:n,attrs:e}=t,{start:r,stop:s,num:o}=e,i=$S(r,s,o);return n.makeTensorInfo([i.length],"float32",i)}},FS=gc(t=>Math.log(t)),EP=Dd(d.Log,FS),_P={kernelName:d.Log,backendName:"cpu",kernelFunc:EP},IP=Ar(d.Log1p,t=>Math.log1p(t)),DP={kernelName:d.Log1p,backendName:"cpu",kernelFunc:IP},TP=As((t,n)=>t&&n),NP=Ks(d.LogicalAnd,TP,null,"bool"),kP={kernelName:d.LogicalAnd,backendName:"cpu",kernelFunc:NP},AP=Ar(d.LogicalNot,t=>t?0:1,"bool"),RP={kernelName:d.LogicalNot,backendName:"cpu",kernelFunc:AP},OP=As((t,n)=>t||n),MP=Ks(d.LogicalOr,OP,null,"bool"),$P={kernelName:d.LogicalOr,backendName:"cpu",kernelFunc:MP},PP={kernelName:d.LRN,backendName:"cpu",kernelFunc:function FP(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{depthRadius:o,bias:i,alpha:a,beta:u}=r;cn(s,"LRN");const c=s.shape[3],l=c-1,h=e.data.get(s.dataId).values,f=d.util.sizeFromShape(s.shape),m=new Float32Array(f);function y(w){const E=w%c;let D=w-E+Math.max(0,E-o);const O=w-E+Math.min(E+o,l);let W=0;for(;D<=O;D++){const q=h[D];W+=q*q}return W}for(let w=0;w<f;w++){const E=y(w),D=h[w]*Math.pow(i+a*E,-u);m[w]=D}return e.makeTensorInfo(s.shape,s.dtype,m)}},BP={kernelName:d.LRNGrad,backendName:"cpu",kernelFunc:function LP(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,y:o,dy:i}=n,{depthRadius:a,bias:u,alpha:c,beta:l}=r;cn(i,"LRNGrad");const h=d.util.sizeFromShape(i.shape),f=i.shape[3],m=e.data.get(i.dataId).values,y=e.data.get(s.dataId).values,w=e.data.get(o.dataId).values,E=new Float32Array(h),D=h;for(let O=0;O<D;O++){const W=O%f,q=O-W+Math.max(0,W-a),re=O-W+Math.min(f,W+a+1);let pe=0;for(let Ae=q;Ae<re;Ae++)pe+=Math.pow(y[Ae],2);pe=c*pe+u;for(let Ae=q;Ae<re;Ae++){let Be=-2*c*l*y[Ae]*w[O]/pe;O===Ae&&(Be+=Math.pow(pe,-l)),Be*=m[O],E[Ae]+=Be}}return e.makeTensorInfo(i.shape,s.dtype,E)}};function PS(t,n,e,r){const s=d.util.getTypedArrayFromDType(r,d.util.sizeFromShape(e));for(let o=0;o<s.length;++o){const i=o*n;let a=t[i];for(let u=0;u<n;++u){const c=t[i+u];(Number.isNaN(c)||c>a)&&(a=c)}s[o]=a}return s}function LS(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reductionIndices:o,keepDims:i}=r,a=e;let u=s.shape;const c=u.length,l=d.util.parseAxisParam(o,u);let h=l;const f=d.backend_util.getAxesPermutation(h,c);let m=a.data.get(s.dataId).values;if(null!=f){const q=new Array(c);for(let re=0;re<q.length;re++)q[re]=u[f[re]];m=b3(m,u,s.dtype,f,q),h=d.backend_util.getInnerMostAxes(h.length,c),u=q}cn(s,"max"),d.backend_util.assertAxesAreInnerMostDims("max",h,c);const[y,w]=d.backend_util.computeOutAndReduceShapes(u,h),D=PS(m,d.util.sizeFromShape(w),y,s.dtype),O=a.write(D,y,s.dtype);let W=y;return i&&(W=d.backend_util.expandShapeToKeepDim(y,l)),{dataId:O,shape:W,dtype:s.dtype}}const VP={kernelName:d.Max,backendName:"cpu",kernelFunc:LS},BS=As((t,n)=>Math.max(t,n)),UP=Ks(d.Maximum,BS),WP={kernelName:d.Maximum,backendName:"cpu",kernelFunc:UP},HP={kernelName:d.MaxPool,backendName:"cpu",kernelFunc:function zP(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;cn(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=r;d.util.assert(d.backend_util.eitherStridesOrDilationsAreOne(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=d.backend_util.computePool2DInfo(s.shape,o,i,1,a,u);let h;if(1===l.filterWidth&&1===l.filterHeight&&d.util.arraysEqual(l.inShape,l.outShape))h=uu({inputs:{x:s},backend:e});else{const f=e.data.get(s.dataId).values,m=d.util.computeStrides(s.shape),y=w3(f,0,s.dtype,m,l,"max");h=e.makeTensorInfo(l.outShape,s.dtype,y.values)}return h}},GP={kernelName:d.MaxPool3D,backendName:"cpu",kernelFunc:function jP(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:u,dataFormat:c}=r;cn(s,"maxPool3d");const l=d.backend_util.computePool3DInfo(s.shape,o,i,1,a,u,c),f=pS(e.data.get(s.dataId).values,0,s.dtype,d.util.computeStrides(s.shape),l,"max");return e.makeTensorInfo(f.shape,"float32",f.values)}},XP={kernelName:d.MaxPool3DGrad,backendName:"cpu",kernelFunc:function KP(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,{filterSize:i,strides:a,pad:u,dimRoundingMode:c}=r;cn([s,o],"maxPool3DGrad");const l=d.backend_util.computePool3DInfo(o.shape,i,a,1,u,c),f=function c9(t,n){const e=(0,d.buffer)(n.outShape,"int32"),r=n.strideDepth,s=n.strideHeight,o=n.strideWidth,i=n.dilationDepth,a=n.dilationHeight,u=n.dilationWidth,c=n.effectiveFilterDepth,l=n.effectiveFilterHeight,h=n.effectiveFilterWidth,f=n.padInfo.front,m=n.padInfo.top,y=n.padInfo.left;for(let w=0;w<n.batchSize;++w)for(let E=0;E<n.inChannels;++E)for(let D=0;D<n.outDepth;++D){const O=D*r-f;let W=O;for(;W<0;)W+=i;const q=Math.min(n.inDepth,c+O);for(let re=0;re<n.outHeight;++re){const pe=re*s-m;let Ae=pe;for(;Ae<0;)Ae+=a;const Be=Math.min(n.inHeight,l+pe);for(let Ke=0;Ke<n.outWidth;++Ke){const Ge=Ke*o-y;let ft=Ge;for(;ft<0;)ft+=u;const yt=Math.min(n.inWidth,h+Ge);let pt=Number.NEGATIVE_INFINITY,wt=-1;for(let vt=W;vt<q;vt+=i){const xt=vt-O;for(let Et=Ae;Et<Be;Et+=a){const mt=Et-pe;for(let _t=ft;_t<yt;_t+=u){const Ot=_t-Ge,Rt=t.get(w,vt,Et,_t,E);Rt>=pt&&(pt=Rt,wt=xt*l*h+mt*l+Ot)}}}e.set(wt,w,D,re,Ke,E)}}}return e}(e.bufferSync(o),l),m=l.strideDepth,y=l.strideHeight,w=l.strideWidth,E=l.dilationDepth,D=l.dilationHeight,O=l.dilationWidth,W=l.effectiveFilterDepth,q=l.effectiveFilterHeight,re=l.effectiveFilterWidth,pe=W-1-l.padInfo.front,Ae=re-1-l.padInfo.left,Be=q-1-l.padInfo.top,Ke=(0,d.buffer)(o.shape,"float32"),Ge=e.bufferSync(s);for(let ft=0;ft<l.batchSize;++ft)for(let yt=0;yt<l.inChannels;++yt)for(let pt=0;pt<l.inDepth;++pt)for(let wt=0;wt<l.inHeight;++wt)for(let vt=0;vt<l.inWidth;++vt){const xt=pt-pe,Et=wt-Be,mt=vt-Ae;let _t=0;for(let Ot=0;Ot<W;Ot+=E){const Rt=(xt+Ot)/m;if(!(Rt<0||Rt>=l.outDepth||Math.floor(Rt)!==Rt))for(let zt=0;zt<q;zt+=D){const $t=(Et+zt)/y;if(!($t<0||$t>=l.outHeight||Math.floor($t)!==$t))for(let jt=0;jt<re;jt+=O){const Ut=(mt+jt)/w;if(Ut<0||Ut>=l.outWidth||Math.floor(Ut)!==Ut)continue;const bn=W*q*re-1-f.get(ft,Rt,$t,Ut,yt)===Ot*q*re+zt*re+jt?1:0;0!==bn&&(_t+=Ge.get(ft,Rt,$t,Ut,yt)*bn)}}}Ke.set(_t,ft,pt,wt,vt,yt)}return e.makeTensorInfo(Ke.shape,Ke.dtype,Ke.values)}},YP={kernelName:d.MaxPoolGrad,backendName:"cpu",kernelFunc:function qP(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o,output:i}=n,a=o;cn([o,i],"maxPoolGrad");const{filterSize:u,strides:c,pad:l,dimRoundingMode:h}=r,f=d.backend_util.computePool2DInfo(a.shape,u,c,1,l,h),m=e.data.get(a.dataId).values,y=(0,d.buffer)(f.outShape,a.dtype,fS(m,a.shape,a.dtype,f).values),w=f.strideHeight,E=f.strideWidth,D=f.dilationHeight,O=f.dilationWidth,W=f.effectiveFilterHeight,q=f.effectiveFilterWidth,re=q-1-f.padInfo.left,pe=W-1-f.padInfo.top,Ae=(0,d.buffer)(a.shape,"float32"),Be=e.data.get(s.dataId).values,Ke=(0,d.buffer)(s.shape,"float32",Be);for(let Ge=0;Ge<f.batchSize;++Ge)for(let ft=0;ft<f.inChannels;++ft)for(let yt=0;yt<f.inHeight;++yt)for(let pt=0;pt<f.inWidth;++pt){const wt=yt-pe,vt=pt-re;let xt=0;for(let Et=0;Et<W;Et+=D){const mt=(wt+Et)/w;if(!(mt<0||mt>=f.outHeight||Math.floor(mt)!==mt))for(let _t=0;_t<q;_t+=O){const Ot=(vt+_t)/E;if(Ot<0||Ot>=f.outWidth||Math.floor(Ot)!==Ot)continue;const $t=W*q-1-y.get(Ge,mt,Ot,ft)===Et*q+_t?1:0;0!==$t&&(xt+=Ke.get(Ge,mt,Ot,ft)*$t)}}Ae.set(xt,Ge,yt,pt,ft)}return e.makeTensorInfo(Ae.shape,Ae.dtype,Ae.values)}},QP={kernelName:d.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=n,u=e;cn(r,"MaxPoolWithArgmax");const c=u.data.get(r.dataId).values,l=d.backend_util.computePool2DInfo(r.shape,s,o,[1,1],i),[h,f]=function ZP(t,n,e,r,s){const i=w3(t,0,e,d.util.computeStrides(n),s,"max"),a=fS(t,n,e,s,!0,r);return[i.values,a.values]}(c,r.shape,r.dtype,a,l),m=u.write(h,l.outShape,r.dtype),y=u.write(f,l.outShape,r.dtype);return[{dataId:m,shape:l.outShape,dtype:r.dtype},{dataId:y,shape:l.outShape,dtype:"int32"}]}},eL={kernelName:d.Mean,backendName:"cpu",kernelFunc:function JP(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=d.util.parseAxisParam(o,s.shape),c=d.backend_util.computeOutAndReduceShapes(s.shape,a)[1],l=d.util.sizeFromShape(c),h=[],f=e.makeTensorInfo([],"float32",new Float32Array([l]));h.push(f);const m=yc({inputs:{x:s},backend:e,attrs:{dtype:"float32"}});h.push(m);const y=E3({inputs:{a:m,b:f},backend:e});h.push(y);const w=Cf({inputs:{x:y},backend:e,attrs:{axis:o,keepDims:i}});return h.forEach(E=>e.disposeIntermediateTensorInfo(E)),w}},nL={kernelName:d.Min,backendName:"cpu",kernelFunc:function tL(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;cn(s,"min");const a=d.util.parseAxisParam(o,s.shape);let u=a;const c=d.backend_util.getAxesPermutation(u,s.shape.length);let l=s;null!=c&&(l=Go({inputs:{x:s},backend:e,attrs:{perm:c}}),u=d.backend_util.getInnerMostAxes(u.length,s.shape.length)),d.backend_util.assertAxesAreInnerMostDims("min",u,l.shape.length);const[h,f]=d.backend_util.computeOutAndReduceShapes(l.shape,u),m=d.util.sizeFromShape(f),y=d.util.makeZerosTypedArray(d.util.sizeFromShape(h),l.dtype),w=e.data.get(l.dataId).values;for(let D=0;D<y.length;++D){const O=D*m;let W=w[O];for(let q=0;q<m;++q){const re=w[O+q];(Number.isNaN(re)||re<W)&&(W=re)}y[D]=W}null!=c&&e.disposeIntermediateTensorInfo(l);const E=e.makeTensorInfo(h,l.dtype,y);if(i){const O=zr({inputs:{x:E},backend:e,attrs:{shape:d.backend_util.expandShapeToKeepDim(h,a)}});return e.disposeIntermediateTensorInfo(E),O}return E}},VS=As((t,n)=>Math.min(t,n)),rL=Ks(d.Minimum,VS),sL={kernelName:d.Minimum,backendName:"cpu",kernelFunc:rL},iL={kernelName:d.MirrorPad,backendName:"cpu",kernelFunc:function oL(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{paddings:o,mode:i}=r;cn(s,"mirrorPad");const a=o.map((W,q)=>W[0]+s.shape[q]+W[1]),u=o.map(W=>W[0]),c=o.map((W,q)=>W[0]+s.shape[q]),l="reflect"===i?0:1,h=e.data.get(s.dataId).values,f=s.shape.length,m=d.util.computeStrides(s.shape),y=d.util.sizeFromShape(a),w=a.length,E=d.util.computeStrides(a),D=d.util.getTypedArrayFromDType(s.dtype,y);for(let W=0;W<y;W++){let q=d.util.indexToLoc(W,w,E);for(let pe=0;pe<w;pe++)q[pe]<u[pe]?q[pe]=2*u[pe]-q[pe]-l:q[pe]>=c[pe]&&(q[pe]=2*(c[pe]-1)-q[pe]+l);q=q.map((pe,Ae)=>pe-u[Ae]);const re=d.util.locToIndex(q,f,m);D[W]=h[re]}return{dataId:e.write(D,a,s.dtype),shape:a,dtype:s.dtype}}},aL=As((t,n)=>{const e=t%n;return t<0&&n<0||t>=0&&n>=0?e:(e+n)%n}),uL=Ks(d.Mod,aL),cL={kernelName:d.Mod,backendName:"cpu",kernelFunc:uL};var lL=M(340);function US(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{dim:o}=r,i=s.shape.length;let a=o;if(-1===a&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);const u=d.util.parseAxisParam([a],s.shape),c=LS({inputs:{x:s},backend:e,attrs:{reductionIndices:u,keepDims:!1}}),l=d.backend_util.expandShapeToKeepDim(c.shape,u),h=zr({inputs:{x:c},backend:e,attrs:{shape:l}}),f=I3({inputs:{a:s,b:h},backend:e}),m=ES({inputs:{x:f},backend:e}),y=Cf({inputs:{x:m},backend:e,attrs:{axis:u,keepDims:!1}}),w=zr({inputs:{x:y},backend:e,attrs:{shape:l}}),E=E3({inputs:{a:m,b:w},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(w),E}const dL={kernelName:d.Softmax,backendName:"cpu",kernelFunc:US},fL={kernelName:d.Multinomial,backendName:"cpu",kernelFunc:function hL(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{numSamples:o,seed:i,normalized:a}=r;cn(s,"multinomial");const u=a?s:US({inputs:{logits:s},backend:e,attrs:{dim:-1}}),c=u.shape[0],l=u.shape[1],h=e.data.get(u.dataId).values,f=[c,o],m=d.util.makeZerosTypedArray(d.util.sizeFromShape(f),"int32");for(let y=0;y<c;++y){const w=y*l,E=new Float32Array(l-1);E[0]=h[w];for(let W=1;W<E.length;++W)E[W]=E[W-1]+h[w+W];const D=lL.alea(i.toString()),O=y*o;for(let W=0;W<o;++W){const q=D();m[O+W]=E.length;for(let re=0;re<E.length;re++)if(q<E[re]){m[O+W]=re;break}}}return a||e.disposeIntermediateTensorInfo(u),e.makeTensorInfo(f,"int32",m)}};function WS(t,n,e){const r=d.util.createScalarValue(-1,e);return S3([],n,r,t,e)}const mL={kernelName:d.Neg,backendName:"cpu",kernelFunc:function pL(t){const{inputs:n,backend:e}=t,{x:r}=n;cn(r,"neg");const s=e.data.get(r.dataId).values,[o,i]=WS(s,r.shape,r.dtype);return e.makeTensorInfo(i,r.dtype,o)}},gL=d.kernel_impls.nonMaxSuppressionV3Impl,vL={kernelName:d.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function yL(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=r;cn(s,"NonMaxSuppression");const c=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,{selectedIndices:h}=gL(c,l,i,a,u);return e.makeTensorInfo([h.length],"int32",new Int32Array(h))}},xL=d.kernel_impls.nonMaxSuppressionV4Impl,wL={kernelName:d.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function bL(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:c}=r;cn(s,"NonMaxSuppressionPadded");const l=e.data.get(s.dataId).values,h=e.data.get(o.dataId).values,{selectedIndices:f,validOutputs:m}=xL(l,h,i,a,u,c);return[e.makeTensorInfo([f.length],"int32",new Int32Array(f)),e.makeTensorInfo([],"int32",new Int32Array([m]))]}},CL=d.kernel_impls.nonMaxSuppressionV5Impl,EL={kernelName:d.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function SL(t){const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:c}=r;cn(s,"NonMaxSuppressionWithScore");const l=e.data.get(s.dataId).values,h=e.data.get(o.dataId).values,f=i,m=a,y=u,w=c,{selectedIndices:E,selectedScores:D}=CL(l,h,f,m,y,w);return[e.makeTensorInfo([E.length],"int32",new Int32Array(E)),e.makeTensorInfo([D.length],"float32",new Float32Array(D))]}},zS=As((t,n)=>t!==n?1:0),_L=Ks(d.NotEqual,zS,null,"bool"),IL={kernelName:d.NotEqual,backendName:"cpu",kernelFunc:_L},TL={kernelName:d.OneHot,backendName:"cpu",kernelFunc:function DL(t){const{inputs:n,backend:e,attrs:r}=t,{indices:s}=n,{dtype:o,depth:i,onValue:a,offValue:u}=r;cn(s,"oneHot");const c=d.util.sizeFromShape(s.shape),l=new Float32Array(c*i);l.fill(u);const h=e.data.get(s.dataId).values;for(let f=0;f<c;++f)h[f]>=0&&h[f]<i&&(l[f*i+h[f]]=a);return e.makeTensorInfo([...s.shape,i],o,l)}};function tg(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const s=nl({inputs:{input:r},backend:e}),o=tg({inputs:{x:s},backend:e}),i=Nd({inputs:{input:r},backend:e}),a=tg({inputs:{x:i},backend:e}),u=fi({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}return T3({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const NL={kernelName:d.ZerosLike,backendName:"cpu",kernelFunc:tg},kL={kernelName:d.OnesLike,backendName:"cpu",kernelFunc:function HS(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const s=nl({inputs:{input:r},backend:e}),o=HS({inputs:{x:s},backend:e}),i=Nd({inputs:{input:r},backend:e}),a=tg({inputs:{x:i},backend:e}),u=fi({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}return T3({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function jS(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r;if(1===n.length)return eg({inputs:{input:n[0]},backend:e,attrs:{dim:s}});const o=n[0].shape,i=n[0].dtype;n.forEach(l=>{d.util.assertShapesMatch(o,l.shape,"All tensors passed to stack must have matching shapes"),d.util.assert(i===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=kd({inputs:n.map(l=>{const h=eg({inputs:{input:l},backend:e,attrs:{dim:s}});return a.push(h),h}),backend:e,attrs:{axis:s}});return a.forEach(l=>e.disposeIntermediateTensorInfo(l)),c}const AL={kernelName:d.Pack,backendName:"cpu",kernelFunc:jS},GS={kernelName:d.PadV2,backendName:"cpu",kernelFunc:function RL(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{paddings:o,constantValue:i}=r;cn(s,"pad");const a=o.map((O,W)=>O[0]+s.shape[W]+O[1]),u=o.map(O=>O[0]),c=e.data.get(s.dataId).values,l=d.util.sizeFromShape(s.shape),h=s.shape.length,f=d.util.computeStrides(s.shape),m=d.util.sizeFromShape(a),y=a.length,w=d.util.computeStrides(a),E=d.util.getTypedArrayFromDType(s.dtype,m);0!==i&&E.fill(i);for(let O=0;O<l;O++){const q=d.util.indexToLoc(O,h,f).map((pe,Ae)=>pe+u[Ae]);E[d.util.locToIndex(q,y,w)]=c[O]}return{dataId:e.write(E,a,s.dtype),shape:a,dtype:s.dtype}}},OL=As((t,n)=>Math.pow(t,n)),ML=Ks(d.Pow,OL),$L={kernelName:d.Pow,backendName:"cpu",kernelFunc:ML};function KS(t,n,e,r){const[s,o]=d.backend_util.computeOutAndReduceShapes(t,r),i=(0,d.upcastType)(n,"int32"),a=d.util.makeZerosTypedArray(d.util.sizeFromShape(s),i),u=d.util.sizeFromShape(o);for(let c=0;c<a.length;++c){const l=c*u;let h=1;for(let f=0;f<u;++f)h*=e[l+f];a[c]=h}return{outVals:a,outShape:s,outDtype:i}}const PL={kernelName:d.Prod,backendName:"cpu",kernelFunc:function FL(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;cn(s,"prod");const a=s.shape.length,u=d.util.parseAxisParam(o,s.shape),c=d.backend_util.getAxesPermutation(u,a);let l=u,h=s;const f=[];null!=c&&(h=Go({inputs:{x:s},backend:e,attrs:{perm:c}}),f.push(h),l=d.backend_util.getInnerMostAxes(l.length,a));const m=e.data.get(h.dataId).values,{outVals:y,outShape:w,outDtype:E}=KS(h.shape,h.dtype,m,l);let D=w;return i&&(D=d.backend_util.expandShapeToKeepDim(w,u)),f.forEach(O=>e.disposeIntermediateTensorInfo(O)),e.makeTensorInfo(D,E,y)}};function XS(t,n){const e=t.slice(0,n);for(;e.length<n;)e.push(1);for(let r=n;r<t.length;r++)e[n-1]*=t[r];return e}function qS(t,n,e,r,s,o,i,a){if(0===t.length)throw new Error("paramsNestedSplits must be non empty");if(0===n[0].length)throw new Error("Split tensors must not be scalars");if(function LL(t,n,e){t.forEach((r,s)=>{if(r<0||r>=e){const o=d.util.indexToLoc(s,n.length,d.util.computeStrides(n)).join(",");throw new Error(`indices[${o}] = ${r} is not in [0, ${e})`)}})}(o,i,n[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:l,valueSlices:h,numValues:f}=function VL(t,n,e,r){const s=[];let o=0;const a=new Array(n.length-1+e.length).fill(null).map(()=>[0]);!function BL(t,n){for(let e=0;e<t.length;++e){const r=t[e],s=e===t.length-1?n:t[e+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let o=1;o<r.length;++o)if(r[o-1]>r[o])throw new Error("Ragged splits must be sorted in ascending order")}}(e,r);let u=1;for(let c=0;c<n.length-1;++c){u*=n[c];const l=n[c+1];for(let h=1;h<u+1;++h)a[c].push(h*l)}for(let c=0;c<t.length;++c){let l=t[c],h=t[c]+1;for(let f=0;f<e.length;++f){const m=e[f],y=f+n.length-1;if(y>=0){const w=a[y],E=w[w.length-1]-m[l];for(let D=l;D<h;++D)a[y].push(m[D+1]+E)}l=m[l],h=m[h]}h!==l&&(s.push([l,h]),o+=h-l)}return{outSplits:a,valueSlices:s,numValues:o}}(o,i,t,c),m=function UL(t){const n=[];for(let e=0;e<t.length;++e){const s=d.util.getArrayFromDType("int32",t[e].length);n.push(s),t[e].forEach((o,i)=>s[i]=o)}return n}(l),y=function zL(t,n,e,r,s){const o=n.slice();o[0]=s;const i=d.util.getArrayFromDType(e,d.util.sizeFromShape(o)),a=t.length;return function WL(t,n,e,r,s,o){const i=XS(n,2)[1],a=XS(o,2)[1];let u=0;for(const c of e)for(let l=c[0];l<c[1];++l){for(let h=0;h<r;++h)s[u*a+h]=t[l*i+h];++u}}(t,n,r,0===a?0:a/n[0],i,o),[i,o]}(e,r,s,h,f);return[m,y[0],y[1]]}const jL={kernelName:d.RaggedGather,backendName:"cpu",kernelFunc:function HL(t){const{inputs:n,backend:e,attrs:r}=t,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=n,u=s.map(D=>e.data.get(D.dataId).values),c=s.map(D=>D.shape),l=e.data.get(o.dataId).values,h=e.data.get(i.dataId).values,[f,m,y]=qS(u,c,l,o.shape,o.dtype,h,i.shape),w=f.map(D=>e.makeTensorInfo([D.length],"int32",D)),E=e.makeTensorInfo(y,o.dtype,m);return w.concat([E])}};var aa=d.backend_util.RowPartitionType;class ng{constructor(n,e,r,s,o,i,a,u,c,l){this.shape=n,this.shapeShape=e,this.values=r,this.valuesShape=s,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=u,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=d.backend_util.getRowPartitionTypesHelper(l),this.raggedRank=d.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(n){return this.rowPartitionTypes[0]===aa.FIRST_DIM_SIZE?this.rowPartitionTypes[n+1]:this.rowPartitionTypes[n]}getRowPartitionTensor(n){return this.rowPartitionTypes[0]===aa.FIRST_DIM_SIZE?this.rowPartitionValues[n+1]:this.rowPartitionValues[n]}getMaxWidth(n){const e=this.getRowPartitionTensor(n-1);switch(this.getRowPartitionTypeByDimension(n-1)){case aa.VALUE_ROWIDS:return ng.getMaxWidthValueRowID(e);case aa.ROW_SPLITS:return ng.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${aa[this.getRowPartitionTypeByDimension(n-1)]}`)}}static getMaxWidthRowSplit(n){const e=n.length;if(0===e||1===e)return 0;let r=0;for(let s=0;s<e-1;++s){const o=n[s+1]-n[s];o>r&&(r=o)}return r}static getMaxWidthValueRowID(n){const e=n.length;if(0===e)return 0;let r=0,s=n[0],o=0;for(let i=1;i<e;++i){const a=n[i];a!==s&&(s=a,o=Math.max(i-r,o),r=i)}return Math.max(e-r,o)}tensorShapeFromTensor(n,e,r=!0){if(0===e.length){if(-1===n[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return ZS(n,r)}calculateOutputSize(n){const e=this.valuesShape;d.backend_util.validateDefaultValueShape(this.defaultValueShape,e);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=d.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,s,e);i[0]<0&&(i[0]=n);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(n,e,r){const s=Math.min(n,r),o=[];let i=0;for(let a=0;a<s;++a,i+=e)o.push(i);for(let a=s;a<n;++a)o.push(-1);return d.util.assert(o.length===n,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(n,e,r,s){const o=n.length,i=[];for(let a=0;a<o-1;++a){const u=n[a+1]-n[a];let c=Math.min(s,u),l=e[a];-1===l&&(c=0);for(let h=0;h<c;++h)i.push(l),l+=r;for(let h=0;h<u-c;++h)i.push(-1)}if(o>0&&i.length!==n[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(n,e,r,s){const o=n.length,i=[];if(0===o)return[];let a=0,u=n[0];if(u>=e.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${e.length}`);let c=e[u];i.push(c);for(let l=1;l<o;++l){const h=n[l];if(h===u)c>=0&&(++a,a<s?c+=r:c=-1);else{if(a=0,u=h,h>=e.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${e.length}`);c=e[h]}i.push(c)}if(i.length!==n.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(n,e,r,s){const o=this.getRowPartitionTensor(n),i=this.getRowPartitionTypeByDimension(n);switch(i){case aa.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,e,r,s);case aa.ROW_SPLITS:if(o.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(o,e,r,s);default:throw new Error(`Unsupported partition type: ${aa[i]}`)}}getFirstDimensionSize(){const n=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case aa.FIRST_DIM_SIZE:return n[0];case aa.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case aa.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${aa[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let u=s.length-2;u>=0;--u)s[u]=s[u+1]*r[u+1];const o=ZS(r,!1),i=d.util.getArrayFromDType(this.valuesDType,d.util.sizeFromShape(o));if(s[0]*r[0]>0){let u=this.calculateFirstParentOutputIndex(e,s[0],r[0]);for(let c=1;c<=this.raggedRank;++c)u=this.calculateOutputIndex(c-1,u,s[c],r[c]);this.setOutput(this.raggedRank,u,i,o)}return[o,i]}setOutput(n,e,r,s){if(0===r.length)return;const o=this.values,i=r;let a=s.slice();a=a.slice(n+1);const u=d.util.sizeFromShape(a),c=e.length;let l=this.defaultValue;if(l.length!==u&&1!==l.length){const y=this.defaultValueShape;(0,d.tidy)(()=>{const w=(0,d.reshape)(l,y);l=(0,d.broadcastTo)(w,a).dataSync()})}let h=0,f=0,m=0;for(let y=0;y<=c;++y){let w=y<c?e[y]:-1;if(w!==m){if(f<m){const E=o.subarray(h*u);YS(i.subarray(f*u),E,(m-f)*u)}if(y>=c&&(w=Math.floor(r.length/u)),w>m)if(1===this.defaultValue.length)i.subarray(m*u,w*u).fill(this.defaultValue[0]),m=w;else for(;w>m;)YS(i.slice(m*u),l,u),++m;w<0?(h=y+1,f=m):(h=y,f=m,m=f+1)}else++m}}}function YS(t,n,e){for(let r=0;r<e;r++)t[r]=n[r]}function ZS(t,n){const e=[];for(let r of t){if(r<0){if(!n)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function QS(t,n,e,r,s,o,i,a,u,c){return new ng(t,n,e,r,s,o,i,a,u,c).compute()}const KL={kernelName:d.RaggedTensorToTensor,backendName:"cpu",kernelFunc:function GL(t){const{inputs:n,backend:e,attrs:r}=t,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=n,{rowPartitionTypes:u}=r,c=e.data.get(s.dataId).values,l=e.data.get(o.dataId).values,h=e.data.get(i.dataId).values,f=a.map(E=>e.data.get(E.dataId).values),m=a.map(E=>E.shape),[y,w]=QS(c,s.shape,l,o.shape,o.dtype,h,i.shape,f,m,u);return e.makeTensorInfo(y,o.dtype,w)}};function JS(t,n,e,r){if(t===n||t<n&&e<0||n<t&&e>1)return d.util.makeZerosTypedArray(0,r);const a=Math.abs(Math.ceil((n-t)/e)),u=d.util.makeZerosTypedArray(a,r);n<t&&1===e&&(e=-1),u[0]=t;for(let c=1;c<u.length;c++)u[c]=u[c-1]+e;return u}const qL={kernelName:d.Range,backendName:"cpu",kernelFunc:function XL(t){const{backend:n,attrs:e}=t,{start:r,stop:s,dtype:o,step:i}=e,a=JS(r,s,i,o);return n.makeTensorInfo([a.length],o,a)}},YL=Ar(d.Reciprocal,t=>1/t),ZL={kernelName:d.Reciprocal,backendName:"cpu",kernelFunc:YL},JL={kernelName:d.ResizeBilinear,backendName:"cpu",kernelFunc:function QL(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r;cn(s,"resizeBilinear");const u=d.util.computeStrides(s.shape),[c,l]=a,[h,f,m,y]=s.shape,w=e.data.get(s.dataId).values,E=new Float32Array(d.util.sizeFromShape([h,c,l,y])),D=[o&&c>1?f-1:f,o&&l>1?m-1:m],O=[o&&c>1?c-1:c,o&&l>1?l-1:l];let W=0;const q=D[0]/O[0],re=D[1]/O[1];for(let pe=0;pe<h;pe++)for(let Ae=0;Ae<c;Ae++){let Be;Be=i?q*(Ae+.5)-.5:q*Ae;const Ke=Math.max(0,Math.floor(Be)),Ge=Be-Ke,ft=Math.min(f-1,Math.ceil(Be)),yt=pe*u[0]+Ke*u[1],pt=pe*u[0]+ft*u[1];for(let wt=0;wt<l;wt++){let vt;vt=i?re*(wt+.5)-.5:re*wt;const xt=Math.max(0,Math.floor(vt)),Et=vt-xt,mt=Math.min(m-1,Math.ceil(vt)),_t=yt+xt*u[2],Ot=pt+xt*u[2],Rt=yt+mt*u[2],zt=pt+mt*u[2];for(let $t=0;$t<y;$t++){const jt=w[_t+$t],Ut=w[Ot+$t],bn=jt+(w[Rt+$t]-jt)*Et;E[W++]=bn+(Ut+(w[zt+$t]-Ut)*Et-bn)*Ge}}}return e.makeTensorInfo([h,c,l,y],"float32",E)}},tB={kernelName:d.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function eB(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r;cn([o,s],"resizeBilinearGrad");const a=d.util.computeStrides(s.shape),[u,c,l,h]=s.shape,[,f,m]=o.shape,y=new Float32Array(u*c*l*h),w=[i&&f>1?c-1:c,i&&m>1?l-1:l],E=[i&&f>1?f-1:f,i&&m>1?m-1:m],D=w[0]/E[0],O=w[1]/E[1],W=e.data.get(o.dataId).values;let q=0;for(let re=0;re<u;re++){const pe=re*a[0];for(let Ae=0;Ae<f;Ae++){const Be=Ae*D,Ke=Math.floor(Be),Ge=Math.min(Math.ceil(Be),c-1),ft=pe+Ke*a[1],yt=pe+Ge*a[1],pt=Be-Ke,wt=1-pt;for(let vt=0;vt<m;vt++){const xt=vt*O,Et=Math.floor(xt),mt=Math.min(Math.ceil(xt),l-1),_t=xt-Et,Ot=1-_t,Rt=ft+Et*a[2],zt=ft+mt*a[2],$t=yt+Et*a[2],jt=yt+mt*a[2],Ut=wt*Ot,Kt=wt*_t,hn=pt*Ot,bn=pt*_t;for(let En=0;En<h;En++){const jn=W[q++];y[Rt+En]+=jn*Ut,y[zt+En]+=jn*Kt,y[$t+En]+=jn*hn,y[jt+En]+=jn*bn}}}}return e.makeTensorInfo([u,l,c,h],"float32",y)}},rB={kernelName:d.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function nB(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r;cn(s,"resizeNearestNeighbor");const u=d.util.computeStrides(s.shape),[c,l]=a,[h,f,m,y]=s.shape,w=e.data.get(s.dataId).values,E=new Float32Array(h*c*l*y),D=[o&&c>1?f-1:f,o&&l>1?m-1:m],O=[o&&c>1?c-1:c,o&&l>1?l-1:l],W=D[0]/O[0],q=D[1]/O[1];let re=0;for(let pe=0;pe<h;pe++){const Ae=pe*u[0];for(let Be=0;Be<c;Be++){const Ke=i?W*(Be+.5):W*Be;let Ge=Math.min(f-1,o?Math.round(Ke):Math.floor(Ke));i&&(Ge=Math.max(0,Ge));const ft=Ae+Ge*u[1];for(let yt=0;yt<l;yt++){const pt=i?q*(yt+.5):q*yt;let wt=Math.min(m-1,o?Math.round(pt):Math.floor(pt));i&&(wt=Math.max(0,wt));const vt=ft+wt*u[2];for(let xt=0;xt<y;xt++)E[re++]=w[vt+xt]}}}return e.makeTensorInfo([h,c,l,y],s.dtype,E)}},oB={kernelName:d.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function sB(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r;cn([o,s],"resizeNearestNeighborGrad");const a=d.util.computeStrides(s.shape),u=d.util.computeStrides(o.shape),[c,l,h,f]=s.shape,[,m,y]=o.shape,w=new Float32Array(c*l*h*f),E=e.data.get(o.dataId).values,D=[i&&m>1?l-1:l,i&&y>1?h-1:h],O=[i&&m>1?m-1:m,i&&y>1?y-1:y],W=D[0]/O[0],q=D[1]/O[1],re=1/W,pe=1/q,Ae=2*Math.ceil(re)+2,Be=2*Math.ceil(pe)+2;for(let Ke=0;Ke<c;Ke++){const Ge=Ke*a[0];for(let ft=0;ft<l;ft++){const yt=Ge+ft*a[1],pt=Math.floor(ft*re),wt=Math.floor(pt-Ae/2);for(let vt=0;vt<h;vt++){const xt=yt+vt*a[2],Et=Math.floor(vt*pe),mt=Math.floor(Et-Be/2);for(let _t=0;_t<f;_t++){let Ot=0;for(let Rt=0;Rt<Ae;Rt++){const zt=Rt+wt;if(zt<0||zt>=m)continue;const $t=Ge+zt*u[1],jt=zt*W;if(ft===Math.min(l-1,i?Math.round(jt):Math.floor(jt)))for(let Kt=0;Kt<Be;Kt++){const hn=Kt+mt;if(hn<0||hn>=y)continue;const bn=$t+hn*u[2],En=hn*q;vt===Math.min(h-1,i?Math.round(En):Math.floor(En))&&(Ot+=E[bn+_t])}}w[xt+_t]=Ot}}}}return e.makeTensorInfo(s.shape,s.dtype,w)}},aB={kernelName:d.Reverse,backendName:"cpu",kernelFunc:function iB(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dims:o}=r;cn(s,"reverse");const i=s.shape.length,a=d.util.parseAxisParam(o,s.shape);if(0===i)return uu({inputs:{x:s},backend:e});const u=new d.TensorBuffer(s.shape,s.dtype),c=e.bufferSync(s);for(let l=0;l<u.size;l++){const h=u.indexToLoc(l),f=h.slice();a.forEach(m=>f[m]=s.shape[m]-1-f[m]),u.set(c.get(...f),...h)}return e.makeTensorInfo(u.shape,u.dtype,u.values)}},uB={kernelName:d.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=n,a=e,u=d.util.getTypedArrayFromDType(r.dtype,d.util.sizeFromShape(r.shape)),[c,l,h,f]=r.shape,[m,y]=d.backend_util.getImageCenter(i,l,h),E=Math.sin(s),D=Math.cos(s),O=a.data.get(r.dataId).values;for(let q=0;q<c;q++){const re=q*h*l*f;for(let pe=0;pe<l;pe++){const Ae=pe*(h*f);for(let Be=0;Be<h;Be++){const Ke=Be*f;for(let Ge=0;Ge<f;Ge++){const ft=[c,pe,Be,Ge],yt=ft[2],pt=ft[1];let wt=(yt-m)*D-(pt-y)*E,vt=(yt-m)*E+(pt-y)*D;wt=Math.round(wt+m),vt=Math.round(vt+y);let xt=o;"number"!=typeof o&&(xt=3===Ge?255:o[Ge]),wt>=0&&wt<h&&vt>=0&&vt<l&&(xt=O[re+vt*(h*f)+wt*f+Ge]),u[re+Ae+Ke+Ge]=xt}}}}return{dataId:a.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},cB=Ar(d.Round,t=>{const n=Math.floor(t);return t-n<.5?Math.floor(t):t-n>.5?Math.ceil(t):n%2==0?n:n+1}),lB={kernelName:d.Round,backendName:"cpu",kernelFunc:cB},eE=gc(t=>1/Math.sqrt(t)),dB=Dd(d.Rsqrt,eE),hB={kernelName:d.Rsqrt,backendName:"cpu",kernelFunc:dB};function Ad(t,n,e,r,s,o,i,a,u,c){const l=[r/s,s],h=t.values,f=n.values;if(0===r)return(0,d.buffer)(e,n.dtype);const m=(0,d.buffer)(l,n.dtype);"string"==typeof u||"number"==typeof u?m.values.fill(u):"boolean"==typeof u&&m.values.fill(+u);for(let y=0;y<o;y++){const w=[];let E=0;for(let D=0;D<i;D++){const O=h[y*i+D];w.push(O),E+=O*a[D]}if(E<0||E>=r/s)throw new Error(`Invalid indices: ${w} does not index into ${e}`);for(let D=0;D<s;D++)c?m.values[E*s+D]+=f[y*s+D]:m.values[E*s+D]=0===n.rank?f[0]:f[y*s+D]}return m}const pB={kernelName:d.ScatterNd,backendName:"cpu",kernelFunc:function fB(t){const{inputs:n,backend:e,attrs:r}=t,{indices:s,updates:o}=n,{shape:i}=r,{sliceRank:a,numUpdates:u,sliceSize:c,strides:l,outputSize:h}=d.backend_util.calculateShapes(o,s,i),w=Ad(e.bufferSync(s),e.bufferSync(o),i,h,c,u,a,l,0,!0);return e.makeTensorInfo(i,w.dtype,w.values)}};function mB(t,n){let e=0,r=t.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),t[s]<n?e=s+1:r=s;return r}function gB(t,n){let e=0,r=t.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),t[s]<=n?e=s+1:r=s;return r}const xB={kernelName:d.SearchSorted,backendName:"cpu",kernelFunc:function vB(t){const{inputs:n,backend:e,attrs:r}=t,{sortedSequence:s,values:o}=n,{side:i}=r,c=function yB(t,n,e,r,s,o){const i=d.util.getArrayFromDType("int32",e*s);for(let a=0;a<e;++a){const u=t.slice(a*r,(a+1)*r),c=a*s;for(let l=0;l<s;++l)i[c+l]="left"===o?mB(u,n[l+c]):gB(u,n[l+c])}return i}(e.data.get(s.dataId).values,e.data.get(o.dataId).values,s.shape[0],s.shape[1],o.shape[1],i);return e.makeTensorInfo(o.shape,"int32",c)}},wB={kernelName:d.Select,backendName:"cpu",kernelFunc:function bB(t){const{inputs:n,backend:e}=t,{condition:r,t:s,e:o}=n;cn([r,s,o],"select");const i=r.shape.length,a=e.data.get(r.dataId).values,u=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,l=(0,d.upcastType)(s.dtype,o.dtype),h=d.util.makeZerosTypedArray(d.util.sizeFromShape(s.shape),l);let f=0;const m=0===i||i>1||1===s.shape.length?1:d.util.sizeFromShape(s.shape.slice(1));for(let y=0;y<a.length;y++)for(let w=0;w<m;w++)h[f++]=1===a[y]?u[y]:c[y];return e.makeTensorInfo(s.shape,l,h)}},CB=d.backend_util.SELU_SCALEALPHA,SB=d.backend_util.SELU_SCALE,EB=Ar(d.Selu,t=>t>=0?SB*t:CB*(Math.exp(t)-1)),_B={kernelName:d.Selu,backendName:"cpu",kernelFunc:EB},IB=Ar(d.Sign,t=>t<0?-1:t>0?1:0),DB={kernelName:d.Sign,backendName:"cpu",kernelFunc:IB},TB=Ar(d.Sin,t=>Math.sin(t)),NB={kernelName:d.Sin,backendName:"cpu",kernelFunc:TB},kB=Ar(d.Sinh,t=>Math.sinh(t)),AB={kernelName:d.Sinh,backendName:"cpu",kernelFunc:kB},tE=Math.log(1.1920928955078125e-7)+2,RB=Ar(d.Softplus,t=>{const n=t>-tE,e=t<tE,r=Math.exp(t);let s;return s=e?r:n?t:Math.log(1+r),s}),OB={kernelName:d.Softplus,backendName:"cpu",kernelFunc:RB},$B={kernelName:d.SpaceToBatchND,backendName:"cpu",kernelFunc:function MB(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,paddings:i}=r;cn([s],"spaceToBatchND");const a=d.util.sizeFromShape(o),u=[[0,0]];u.push(...i);for(let pe=1+o.length;pe<s.shape.length;++pe)u.push([0,0]);const c=GS.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:u,constantValue:0}}),l=d.backend_util.getReshaped(c.shape,o,a,!1),h=d.backend_util.getPermuted(l.length,o.length,!1),f=d.backend_util.getReshapedPermuted(c.shape,o,a,!1),w=zr({inputs:{x:c},backend:e,attrs:{shape:l}}),O=Go({inputs:{x:w},backend:e,attrs:{perm:h}}),re=zr({inputs:{x:O},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(O),re}};function nE(t,n,e,r,s,o,i){const a=n[0],u=o[0],c=new Array(u),l=new Array(a),h=n[1];if(0===u){if(0!==a)throw new Error(d.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));return[d.util.getArrayFromDType(e,0),[0,h],d.util.getArrayFromDType(s,0),c,l]}let f=!0,m=0;const y=new Array(u).fill(0);for(let E=0;E<a;++E){const D=t[E*h];if(D<0)throw new Error(d.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(E,D));if(D>=u)throw new Error(d.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(E,D,u));++y[D],f=f&&D>=m,m=D}let w=!0;for(let E=0;E<u;++E){const D=0===y[E];c[E]=D,w=w&&!D,y[E]=Math.max(y[E],1),E>0&&(y[E]+=y[E-1])}if(w&&f){const E=t,D=r;for(let O=0;O<a;++O)l[O]=O;return[E,[a,h],D,c,l]}{const E=y[u-1],D=d.util.getArrayFromDType(e,E*h),O=d.util.getArrayFromDType(s,E),W=new Array(u).fill(0);for(let q=0;q<a;++q){const re=t[q*h],Ae=(0===re?0:y[re-1])+W[re];W[re]++;for(let Be=0;Be<h;++Be)D[Ae*h+Be]=t[q*h+Be];O[Ae]=r[q],l[q]=Ae}for(let q=0;q<u;++q)if(0===W[q]){const pe=0===q?0:y[q-1];D[pe*h+0]=q;for(let Ae=1;Ae<h;++Ae)D[pe*h+Ae]=0;O[pe]=i}return[D,[E,h],O,c,l]}}const PB={kernelName:d.SparseFillEmptyRows,backendName:"cpu",kernelFunc:function FB(t){const{inputs:n,backend:e}=t,{indices:r,values:s,denseShape:o,defaultValue:i}=n;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=e.data.get(r.dataId).values,u=e.data.get(s.dataId).values,c=e.data.get(o.dataId).values,l=e.data.get(i.dataId).values[0],[h,f,m,y,w]=nE(a,r.shape,r.dtype,u,s.dtype,c,l);return[e.makeTensorInfo(f,r.dtype,h),e.makeTensorInfo([f[0]],s.dtype,m),e.makeTensorInfo([y.length],"bool",new Uint8Array(y.map(E=>Number(E)))),e.makeTensorInfo([w.length],r.dtype,new Int32Array(w))]}};function rE(t,n,e,r,s){const o=d.util.sizeFromShape(r),i=n[0],a=s.length,u=[];let c=1,l=-1;for(let E=0;E<a;++E){const D=s[E];if(-1===D){if(-1!==l)throw new Error(d.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(l,E));l=E,u.push(1)}else{if(D<0)throw new Error(d.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(E,D));c*=D,u.push(D)}}if(-1!==l){if(c<=0)throw new Error(d.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const E=Math.trunc(o/c);if(c*E!==o)throw new Error(d.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(r,u));u[l]=E}if(d.util.sizeFromShape(u)!==o)throw new Error(d.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(r,u));const f=r.length,m=[];if(f>0){m[f-1]=1;for(let E=f-2;E>=0;--E)m[E]=m[E+1]*r[E+1]}const y=[];if(a>0){y[a-1]=1;for(let E=a-2;E>=0;--E)y[E]=y[E+1]*u[E+1]}const w=d.util.getArrayFromDType(e,i*a);for(let E=0;E<i;++E){let D=0;for(let O=0;O<f;++O)D+=t[E*f+O]*m[O];for(let O=0;O<a;++O)w[E*a+O]=Math.trunc(D/y[O]),D%=y[O]}return[w,[i,a],u]}const BB={kernelName:d.SparseReshape,backendName:"cpu",kernelFunc:function LB(t){const{inputs:n,backend:e}=t,{inputIndices:r,inputShape:s,newShape:o}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(e.data.get(s.dataId).values),a=e.data.get(r.dataId).values,u=Array.from(e.data.get(o.dataId).values),[c,l,h]=rE(a,r.shape,r.dtype,i,u);return[e.makeTensorInfo(l,r.dtype,c),e.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}};function N3(t,n,e,r,s,o=!1,i=0){const a=r.length,u=[n[0],t.length/n[0]],c=u[1],h=a>0?s[a-1]+1:0;if(h<0)throw new Error(d.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const f=n.slice();f[0]=h;const m=f.reduce((W,q)=>W*q,1),y=d.util.getArrayFromDType(e,m);if(0===a)return h>0&&y.fill(i),[y,f];if(h<=0)throw new Error(d.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let w=0,E=1,D=0,O=s[w];for(;;){let W=0;if(E<a){if(W=s[E],O===W){++E;continue}if(O>=W)throw new Error(d.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(O<0||O>=h)throw new Error(d.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(O,h));O>D&&y.fill(i,D*c,O*c);for(let q=w;q<E;++q){const re=r[q];if(re<0||re>=u[0])throw new Error(d.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(q,r[q],u[0]));for(let pe=0;pe<c;pe++)y[O*c+pe]+=t[re*c+pe]}if(o)for(let q=0;q<c;q++)y[O*c+q]/=E-w;if(w=E,++E,D=O+1,O=W,E>a)break}return D<h&&y.fill(i,D*c,h*c),[y,f]}const UB={kernelName:d.SparseSegmentMean,backendName:"cpu",kernelFunc:function VB(t){const{inputs:n,backend:e}=t,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,[c,l]=N3(i,r.shape,r.dtype,a,u,!0);return e.makeTensorInfo(l,r.dtype,c)}},zB={kernelName:d.SparseSegmentSum,backendName:"cpu",kernelFunc:function WB(t){const{inputs:n,backend:e}=t,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,[c,l]=N3(i,r.shape,r.dtype,a,u);return e.makeTensorInfo(l,r.dtype,c)}},jB={kernelName:d.SparseToDense,backendName:"cpu",kernelFunc:function HB(t){const{inputs:n,backend:e,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:u,numUpdates:c,sliceSize:l,strides:h,outputSize:f}=d.backend_util.calculateShapes(o,s,a),m=!1,y=e.bufferSync(s);let w;switch(o.dtype){case"bool":w=Ad(y,e.bufferSync(o),a,f,l,c,u,h,Boolean(e.data.get(i.dataId).values[0]),m);break;case"float32":case"int32":w=Ad(y,e.bufferSync(o),a,f,l,c,u,h,e.data.get(i.dataId).values[0],m);break;case"string":w=Ad(y,e.bufferSync(o),a,f,l,c,u,h,d.util.decodeString(e.data.get(i.dataId).values[0]),m);break;default:throw new Error(`Unsupported type ${o.dtype}`)}return e.makeTensorInfo(a,w.dtype,w.values)}},KB={kernelName:d.SplitV,backendName:"cpu",kernelFunc:function GB(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{numOrSizeSplits:o,axis:i}=r,a=d.util.parseAxisParam(i,s.shape)[0],u=d.backend_util.prepareSplitSize(s,o,a),c=new Array(s.shape.length).fill(0),l=s.shape.slice();return u.map(h=>{const f=[...l];f[a]=h;const m=rl({inputs:{x:s},backend:e,attrs:{begin:c,size:f}});return c[a]+=h,m})}},XB=gc(t=>Math.sqrt(t)),qB=Ar(d.Sqrt,t=>Math.sqrt(t)),YB={kernelName:d.Sqrt,backendName:"cpu",kernelFunc:qB},ZB={kernelName:d.Square,backendName:"cpu",kernelFunc:({inputs:t,backend:n})=>{const{x:e}=t,r=n;cn(e,"square");const s=r.data.get(e.dataId).values,o=new Float32Array(s.length);for(let a=0;a<s.length;++a){const u=s[a];o[a]=u*u}return{dataId:r.write(o,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},sE=As((t,n)=>{const e=t-n;return e*e}),QB=Ks(d.SquaredDifference,sE),JB={kernelName:d.SquaredDifference,backendName:"cpu",kernelFunc:QB},eV=Ar(d.Step,(t,n)=>{const e=n;return isNaN(t)?NaN:t>0?1:e.alpha}),tV={kernelName:d.Step,backendName:"cpu",kernelFunc:eV};function oE(t,n,e,r){const s=(0,d.buffer)(t,n.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let u=0;u<a.length;u++)a[u]=i[u]*e[u]+r[u];s.set(n.get(...a),...i)}return s}const rV={kernelName:d.StridedSlice,backendName:"cpu",kernelFunc:function nV(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,end:i,strides:a,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:h,shrinkAxisMask:f}=r;cn(s,"stridedSlice");const{finalShapeSparse:m,finalShape:y,isIdentity:w,sliceDim0:E,isSimpleSlice:D,begin:O,end:W,strides:q}=d.slice_util.sliceInfo(s.shape,o,i,a,u,c,l,h,f);let re;if(w)re=zr({inputs:{x:s},backend:e,attrs:{shape:y}});else if(E||D){d.util.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const pe=d.slice_util.computeOutShape(O,W,q),Ae=rl({inputs:{x:s},backend:e,attrs:{begin:O,size:pe}});re=zr({inputs:{x:Ae},backend:e,attrs:{shape:y}}),e.disposeIntermediateTensorInfo(Ae)}else{const Ae=oE(m,e.bufferSync(s),q,O);re=e.makeTensorInfo(y,Ae.dtype,Ae.values)}return re}};class sV{constructor(n,e,r,s,o,i){this.separator=d.util.encodeString(n),this.nGramWidths=e,this.leftPad=d.util.encodeString(r),this.rightPad=d.util.encodeString(s),this.padWidth=o,this.preserveShort=i}getPadWidth(n){return Math.min(this.padWidth<0?n-1:this.padWidth,n-1)}getNumNGrams(n,e){const r=this.getPadWidth(e);return Math.max(0,n+2*r-e+1)}createNGrams(n,e,r,s,o,i){for(let a=0;a<o;++a){const u=this.getPadWidth(i),c=Math.max(0,u-a),l=Math.max(0,u-(o-(a+1))),h=i-(c+l),f=e+(c>0?0:a-u);let m=0;m+=c*this.leftPad.length;for(let O=0;O<h;++O)m+=n[f+O].length;m+=l*this.rightPad.length,m+=(c+l+h-1)*this.separator.length,r[s+a]=new Uint8Array(m);const w=r[s+a];let E=0;const D=O=>O.forEach(W=>w[E++]=W);for(let O=0;O<c;++O)D(this.leftPad),D(this.separator);for(let O=0;O<h-1;++O)D(n[f+O]),D(this.separator);if(h>0){D(n[f+h-1]);for(let O=0;O<l;++O)D(this.separator),D(this.rightPad)}else{for(let O=0;O<l-1;++O)D(this.rightPad),D(this.separator);D(this.rightPad)}}}compute(n,e){const r=n.length,s=e.length;if(s>0){let u=e[0];if(0!==u)throw new Error(`First split value must be 0, got ${u}`);for(let c=1;c<s;++c){let l=e[c]>=u;if(l=l&&e[c]<=r,!l)throw new Error(`Invalid split value ${e[c]}, must be in [${u}, ${r}]`);u=e[c]}if(u!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${u}`)}const o=s-1,i=d.util.getArrayFromDType("int32",s);if(0===r||0===s){const u=new Array(r);for(let c=0;c<=o;++c)i[c]=0;return[u,i]}i[0]=0;for(let u=1;u<=o;++u){const c=e[u]-e[u-1];let l=0;this.nGramWidths.forEach(h=>{l+=this.getNumNGrams(c,h)}),this.preserveShort&&c>0&&0===l&&(l=1),i[u]=i[u-1]+l}const a=new Array(i[o]);for(let u=0;u<o;++u){const c=e[u];let l=i[u];if(this.nGramWidths.forEach(h=>{const m=this.getNumNGrams(e[u+1]-e[u],h);this.createNGrams(n,c,a,l,m,h),l+=m}),this.preserveShort&&l===i[u]){const h=e[u+1]-e[u];if(0===h)continue;this.createNGrams(n,c,a,l,1,h+2*this.padWidth)}}return[a,i]}}function iE(t,n,e,r,s,o,i,a){return new sV(e,r,s,o,i,a).compute(t,n)}const iV={kernelName:d.StringNGrams,backendName:"cpu",kernelFunc:function oV(t){const{inputs:n,backend:e,attrs:r}=t,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:c}=r,{data:l,dataSplits:h}=n,f=e.data.get(l.dataId).values,m=e.data.get(h.dataId).values,[y,w]=iE(f,m,s,o,i,a,u,c);return[e.makeTensorInfo([y.length],"string",y),e.makeTensorInfo(h.shape,"int32",w)]}};function aV(t,n,e,r){if(!t.length)return;if(0===n.length){for(let o=0;o<t.length;++o)r.push(t.subarray(o,o+1));return}if(1===n.length){const o=n[0];let i=t.indexOf(o);for(;-1!==i;){const a=t.subarray(0,i);(!e||0!==a.length)&&r.push(a),i=(t=t.subarray(i+1)).indexOf(o)}return void((!e||0!==t.length)&&r.push(t))}let s=0;for(let o=0;o<t.length+1;o++)if(o===t.length||-1!==n.indexOf(t[o])){const i=t.subarray(s,o);(!e||0!==i.length)&&r.push(i),s=o+1}}function aE(t,n,e){const r=t.length,s=[];let o=0,i=0;const a=new Array(r);for(let f=0;f<r;++f){const m=s.length;aV(t[f],n,e,s);const y=s.length-m;a[f]=y,o+=y,i=Math.max(i,y)}const u=d.util.getArrayFromDType("int32",2*o),c=new Array(o),l=[r,i];let h=0;for(let f=0;f<r;++f)for(let m=0;m<a[f];++m)u[2*h]=f,u[2*h+1]=m,c[h]=s[h],++h;return[u,c,l]}const cV={kernelName:d.StringSplit,backendName:"cpu",kernelFunc:function uV(t){const{inputs:n,backend:e,attrs:r}=t,{skipEmpty:s}=r,{input:o,delimiter:i}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=e.data.get(o.dataId).values,u=e.data.get(i.dataId).values[0],[c,l,h]=aE(a,u,s),f=l.length;return[e.makeTensorInfo([f,2],"int32",c),e.makeTensorInfo([f],"string",l),e.makeTensorInfo([2],"int32",new Int32Array(h))]}};function uE(t,n){const e=d.util.getArrayFromDType("int32",t.length);for(let r=0;r<t.length;++r)e[r]=d.util.fingerPrint64(t[r]).modulo(n).getLowBitsUnsigned();return e}const dV={kernelName:d.StringToHashBucketFast,backendName:"cpu",kernelFunc:function lV(t){const{inputs:n,backend:e,attrs:r}=t,{numBuckets:s}=r,{input:o}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=uE(e.data.get(o.dataId).values,s);return e.makeTensorInfo(o.shape,"int32",a)}},hV=Ar(d.Tan,t=>Math.tan(t)),fV={kernelName:d.Tan,backendName:"cpu",kernelFunc:hV},pV=Ar(d.Tanh,t=>Math.tanh(t));function cE(t,n){const e=new Array(t.rank);for(let s=0;s<e.length;s++)e[s]=t.shape[s]*n[s];const r=(0,d.buffer)(e,t.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(t.rank);for(let u=0;u<i.length;u++)i[u]=o[u]%t.shape[u];const a=t.locToIndex(i);r.values[s]=t.values[a]}return r}const yV={kernelName:d.Tile,backendName:"cpu",kernelFunc:function gV(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reps:o}=r;cn(s,"tile");const i=cE(e.bufferSync(s),o);return e.makeTensorInfo(i.shape,i.dtype,i.values)}},Sf=(t,n)=>{const e=n.value-t.value;return 0===e?t.index-n.index:e};function lE(t,n,e=0,r=t.length-1){for(;r>e;){if(r-e>600){const a=r-e+1,u=n-e+1,c=Math.log(a),l=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*l*(a-l)/a)*Math.sign(u-a/2);lE(t,n,Math.max(e,Math.floor(n-u*l/a+h)),Math.min(r,Math.floor(n+(a-u)*l/a+h)))}const s=t[n];let o=e,i=r;for(d.util.swap(t,e,n),Sf(t[r],s)>0&&d.util.swap(t,e,r);o<i;){for(d.util.swap(t,o,i),o++,i--;Sf(t[o],s)<0;)o+=1;for(;Sf(t[i],s)>0;)i-=1}0===Sf(t[e],s)?d.util.swap(t,e,i):(i+=1,d.util.swap(t,i,r)),i<=n&&(e=i+1),n<=i&&(r=i-1)}}function dE(t,n,e,r,s){const o=n[n.length-1],[i,a]=[t.length/o,o],u=d.util.getTypedArrayFromDType(e,i*r),c=d.util.getTypedArrayFromDType("int32",i*r);for(let h=0;h<i;h++){const f=h*a,m=t.subarray(f,f+a);let y=new Array(m.length);m.forEach((O,W)=>y[W]={value:O,index:W}),r<y.length&&(lE(y,r),y=y.slice(0,r)),s&&y.sort(Sf);const w=h*r,E=u.subarray(w,w+r),D=c.subarray(w,w+r);for(let O=0;O<r;O++)E[O]=y[O].value,D[O]=y[O].index}const l=n.slice();return l[l.length-1]=r,[(0,d.buffer)(l,e,u),(0,d.buffer)(l,"int32",c)]}const xV={kernelName:d.TopK,backendName:"cpu",kernelFunc:function vV(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{k:o,sorted:i}=r;cn(s,"topk");const a=e.data.get(s.dataId).values,[u,c]=dE(a,s.shape,s.dtype,o,i);return[e.makeTensorInfo(u.shape,u.dtype,u.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}},wV={kernelName:d.Transform,backendName:"cpu",kernelFunc:function bV(t){const{inputs:n,attrs:e,backend:r}=t,{image:s,transforms:o}=n,{interpolation:i,fillMode:a,fillValue:u,outputShape:c}=e,[l,h,f,m]=s.shape,[y,w]=c??[h,f],E=[l,y,w,m],D=d.util.computeStrides(s.shape),O=D[0],W=D[1],q=D[2],re=d.util.computeStrides(E),pe=re[0],Ae=re[1],Be=re[2],Ke=d.util.getTypedArrayFromDType(s.dtype,d.util.sizeFromShape(E));Ke.fill(u);const Ge=r.data.get(s.dataId).values,ft=r.data.get(o.dataId).values;for(let pt=0;pt<l;++pt){const wt=1===o.shape[0]?ft:ft.subarray(8*pt,8*pt+8);for(let vt=0;vt<y;++vt)for(let xt=0;xt<w;++xt)for(let Et=0;Et<m;++Et){let mt;const _t=wt[6]*xt+wt[7]*vt+1;if(0===_t)continue;const Rt=(wt[3]*xt+wt[4]*vt+wt[5])/_t,zt=hE((wt[0]*xt+wt[1]*vt+wt[2])/_t,f,a),$t=hE(Rt,h,a);switch(i){case"nearest":mt=IV(Ge,h,f,O,W,q,pt,$t,zt,Et,u);break;case"bilinear":mt=DV(Ge,h,f,O,W,q,pt,$t,zt,Et,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}Ke[pt*pe+vt*Ae+xt*Be+Et]=mt}return r.makeTensorInfo(E,s.dtype,Ke)}return{dataId:r.write(Ke,E,s.dtype),shape:s.shape,dtype:s.dtype}}};function hE(t,n,e){switch(e){case"reflect":return function CV(t,n){let e=t;if(e<0)if(n<=1)e=0;else{const r=2*n;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-n?e+r:-e-1}else if(e>n-1)if(n<=1)e=0;else{const r=2*n;e-=r*Math.trunc(e/r),e>=n&&(e=r-e-1)}return d.util.clamp(0,e,n-1)}(t,n);case"wrap":return function SV(t,n){let e=t;return e<0?n<=1?e=0:e+=n*(Math.trunc(-e/(n-1))+1):e>n-1&&(n<=1?e=0:e-=n*Math.trunc(e/(n-1))),d.util.clamp(0,e,n-1)}(t,n);case"nearest":return function _V(t,n){return d.util.clamp(0,t,n-1)}(t,n);default:return function EV(t,n){return t}(t)}}function Ef(t,n,e,r,s,o,i,a,u,c,l){return 0<=a&&a<n&&0<=u&&u<e?t[i*r+a*s+u*o+c]:l}function IV(t,n,e,r,s,o,i,a,u,c,l){return Ef(t,n,e,r,s,o,i,Math.round(a),Math.round(u),c,l)}function DV(t,n,e,r,s,o,i,a,u,c,l){const h=Math.floor(a),f=Math.floor(u),m=h+1,y=f+1;return(m-a)*((y-u)*Ef(t,n,e,r,s,o,i,h,f,c,l)+(u-f)*Ef(t,n,e,r,s,o,i,h,y,c,l))+(a-h)*((y-u)*Ef(t,n,e,r,s,o,i,m,f,c,l)+(u-f)*Ef(t,n,e,r,s,o,i,m,y,c,l))}function fE(t,n,e,r){const s=d.util.parseAxisParam(n,e)[0],o=[1,e[0],1];for(let y=0;y<s;y++)o[0]*=e[y];o[1]=e[s];for(let y=s+1;y<e.length;y++)o[2]*=e[y];const i={},a=new Int32Array(e[s]),u=new d.TensorBuffer(o,r,t),c=[],l=1===o[0]&&1===o[2];for(let y=0;y<e[s];y++){let w;if(l)w=t[y].toString();else{const E=[];for(let D=0;D<o[0];D++)for(let O=0;O<o[2];O++)E.push(u.get(D,y,O));w=E.join(",")}if(void 0!==i[w])a[y]=i[w];else{const E=Object.keys(i).length;i[w]=E,a[y]=E,c.push(y)}}const h=o.slice();h[1]=Object.keys(i).length;const f=new d.TensorBuffer(h,r);c.forEach((y,w)=>{for(let E=0;E<o[0];E++)for(let D=0;D<o[2];D++)f.set(u.get(E,y,D),E,w,D)});const m=e.slice();return m[s]=h[1],{outputValues:f.values,outputShape:m,indices:a}}const NV={kernelName:d.Unique,backendName:"cpu",kernelFunc:function TV(t){const{inputs:n,attrs:e,backend:r}=t,{axis:s}=e,{x:o}=n;cn(o,"unique");const i=r.data.get(o.dataId).values,{outputValues:a,outputShape:u,indices:c}=fE(i,s,o.shape,o.dtype);return[r.makeTensorInfo(u,o.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},AV={kernelName:d.Unpack,backendName:"cpu",kernelFunc:function kV(t){const{inputs:n,backend:e,attrs:r}=t,{value:s}=n;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s.shape.length,a=s.shape[o],u=new Array(i-1);let c=0;for(let m=0;m<i;m++)m!==o&&(u[c++]=s.shape[m]);const l=new Array(i).fill(0),h=s.shape.slice();h[o]=1;const f=new Array(a);for(let m=0;m<f.length;m++){l[o]=m;const y=rl({inputs:{x:s},backend:e,attrs:{begin:l,size:h}});f[m]=zr({inputs:{x:y},backend:e,attrs:{shape:u}}),e.disposeIntermediateTensorInfo(y)}return f}},OV={kernelName:d.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function RV(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,segmentIds:o}=n,{numSegments:i}=r;cn(s,"unsortedSegmentSum");const c=[],l=[],h=s.shape.length-o.shape.length;let f=o;for(let y=0;y<h;++y){const w=eg({inputs:{input:f},backend:e,attrs:{dim:y+1}});f=w,l.push(w)}for(let y=0;y<i;++y){const w=d.util.createScalarValue(y,"int32"),E=e.makeTensorInfo([],"int32",w),D=CS({inputs:{a:E,b:f},backend:e}),O=yc({inputs:{x:D},backend:e,attrs:{dtype:"float32"}}),W=Jm({inputs:{a:O,b:s},backend:e}),q=Cf({inputs:{x:W},backend:e,attrs:{axis:0,keepDims:!1}});c.push(q),l.push(E),l.push(D),l.push(O),l.push(W),l.push(q)}const m=jS({inputs:c,backend:e,attrs:{axis:0}});return l.forEach(y=>e.disposeIntermediateTensorInfo(y)),m}},MV=[M$,F$,L$,V$,k$,W$,j$,K$,q$,Z$,J$,t9,r9,i9,u9,d9,f9,m9,y9,R$,x9,C9,E9,I9,T$,T9,k9,I$,R9,M9,$9,P9,B9,U9,z9,j9,K9,q9,Z9,J9,tF,rF,oF,iF,uF,lF,hF,fF,pF,mF,bF,y$,CF,SF,AF,RF,OF,$F,zF,HF,GF,XF,ZF,JF,tP,rP,oP,aP,cP,v$,dP,O9,fP,mP,yP,x$,xP,wP,SP,_P,DP,kP,RP,$P,PP,BP,VP,WP,HP,GP,XP,YP,QP,eL,nL,sL,iL,cL,fL,yF,mL,vL,wL,EL,IL,TL,kL,AL,GS,$L,w$,PL,jL,KL,qL,D$,_3,ZL,C$,S$,A$,JL,tB,rB,oB,aB,uB,lB,hB,pB,xB,wB,_B,_$,DB,NB,AB,b9,dL,OB,$B,PB,BB,UB,zB,jB,KB,YB,ZB,JB,tV,rV,iV,cV,dV,LF,vF,fV,{kernelName:d.Tanh,backendName:"cpu",kernelFunc:pV},yV,xV,wV,z$,NV,AV,OV,NL];for(const t of MV)(0,d.registerKernel)(t);const vc={},rg={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Ra(t,n){if(!(t in vc)||null!=n){const r=function PV(t,n){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=n??function FV(t){if(typeof OffscreenCanvas<"u"&&2===t)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete vc[t]},!1),(0,d.env)().getBool("SOFTWARE_WEBGL_ENABLED")&&(rg.failIfMajorPerformanceCaveat=!1),1===t?e.getContext("webgl",rg)||e.getContext("experimental-webgl",rg):e.getContext("webgl2",rg)}(t,n);if(null===r)return console.log("Could not get context for WebGL version",t),null;vc[t]=r}const e=vc[t];return null==e||e.isContextLost()?(delete vc[t],Ra(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),vc[t])}var Rd=(()=>(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(Rd||(Rd={})),Rd))(),pi=(()=>(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(pi||(pi={})),pi))(),Xs=(()=>(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(Xs||(Xs={})),Xs))();function _f(t,n){return[n,t]}function sg(t){const n=d.util.sizeFromShape(t),e=Math.ceil(n/4);return d.util.sizeToSquarishShape(e)}function Od(t,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(t/2))]}function k3(t,n){const e=t;let r,s,o,i,a,u,c,l,h,f;return 2===(0,d.env)().getNumber("WEBGL_VERSION")?(r=e.R32F,s=e.R16F,o=e.RGBA16F,i=e.RGBA32F,a=e.RED,c=4,l=1,h=e.HALF_FLOAT,f=e.FLOAT,u=e.RGBA8):(r=t.RGBA,s=t.RGBA,o=t.RGBA,i=e.RGBA,a=t.RGBA,c=4,l=4,h=null!=n?n.HALF_FLOAT_OES:null,f=t.FLOAT,u=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:c,defaultNumChannels:l,textureTypeHalfFloat:h,textureTypeFloat:f}}function rn(t,n){const e=n();return(0,d.env)().getBool("DEBUG")&&function VV(t){const n=t.getError();if(n!==t.NO_ERROR)throw new Error("WebGL Error: "+function HV(t,n){switch(n){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${n}`}}(t,n))}(t),e}const UV=5.96e-8,WV=65504;function zV(t){return!!((0,d.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||UV<Math.abs(t)&&Math.abs(t)<WV)}function og(t,n){return Wu(t,()=>t.getExtension(n),'Extension "'+n+'" not supported on this browser.')}const KV=/ERROR: [0-9]+:([0-9]+):/g;function pE(t,n){const e=KV.exec(n);if(null==e)return console.log(`Couldn't parse line number in error: ${n}`),void console.log(t);const r=+e[1],s=t.split("\n"),o=s.length.toString().length+2,i=s.map((h,f)=>d.util.rightPad((f+1).toString(),o)+h);let a=0;for(let h=0;h<i.length;h++)a=Math.max(i[h].length,a);const u=i.slice(0,r-1),c=i.slice(r-1,r),l=i.slice(r);console.log(u.join("\n")),console.log(n.split("\n")[0]),console.log(`%c ${d.util.rightPad(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(l.join("\n"))}function A3(t,n){if(rn(t,()=>t.validateProgram(n)),!1===t.getProgramParameter(n,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function mE(t,n,e,r,s,o,i){const a=t.getAttribLocation(n,e);return-1!==a&&(rn(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),rn(t,()=>t.vertexAttribPointer(a,s,t.FLOAT,!1,o,i)),rn(t,()=>t.enableVertexAttribArray(a)),!0)}function sU(t,n,e,r){rn(t,()=>function tU(t,n,e){(function yE(t,n){const e=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=n+t.TEXTURE0;if(r<t.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(t,e),rn(t,()=>t.activeTexture(t.TEXTURE0+e)),rn(t,()=>t.bindTexture(t.TEXTURE_2D,n))}(t,n,r)),rn(t,()=>t.uniform1i(e,r))}function R3(t,n,e){rn(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),rn(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0))}function gE(t,n){rn(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),rn(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function ig(t){const n=t.checkFramebufferStatus(t.FRAMEBUFFER);if(n!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function oU(t,n){switch(n){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${n}`}}(t,n))}function Wu(t,n,e){const r=rn(t,()=>n());if(null==r)throw new Error(e);return r}function Md(t,n=2){return d.util.sizeFromShape(t.slice(0,t.length-n))}function $d(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function O3(t){let n=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(n=[Md(t),...$d(t)]),n}function ag(t){return t%2==0}function ug(t,n){if(t=t.slice(-2),n=n.slice(-2),d.util.arraysEqual(t,n)||!t.length||!n.length||0===t[0]||0===t[1]||0===n[0]||0===n[1])return!0;if(t.length!==n.length){const e=t.slice(-1)[0],r=n.slice(-1)[0];if(e===r||ag(e)&&ag(r)&&(1===t[0]||1===n[0]))return!0}return t[1]===n[1]&&ag(t[0])&&ag(n[0])}let cg,lg;function ua(t,n){return null!=t.getExtension(n)}function vE(t){try{if(null!=Ra(t))return!0}catch(n){return console.log("Error when getting WebGL context: ",n),!1}return!1}function M3(t){const n=k3(t),e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(e),t.deleteFramebuffer(o),i}function If(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{null!=e&&d.util.assert("complex64"!==e.dtype,()=>`${n} does not support complex64 tensors in the WebGL backend.`)})}const gn=(0,d.env)();function Do(){let t,n,e,r,s,o,i,a,u,c;return 2===(0,d.env)().getNumber("WEBGL_VERSION")?(t="#version 300 es",n="in",e="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a=(0,d.env)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",u="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",n="attribute",e="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:n,varyingVs:e,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:u,defineRound:c}}function sl(t,n,e="index"){const r=d.util.computeStrides(n);return r.map((s,o)=>`int ${t[o]} = ${e} / ${s}; ${o===r.length-1?`int ${t[o+1]} = ${e} - ${t[o]} * ${s}`:`index -= ${t[o]} * ${s}`};`).join("")}function dg(t,n,e="index"){const r=d.util.computeStrides(n);return r.map((s,o)=>`int ${t[o]} = ${e} / outShapeStrides[${o}]; ${o===r.length-1?`int ${t[o+1]} = ${e} - ${t[o]} * outShapeStrides[${o}]`:`index -= ${t[o]} * outShapeStrides[${o}]`};`).join("")}function $3(t){const n=d.util.computeStrides(t).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}gn.registerFlag("HAS_WEBGL",()=>gn.getNumber("WEBGL_VERSION")>0),gn.registerFlag("WEBGL_VERSION",()=>vE(2)?2:vE(1)?1:0),gn.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),gn.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===gn.get("WEBGL_VERSION")),gn.registerFlag("WEBGL_CPU_FORWARD",()=>!0),gn.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),gn.registerFlag("WEBGL_PACK",()=>gn.getBool("HAS_WEBGL")),gn.registerFlag("WEBGL_PACK_NORMALIZATION",()=>gn.getBool("WEBGL_PACK")),gn.registerFlag("WEBGL_PACK_CLIP",()=>gn.getBool("WEBGL_PACK")),gn.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>gn.getBool("WEBGL_PACK")),gn.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>gn.getBool("WEBGL_PACK")),gn.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>gn.getBool("WEBGL_PACK")),gn.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>gn.getBool("WEBGL_PACK")),gn.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>gn.getBool("WEBGL_PACK")),gn.registerFlag("WEBGL_PACK_REDUCE",()=>gn.getBool("WEBGL_PACK")),gn.registerFlag("WEBGL_LAZILY_UNPACK",()=>gn.getBool("WEBGL_PACK")),gn.registerFlag("WEBGL_CONV_IM2COL",()=>gn.getBool("WEBGL_PACK")),gn.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function aU(t){if(null==cg){const n=Ra(t);cg=n.getParameter(n.MAX_TEXTURE_SIZE)}return cg}(gn.getNumber("WEBGL_VERSION"))),gn.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function uU(t){if(null==lg){const n=Ra(t);lg=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,lg)}(gn.getNumber("WEBGL_VERSION"))),gn.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=gn.getNumber("WEBGL_VERSION");return 0===t?0:function cU(t){if(0===t)return 0;let n;const e=Ra(t);return n=ua(e,"EXT_disjoint_timer_query_webgl2")&&2===t?2:ua(e,"EXT_disjoint_timer_query")?1:0,n}(t)}),gn.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>gn.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!d.device_util.isMobile()),gn.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function lU(t){if(0===t)return!1;const n=Ra(t);if(1===t){if(!ua(n,"OES_texture_float"))return!1}else if(!ua(n,"EXT_color_buffer_float"))return!1;return M3(n)}(gn.getNumber("WEBGL_VERSION"))),gn.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!gn.getBool("WEBGL_FORCE_F16_TEXTURES")&&gn.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),gn.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function dU(t){if(0===t)return!1;const n=Ra(t);if(1!==t){if(ua(n,"EXT_color_buffer_float"))return M3(n);const r="EXT_color_buffer_half_float";if(ua(n,r)){const s=n.getExtension(r);return function hU(t,n){const e=k3(t,n),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(i),a}(n,s)}return!1}return!(!ua(n,"OES_texture_float")||!ua(n,"WEBGL_color_buffer_float"))&&M3(n)}(gn.getNumber("WEBGL_VERSION"))),gn.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function fU(t){return 2===t&&null!=Ra(t).fenceSync}(gn.getNumber("WEBGL_VERSION"))),gn.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>gn.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),gn.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)}),gn.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>d.device_util.isMobile()?1:-1,t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)}),gn.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),gn.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),gn.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),gn.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),gn.registerFlag("WEBGL_EXP_CONV",()=>!1),gn.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>gn.getBool("IS_TEST")),gn.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),gn.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),gn.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);const xE="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:bE}=d.backend_util;function gU(t,n,e){const r=[];if(t.forEach(m=>{const y=d.util.sizeFromShape(m.shapeInfo.logicalShape);if(m.shapeInfo.isUniform?r.push(`uniform float ${m.name}${y>1?`[${y}]`:""};`):(r.push(`uniform sampler2D ${m.name};`),r.push(`uniform int offset${m.name};`)),e.enableShapeUniforms){const{uniformShape:w}=P3(e.packedInputs,m.shapeInfo.logicalShape,m.shapeInfo.texShape);switch(w.length){case 1:r.push(`uniform int ${m.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${m.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${m.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${m.name}Shape;`)}r.push(`uniform ivec2 ${m.name}TexShape;`)}}),e.enableShapeUniforms){switch(n.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(m=>{r.push(`uniform ${m.type} ${m.name}${m.arrayIndex?`[${m.arrayIndex}]`:""};`)});const s=r.join("\n"),o=t.map(m=>function yU(t,n,e=!1,r){let s="";s+=e?wE(t,r):Fd(t,r);return t.shapeInfo.logicalShape.length<=n.logicalShape.length&&(s+=e?function YU(t,n){const e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",o=t.shapeInfo.logicalShape.length,i=n.logicalShape.length,a=bE(t.shapeInfo.logicalShape,n.logicalShape),u=Hr(i),c=i-o;let l;const h=["x","y","z","w","u","v"];l=0===o?"":i<2&&a.length>=1?"coords = 0;":a.map(O=>`coords.${h[O+c]} = 0;`).join("\n");let f="";f=i<2&&o>0?"coords":t.shapeInfo.logicalShape.map((O,W)=>`coords.${h[W+c]}`).join(", ");let m="return outputValue;";const w=1===d.util.sizeFromShape(t.shapeInfo.logicalShape),D=1===d.util.sizeFromShape(n.logicalShape);if(1!==o||w||D){if(w&&!D)m=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const O=o-2,W=o-1;a.indexOf(O)>-1&&a.indexOf(W)>-1?m="return vec4(outputValue.x);":a.indexOf(O)>-1?m="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(W)>-1&&(m="return vec4(outputValue.xx, outputValue.zz);")}}else m="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${l}\n      vec4 outputValue = get${r}(${f});\n      ${m}\n    }\n  `}(t,n):function ZU(t,n){const e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",a=t.shapeInfo.logicalShape.length,u=n.logicalShape.length;if(!t.shapeInfo.isUniform&&a===u&&null==t.shapeInfo.flatOffset&&d.util.arraysEqual(t.shapeInfo.texShape,n.texShape))return`\n      float ${s}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const c=Hr(u),l=bE(t.shapeInfo.logicalShape,n.logicalShape),h=u-a;let f;const m=["x","y","z","w","u","v"];f=0===a?"":u<2&&l.length>=1?"coords = 0;":l.map(w=>`coords.${m[w+h]} = 0;`).join("\n");let y="";return y=u<2&&a>0?"coords":t.shapeInfo.logicalShape.map((w,E)=>`coords.${m[E+h]}`).join(", "),`\n    float ${s}() {\n      ${c} coords = getOutputCoords();\n      ${f}\n      return get${r}(${y});\n    }\n  `}(t,n)),s}(m,n,e.packedInputs,e.enableShapeUniforms)).join("\n"),i=n.texShape,a=Do(),u=function bU(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let c,l,h=function SU(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${EU}\n    ${_U}\n    ${IU}\n  `}(a);return n.isPacked?(c=function vU(t,n,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function TU(t,n,e){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,n,e);case 2:return function FU(t,n,e){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(d.util.arraysEqual(t,n))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(t[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,n,e);case 3:return function kU(t,n,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],s=Math.ceil(t[2]/2),o=s*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,n,e);default:return function RU(t,n,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],s=Math.ceil(t[t.length-1]/2),o=s*Math.ceil(t[t.length-2]/2);let i=o,a="",u="b, r, c";for(let c=2;c<t.length-1;c++)i*=t[t.length-c-1],a=`\n      int b${c} = index / ${i};\n      index -= b${c} * ${i};\n    `+a,u=`b${c}, `+u;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${t.length}(${u});\n    }\n  `}(t,n,e)}}(n.logicalShape,i,e.enableShapeUniforms),l=function CU(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(a)):(c=function xU(t,n,e){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function NU(t,n,e){return 1===n[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}(0,n,e);case 2:return function PU(t,n,e){return d.util.arraysEqual(t,n)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `:1===t[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,n,e);case 3:return function AU(t,n,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${dg(["r","c","d"],t)}\n    return ivec3(r, c, d);\n  }\n`;const r=sl(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(t,n,e);case 4:return function OU(t,n,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${dg(["r","c","d","d2"],t)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=sl(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,n,e);case 5:return function MU(t,n){const e=sl(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,n);case 6:return function $U(t,n){const e=sl(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,n);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}(n.logicalShape,i,e.enableShapeUniforms),l=function wU(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(h+=DU),[h,u,l,s,c,o,e.userCode].join("\n")}function Fd(t,n=!1){const e=t.shapeInfo.logicalShape;switch(e.length){case 0:return function BU(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[s,o]=t.shapeInfo.texShape;if(1===s&&1===o)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const i=ol(e);if(n)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,u]=t.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${u}, ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t,n);case 1:return function UU(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Pd(t)}\n      }\n    `;const s=t.shapeInfo.texShape,o=s[0],i=s[1];if(1===i&&1===o)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=ol(e);return 1===i?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===o?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:n?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(t,n);case 2:return function zU(t,n){const e=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape;if(null!=o&&d.util.arraysEqual(e,o))return n?`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${o[1]}.0, ${o[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:i,keptDims:a}=d.util.squeezeShape(e);if(i.length<e.length){const m=["row","col"];return`\n      ${Fd(Ld(t,i),n)}\n      float ${s}(int row, int col) {\n        return ${s}(${Bd(m,a)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Pd(t)}\n      }\n    `;const c=o[0],l=o[1],h=ol(r);return 1===l?n?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===c?n?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:n?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${c}, ${l}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(t,n);case 3:return function jU(t,n){const e=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[1]*e[2],i=e[2],{newShape:a,keptDims:u}=d.util.squeezeShape(e);if(a.length<e.length){const E=["row","col","depth"];return`\n        ${Fd(Ld(t,a),n)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${Bd(E,u)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${o}, ${i}, 1)));\n        ${Pd(t)}\n      }\n    `;const l=t.shapeInfo.texShape,h=l[0],f=l[1],m=t.shapeInfo.flatOffset;if(f===o&&null==m)return n?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${f}.0, ${h}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(f===i&&null==m)return n?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${h}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const y=ol(r);return n?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${y};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o} + col * ${i} + depth + ${y};\n        vec2 uv = uvFromFlat(${h}, ${f}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(t,n);case 4:return function KU(t,n){const e=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e[3],i=e[2]*o,a=e[1]*i,{newShape:u,keptDims:c}=d.util.squeezeShape(e);if(u.length<e.length){const W=["row","col","depth","depth2"];return`\n      ${Fd(Ld(t,u),n)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${Bd(W,c)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${i}, ${o}, 1)));\n        ${Pd(t)}\n      }\n    `;const l=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,f=h[0],m=h[1],y=`int stride2 = ${r}Shape[3];`,w=`int stride1 = ${r}Shape[2] * stride2;`,E=`int stride0 = ${r}Shape[1] * stride1;`;if(m===a&&null==l)return n?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${y}\n        ${w}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${f}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(m===o&&null==l)return n?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${f}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const D=ol(r);return n?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${y}\n      ${w}\n      ${E}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${D});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} +\n          depth * ${o} + depth2;\n      vec2 uv = uvFromFlat(${f}, ${m}, index + ${D});\n      return sampleTexture(${r}, uv);\n    }\n  `}(t,n);case 5:return function XU(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n[4],o=n[3]*s,i=n[2]*o,a=n[1]*i,{newShape:u,keptDims:c}=d.util.squeezeShape(n);if(u.length<n.length){const E=["row","col","depth","depth2","depth3"];return`\n      ${Fd(Ld(t,u))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Bd(E,c)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${i}, ${o}, ${s})) +\n          depth3;\n        ${Pd(t)}\n      }\n    `;const l=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,f=h[0],m=h[1];if(m===a&&null==l)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(m===s&&null==l)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} + depth * ${o} +\n          depth2 * ${s} + depth3 + ${ol(e)};\n      vec2 uv = uvFromFlat(${f}, ${m}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);case 6:return function qU(t){const n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:o}=d.util.squeezeShape(n);if(s.length<n.length){const D=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Fd(Ld(t,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Bd(D,o)});\n      }\n    `}const i=n[5],a=n[4]*i,u=n[3]*a,c=n[2]*u,l=n[1]*c;if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${l}, ${c}, ${u}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${Pd(t)}\n      }\n    `;const h=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,m=f[0],y=f[1];if(y===l&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${u}, ${a}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${y}.0, ${m}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(y===i&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${y}.0, ${m}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${c} + depth * ${u} +\n          depth2 * ${a} + depth3 * ${i} + depth4 + ${ol(e)};\n      vec2 uv = uvFromFlat(${m}, ${y}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(t);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function wE(t,n){switch(t.shapeInfo.logicalShape.length){case 0:return function LU(t){const n=t.name;return`\n    vec4 ${"get"+n.charAt(0).toUpperCase()+n.slice(1)}() {\n      return ${Do().texture2D}(${n}, halfCR);\n    }\n  `}(t);case 1:return function VU(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t.shapeInfo.texShape,o=Do();if(n)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${o.texture2D}(${e}, uv);\n    }\n  `}(t,n);case 2:return function WU(t,n){const e=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=o[0],a=o[1],u=Do();if(null!=o&&d.util.arraysEqual(e,o))return n?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `;if(n)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `;const c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}(t,n);case 3:return function HU(t,n){const e=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===e[0]){const m=[1,2],w=["b","row","col"];return`\n        ${wE(Ld(t,e.slice(1)),n)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${Bd(w,m)});\n        }\n      `}const a=Do();if(n)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const u=i[0],c=i[1],l=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${u}, ${c}, ${l*Math.ceil(e[1]/2)}, ${l}, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}(t,n);default:return function GU(t,n){const e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Do();if(n)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${e}, uv);\n    }\n  `;const o=t.shapeInfo.logicalShape,i=o.length,a=t.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=u[0],l=u[1],h=Math.ceil(o[i-1]/2);let f=h*Math.ceil(o[i-2]/2),m="int b, int row, int col",y=`b * ${f} + (row / 2) * ${h} + (col / 2)`;for(let w=2;w<i-1;w++)m=`int b${w}, `+m,f*=o[i-w-1],y=`b${w} * ${f} + `+y;return`\n    vec4 ${r}(${m}) {\n      int index = ${y};\n      int texR = index / ${l};\n      int texC = index - texR * ${l};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${c});\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(t,n)}}const EU="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",_U="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",IU="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",DU="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function ol(t){return`offset${t}`}function Pd(t){const n=t.name,e=d.util.sizeFromShape(t.shapeInfo.logicalShape);return e<2?`return ${n};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function Hr(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function P3(t,n,e){const{newShape:r,keptDims:s}=d.util.squeezeShape(n),o=n.length,i=t&&3===o&&1===n[0],a=i?n.slice(1):r,u=!t&&o>1&&!d.util.arraysEqual(n,e)&&r.length<o||i;return{useSqueezeShape:u,uniformShape:u?a:n,keptDims:s}}function Ld(t,n){const e=JSON.parse(JSON.stringify(t));return e.shapeInfo.logicalShape=n,e}function Bd(t,n){return n.map(e=>t[e]).join(", ")}function SE(t,n,e){const r={},s={},o={},i=[];let a,u,c,l=null,h=null;h=t.getUniformLocation(e,"NAN",!1),1===(0,d.env)().getNumber("WEBGL_VERSION")&&(l=t.getUniformLocation(e,"INFINITY",!1));const f=!1;for(let m=0;m<n.variableNames.length;m++){const y=n.variableNames[m];r[y]=t.getUniformLocation(e,y,f),r[`offset${y}`]=t.getUniformLocation(e,`offset${y}`,f),n.enableShapeUniforms&&(s[`${y}Shape`]=t.getUniformLocation(e,`${y}Shape`,f),o[`${y}TexShape`]=t.getUniformLocation(e,`${y}TexShape`,f))}return n.enableShapeUniforms&&(a=t.getUniformLocation(e,"outShape",f),c=t.getUniformLocation(e,"outShapeStrides",f),u=t.getUniformLocation(e,"outTexShape",f)),n.customUniforms&&n.customUniforms.forEach((m,y)=>{i[y]=t.getUniformLocation(e,m.name,f)}),{uniformLocations:r,customUniformLocations:i,infLoc:l,nanLoc:h,inShapesLocations:s,inTexShapesLocations:o,outShapeLocation:a,outShapeStridesLocation:c,outTexShapeLocation:u}}function EE(t,n){if(t.length!==n.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${n.length} inputs`);t.forEach((e,r)=>{const s=e.logicalShape,o=n[r],i=o.shape;if(!d.util.arraysEqual(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(e.isUniform&&o.isUniform)return;const a=e.texShape,u=o.isUniform?null:o.texData.texShape;if(!d.util.arraysEqual(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function To(t){return(0,d.env)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}class tW{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Rd.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Do();this.outputShape=n,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?dg(["r","c","d"],n):sl(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class nW{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Rd.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Do();this.outputShape=n,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?dg(["r","c","d"],n):sl(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class rW{constructor(n){this.variableNames=["A"],this.outTexUsage=pi.DOWNLOAD;const e=Do();this.outputShape=n,this.userCode=`\n      ${xE}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class sW{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=pi.DOWNLOAD;const e=Do();this.outputShape=n,this.userCode=`\n      ${xE}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class oW{constructor(n,e=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Do();this.outputShape=n,this.enableShapeUniforms=To(this.outputShape.length);let s="result";e&&(s="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":$3(n)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class iW{constructor(n,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Do();this.outputShape=n,this.enableShapeUniforms=To(this.outputShape.length);let s="",o="result";e&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const u=2*i+a;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${n[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${n[1]}`}) {\n            localCoords[1] += ${i};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${u}] = values[0];\n            } else if (offset == 1) {\n              result[${u}] = values[1];\n            } else if (offset == 2) {\n              result[${u}] = values[2];\n            } else {\n              result[${u}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":$3(n)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${r.output} = ${o};\n        }\n    `}}function Df(t,n,e,r,s,o){!function JV(t,n){const e=(0,d.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||n<=0)throw new Error(`Requested texture size [${t}x${n}] is invalid.`);if(t>e||n>e)throw new Error(`Requested texture size [${t}x${n}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(n,e);const i=function QV(t){return Wu(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}(t),a=t.TEXTURE_2D;return rn(t,()=>t.bindTexture(a,i)),rn(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),rn(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),rn(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),rn(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),1===(0,d.env)().getNumber("WEBGL_VERSION")?rn(t,()=>t.texImage2D(a,0,r,n,e,0,s,o,null)):rn(t,()=>t.texStorage2D(a,1,r,n,e)),rn(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:i,texShape:[e,n]}}function _E(t){return t.internalFormatFloat}function IE(t){return t.internalFormatHalfFloat}function DE(t){return t.downloadTextureFormat}function TE(t){return t.internalFormatPackedFloat}function NE(t){return t.internalFormatPackedHalfFloat}class L3{constructor(n){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=(0,d.env)().getNumber("WEBGL_VERSION");null!=n?(this.gl=n,function $V(t,n){vc[t]=n}(e,n)):this.gl=Ra(e);let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,d.env)().getNumber("WEBGL_VERSION")){const i="OES_texture_half_float";if(this.textureFloatExtension=og(this.gl,"OES_texture_float"),ua(this.gl,i))this.textureHalfFloatExtension=og(this.gl,i);else if((0,d.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),ua(this.gl,s))this.colorBufferHalfFloatExtension=og(this.gl,s);else if((0,d.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",ua(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!ua(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function uW(t){return function YV(t,n){const e=Wu(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return rn(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),rn(t,()=>t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)),e}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function cW(t){return function ZV(t,n){const e=Wu(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return rn(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e)),rn(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)),e}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function eU(t){return Wu(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=k3(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,d.env)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const n=this.gl;rn(n,()=>n.finish()),rn(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),rn(n,()=>n.deleteFramebuffer(this.framebuffer)),rn(n,()=>n.bindBuffer(n.ARRAY_BUFFER,null)),rn(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)),rn(n,()=>n.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(n,e){return this.throwIfDisposed(),function lW(t,n,e,r){const[s,o]=_f(n,e);return Df(t,s,o,_E(r),r.textureFormatFloat,t.FLOAT)}(this.gl,n,e,this.textureConfig)}createFloat16MatrixTexture(n,e){return this.throwIfDisposed(),function dW(t,n,e,r){const[s,o]=_f(n,e);return Df(t,s,o,IE(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,n,e,this.textureConfig)}createUnsignedBytesMatrixTexture(n,e){return this.throwIfDisposed(),function hW(t,n,e,r){const[s,o]=_f(n,e);return Df(t,s,o,DE(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,n,e,this.textureConfig)}uploadPixelDataToTexture(n,e){this.throwIfDisposed(),function yW(t,n,e){rn(t,()=>t.bindTexture(t.TEXTURE_2D,n)),e.data instanceof Uint8Array?2===(0,d.env)().getNumber("WEBGL_VERSION")?rn(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e.width,e.height,t.RGBA,t.UNSIGNED_BYTE,e.data)):rn(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e.width,e.height,0,t.RGBA,t.UNSIGNED_BYTE,e.data)):2===(0,d.env)().getNumber("WEBGL_VERSION")?rn(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,e)):rn(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e)),rn(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,n,e)}uploadDenseMatrixToTexture(n,e,r,s){this.throwIfDisposed(),function gW(t,n,e,r,s,o){let i,a,u;rn(t,()=>t.bindTexture(t.TEXTURE_2D,n)),s instanceof Uint8Array?(i=new Uint8Array(e*r*4),a=t.UNSIGNED_BYTE,u=t.RGBA):(i=new Float32Array(e*r*4),a=t.FLOAT,u=o.internalFormatPackedFloat),i.set(s),2===(0,d.env)().getNumber("WEBGL_VERSION")?rn(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e,r,t.RGBA,a,i)):rn(t,()=>t.texImage2D(t.TEXTURE_2D,0,u,e,r,0,t.RGBA,a,i)),rn(t,()=>t.bindTexture(t.TEXTURE_2D,null))}(this.gl,n,e,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(n,e){return this.throwIfDisposed(),function pW(t,n,e,r){const[s,o]=Od(n,e);return Df(t,s,o,NE(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,n,e,this.textureConfig)}createPackedMatrixTexture(n,e){return this.throwIfDisposed(),function fW(t,n,e,r){const[s,o]=Od(n,e);return Df(t,s,o,TE(r),t.RGBA,t.FLOAT)}(this.gl,n,e,this.textureConfig)}deleteMatrixTexture(n){this.throwIfDisposed(),this.outputTexture===n&&(gE(this.gl,this.framebuffer),this.outputTexture=null),rn(this.gl,()=>this.gl.deleteTexture(n))}downloadByteEncodedFloatMatrixFromOutputTexture(n,e,r){return this.downloadMatrixDriver(n,()=>function bW(t,n,e,r){const[s,o]=_f(n,e),a=new Uint8Array(function LV(t,n){return t*n}(n*e,4));return rn(t,()=>t.readPixels(0,0,s,o,r.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(n,e,r,s,o,i){return function wW(t,n,e,r,s,o,i,a){const u=t,c=new Float32Array(function BV(t,n){const[e,r]=Od(t,n);return e*r*4}(o,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,n),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}(this.gl,n,0,0,0,o,i)}downloadFloat32MatrixFromBuffer(n,e){return function xW(t,n,e){const r=t,s=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,n),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,n,e)}createBufferFromTexture(n,e,r){this.bindTextureToFrameBuffer(n);const s=function vW(t,n,e,r){const s=t.createBuffer();rn(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,s));const a=16*n*e;return rn(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),rn(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,0)),rn(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const n=this.createFence(this.gl);return this.pollFence(n)}createFence(n){let e,r;if((0,d.env)().getBool("WEBGL_FENCE_API_ENABLED")){const s=n,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush(),r=()=>{const i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},e=o}else(0,d.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,(0,d.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(n,e,r){return this.downloadMatrixDriver(n,()=>function CW(t,n,e){const r=new Float32Array(n*e*4);return rn(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,r)),r}(this.gl,e,r))}createProgram(n){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function aW(t){const n=Do();return function jV(t,n){const e=Wu(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(rn(t,()=>t.shaderSource(e,n)),rn(t,()=>t.compileShader(e)),!1===t.getShaderParameter(e,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(t,`${n.version}\n    precision highp float;\n    ${n.attribute} vec3 clipSpacePos;\n    ${n.attribute} vec2 uv;\n    ${n.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function XV(t){return Wu(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}(e);return rn(e,()=>e.attachShader(r,this.vertexShader)),rn(e,()=>e.attachShader(r,n)),function qV(t,n){if(rn(t,()=>t.linkProgram(n)),!(0,d.env)().get("ENGINE_COMPILE_ONLY")&&!1===t.getProgramParameter(n,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}(e,r),this.debug&&A3(e,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=function mW(t,n,e){return rn(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),mE(t,n,"clipSpacePos",e,3,20,0)&&mE(t,n,"uv",e,2,20,12)}(e,this.program,this.vertexBuffer)),r}deleteProgram(n){this.throwIfDisposed(),n===this.program&&(this.program=null),null!=n&&rn(this.gl,()=>this.gl.deleteProgram(n))}setProgram(n){this.throwIfDisposed(),this.program=n,null!=this.program&&this.debug&&A3(this.gl,this.program),rn(this.gl,()=>this.gl.useProgram(n))}getUniformLocation(n,e,r=!0){return this.throwIfDisposed(),r?function nU(t,n,e){return Wu(t,()=>t.getUniformLocation(n,e),'uniform "'+e+'" not present in program.')}(this.gl,n,e):function rU(t,n,e){return t.getUniformLocation(n,e)}(this.gl,n,e)}getAttributeLocation(n,e){return this.throwIfDisposed(),rn(this.gl,()=>this.gl.getAttribLocation(n,e))}getUniformLocationNoThrow(n,e){return this.throwIfDisposed(),this.gl.getUniformLocation(n,e)}setInputMatrixTexture(n,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),sU(this.gl,n,e,r)}setOutputMatrixTexture(n,e,r){this.setOutputMatrixTextureDriver(n,r,e)}setOutputPackedMatrixTexture(n,e,r){this.throwIfDisposed();const[s,o]=Od(e,r);this.setOutputMatrixTextureDriver(n,s,o)}setOutputMatrixWriteRegion(n,e,r,s){this.setOutputMatrixWriteRegionDriver(r,n,s,e)}setOutputPackedMatrixWriteRegion(n,e,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&A3(this.gl,this.program),ig(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const n=this.gl;this.debug&&this.debugValidate(),rn(n,()=>n.drawElements(n.TRIANGLES,6,n.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),rn(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=og(this.gl,2===(0,d.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,d.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const n=this.getQueryTimerExtensionWebGL1(),e=n.createQueryEXT();return n.beginQueryEXT(n.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===(0,d.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const n=this.getQueryTimerExtensionWebGL1();n.endQueryEXT(n.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(n){var e=this;return(0,bs.Z)(function*(){return yield d.util.repeatedTry(()=>e.disposed||e.isQueryAvailable(n,(0,d.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(n,(0,d.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(n,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(n,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(n,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(n,e){if(0===e)return!0;if(2===e){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(n,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(n,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(n){return new Promise(e=>{this.addItemToPoll(()=>n.isFencePassed(),()=>e())})}pollItems(){const n=function SW(t){let n=0;for(;n<t.length&&t[n]();++n);return n-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=n;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(n+1)}addItemToPoll(n,e){if(this.itemsToPoll.push({isDoneFn:n,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in(0,d.env)().platform&&(r=(0,d.env)().platform.setTimeoutCustom.bind((0,d.env)().platform)),d.util.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(n){this.throwIfDisposed(),R3(this.gl,n,this.framebuffer),this.debug&&ig(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(R3(this.gl,this.outputTexture,this.framebuffer),this.debug&&ig(this.gl)):gE(this.gl,this.framebuffer)}downloadMatrixDriver(n,e){this.bindTextureToFrameBuffer(n);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(n,e,r){this.throwIfDisposed();const s=this.gl;R3(s,n,this.framebuffer),this.debug&&ig(s),this.outputTexture=n,rn(s,()=>s.viewport(0,0,e,r)),rn(s,()=>s.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(n,e,r,s){this.throwIfDisposed(),rn(this.gl,()=>this.gl.scissor(n,e,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:EW,bincountImpl:kE,bincountReduceImpl:_W,castImpl:IW,ceilImpl:DW,concatImpl:TW,equalImpl:NW,expImpl:kW,expm1Impl:AW,floorImpl:RW,gatherNdImpl:OW,gatherV2Impl:MW,greaterImpl:$W,greaterEqualImpl:FW,lessImpl:PW,lessEqualImpl:LW,linSpaceImpl:BW,logImpl:VW,maxImpl:UW,maximumImpl:WW,minimumImpl:zW,multiplyImpl:HW,negImpl:jW,notEqualImpl:GW,prodImpl:KW,raggedGatherImpl:XW,raggedTensorToTensorImpl:qW,rangeImpl:YW,rsqrtImpl:ZW,scatterImpl:QW,sigmoidImpl:JW,simpleAbsImpl:AE,sliceImpl:ez,sparseFillEmptyRowsImpl:tz,sparseReshapeImpl:nz,sparseSegmentReductionImpl:RE,sqrtImpl:rz,stridedSliceImpl:sz,stringNGramsImpl:oz,stringSplitImpl:iz,stringToHashBucketFastImpl:az,subImpl:uz,tileImpl:cz,topKImpl:lz,transposeImpl:B3,uniqueImpl:dz}=_e;function OE(t,n){return["x","y","z","w","u","v"].slice(0,n).map(e=>`${t}.${e}`)}function No(t,n){return 1===n?[t]:OE(t,n)}class fz{constructor(n){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.enableShapeUniforms=To(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=No("rc",this.rank),r=Hr(this.rank),s=this.getOutOfBoundsCondition(e),o=this.getSetup(e),i=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}getSourceCoordsArr(n){const e=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${n[n.length-1-i]},`+o;e.push(o)}return e}getOutOfBoundsCondition(n){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${n[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(n){if(1===this.rank)return"";const e=n.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(n){const e=this.getSourceCoordsArr(n);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class ME{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=n,this.enableShapeUniforms=To(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2==1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`\n        ${o}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}this.userCode=`\n      ${function pz(t,n){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${n?function mU(t,n,e="index"){const s=function pU(t,n){const e=t.length,r=t.map(o=>`${n}[${o}]`),s=new Array(e-1);s[e-2]=r[e-1];for(let o=e-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}(t.map((o,i)=>i),n);return s.map((o,i)=>`int ${t[i]} = ${e} / ${s[i]}; ${i===s.length-1?`int ${t[i+1]} = ${e} - ${t[i]} * ${s[i]}`:`index -= ${t[i]} * ${s[i]}`};`).join("")}(["r","c","d"],"inputShape"):sl(["r","c","d"],t)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":$3(n)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":n[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":n[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class mz{constructor(n){this.gpgpu=n,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(n,e,r){const s=FE(e,r),o=PE(n,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=$E(n,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const u=this.freeTextures[o].shift();return this.usedTextures[o].push(u),u}let a;return s===Xs.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(n[0],n[1]):s===Xs.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(n[0],n[1]):s===Xs.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(n[0],n[1]):s===Xs.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(n[0],n[1]):s===Xs.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(n[0],n[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(n,e,r,s){if(null==this.freeTextures)return;const o=FE(r,s),i=PE(e,o,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=$E(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),u=(0,d.env)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==u&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(n.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(n),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[i],l=c.indexOf(n);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(l,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const n in this.freeTextures)this.freeTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const n in this.usedTextures)this.usedTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function $E(t,n,e,r,s){const o=function yz(t,n){switch(t){case Xs.PACKED_2X2_FLOAT32:return TE(n);case Xs.PACKED_2X2_FLOAT16:return NE(n);case Xs.UNPACKED_FLOAT32:return _E(n);case Xs.UNPACKED_FLOAT16:return IE(n);case Xs.PACKED_4X1_UNSIGNED_BYTE:return DE(n);default:throw new Error(`Unknown physical texture type ${t}`)}}(n,r);let i;if(s){const[u,c]=Od(t[0],t[1]);i=u*c}else{const[u,c]=_f(t[0],t[1]);i=u*c}const a=function gz(t,n){if(n===t.R32F)return 4;if(n===t.R16F)return 2;if(n===t.RGBA32F)return 16;if(n===t.RGBA)return 16;if(n===t.RGBA16F)return 8;if(n===t.RGBA8)return 4;throw new Error(`Unknown internal format ${n}`)}(e,o);return i*a}function FE(t,n){if(t===pi.UPLOAD)return Xs.PACKED_2X2_FLOAT32;if(t===pi.RENDER||null==t)return function vz(t){return(0,d.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?Xs.PACKED_2X2_FLOAT32:Xs.UNPACKED_FLOAT32:t?Xs.PACKED_2X2_FLOAT16:Xs.UNPACKED_FLOAT16}(n);if(t===pi.DOWNLOAD||t===pi.PIXELS)return Xs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function PE(t,n,e){return`${t[0]}_${t[1]}_${n}_${e}`}class zu{constructor(n,e){this.variableNames=["A"],this.outputShape=n,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Li="if (isnan(x)) return x;",xz="return x;",LE="return abs(x);",bz="return (x >= 0.0) ? x : (exp(x) - 1.0);",wz=Li+"\n  return (x < 0.0) ? 0.0 : x;\n",Cz=Li+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Vd="return x;",Sz="return 1.0 / (1.0 + exp(-1.0 * x));",Ez="return x;",_z="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",Iz="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Dz="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Tz="return 1.0 / (1.0 + exp(-1.0 * x));";class il{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class Nz{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=n,this.enableShapeUniforms=To(this.outputShape.length);const e=n.length,r=No("rc",e),s=Hr(e),o=function hz(t,n){if(1===t)return"rc";let e="";for(let r=0;r<t;r++)e+=n[r],r<t-1&&(e+=",");return e}(e,r),i=r.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const kz=d.kernel_impls.whereImpl,fg={},Mz=(0,d.env)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let Pz=(()=>{class t extends d.KernelBackend{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,d.env)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof L3)r=e;else{const s=Ra((0,d.env)().getNumber("WEBGL_VERSION"),e);r=new L3(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Ra((0,d.env)().getNumber("WEBGL_VERSION"));r=new L3(s),this.binaryCache=function Oz(t){return t in fg||(fg[t]={}),fg[t]}((0,d.env)().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new mz(this.gpgpu),this.numMBBeforeWarning=function Fz(){return null==(0,d.env)().global.screen?1024:(0,d.env)().global.screen.height*(0,d.env)().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new d.DataStorage(this,(0,d.engine)())}nextDataId(){return t.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,r,s){if(((0,d.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,d.env)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===s&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:r,dtype:s,values:e,usage:pi.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,s,o,i){if((0,d.env)().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===o)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:o,values:r,usage:pi.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:s,dtype:o,complexTensorInfos:i,slice:a,shape:u,isPacked:c}=r;if(null!=a){let m;m=c?new il(u,Vd):new zu(u,Vd);const y=this.runWebGLProgram(m,[{dataId:e,shape:u,dtype:o}],o),w=this.readSync(y.dataId);return this.disposeIntermediateTensorInfo(y),w}if(null!=s)return this.convertAndCacheOnCPU(e);if("string"===o)return s;const l=null!=this.activeTimers;let h,f;if(l&&(h=d.util.now()),"complex64"===o){const m=this.readSync(i.real.dataId),y=this.readSync(i.imag.dataId);f=d.backend_util.mergeRealAndImagArrays(m,y)}else f=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=d.util.now()-h),this.convertAndCacheOnCPU(e,f)}read(e){var r=this;return(0,bs.Z)(function*(){if(r.pendingRead.has(e)){const E=r.pendingRead.get(e);return new Promise(D=>E.push(D))}const s=r.texData.get(e),{values:o,shape:i,slice:a,dtype:u,complexTensorInfos:c,isPacked:l}=s;if(null!=a){let E;E=l?new il(i,Vd):new zu(i,Vd);const D=r.runWebGLProgram(E,[{dataId:e,shape:i,dtype:u}],u),O=r.read(D.dataId);return r.disposeIntermediateTensorInfo(D),O}if(null!=o)return r.convertAndCacheOnCPU(e);if((0,d.env)().getBool("DEBUG")&&!(0,d.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,d.env)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let f,m,h=null;if("complex64"!==u&&(0,d.env)().get("WEBGL_BUFFER_SUPPORTED")){f=r.decode(e);const E=r.texData.get(f.dataId);h=r.gpgpu.createBufferFromTexture(E.texture.texture,...sg(i))}if(r.pendingRead.set(e,[]),"complex64"!==u&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===u){const E=yield Promise.all([r.read(c.real.dataId),r.read(c.imag.dataId)]);m=d.backend_util.mergeRealAndImagArrays(E[0],E[1])}else if(null==h)m=r.getValuesFromTexture(e);else{const E=d.util.sizeFromShape(i);m=r.gpgpu.downloadFloat32MatrixFromBuffer(h,E)}if(null!=f&&r.disposeIntermediateTensorInfo(f),null!=h){const E=r.gpgpu.gl;rn(E,()=>E.deleteBuffer(h))}const y=r.convertAndCacheOnCPU(e,m),w=r.pendingRead.get(e);return r.pendingRead.delete(e),w.forEach(E=>E(y)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&(0,d.engine)().removeDataId(e,r),r.pendingDeletes--),y})()}readToGPU(e,r={}){const s=this.texData.get(e),{values:o,shape:i,slice:a,dtype:u,isPacked:c,texture:l}=s;if("complex64"===u)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let y;y=c?new il(i,Vd):new zu(i,Vd);const w=this.runWebGLProgram(y,[{dataId:e,shape:i,dtype:u}],u),E=this.readToGPU(w,r);return this.disposeIntermediateTensorInfo(w),E}if(null==l)throw null!=o?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const h=this.decode(e,r.customTexShape),f=(0,d.engine)().makeTensorFromTensorInfo(h),m=this.texData.get(h.dataId);return Object.assign({tensorRef:f},m.texture)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(o=>d.util.decodeString(o));return(0,d.buffer)(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,d.buffer)(e.shape,e.dtype,r)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const s=e[r];if(!zV(s))throw(0,d.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:s,isPacked:o}=this.texData.get(e),i=d.util.sizeFromShape(r);if((0,d.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(e),y=this.texData.get(m.dataId),w=this.gpgpu.downloadMatrixFromPackedTexture(y.texture.texture,...sg(r)).subarray(0,i);return this.disposeIntermediateTensorInfo(m),w}const a=(0,d.env)().getBool("WEBGL_PACK")&&!0===o,u=a?O3(r):r,c=a?new sW(u):new rW(u),l=this.runWebGLProgram(c,[{shape:u,dtype:s,dataId:e}],"float32"),h=this.texData.get(l.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(l),f}timerAvailable(){return(0,d.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const s=this.activeTimers,o=[];let i=!1;null==this.programTimersStack?(this.programTimersStack=o,i=!0):this.activeTimers.push(o),this.activeTimers=o,e();const a=d.util.flatten(this.activeTimers.map(l=>l.query)).filter(l=>null!=l),u=d.util.flatten(this.activeTimers.map(l=>l.name)).filter(l=>null!=l);this.activeTimers=s,i&&(this.programTimersStack=null);const c={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(0,bs.Z)(function*(){if((0,d.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=yield Promise.all(a);c.kernelMs=d.util.sum(l),c.getExtraProfileInfo=()=>l.map((h,f)=>({name:u[f],ms:h})).map(h=>`${h.name}: ${h.ms}`).join(", ")}else c.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,c})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,d.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:d.util.now(),endMs:null}}endTimer(e){return(0,d.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=d.util.now(),e)}getQueryTime(e){var r=this;return(0,bs.Z)(function*(){return(0,d.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return null!=s&&(this.disposeData(s.real.dataId,r),this.disposeData(s.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:s,texShape:o,usage:i,isPacked:a,slice:u}=this.texData.get(e),c=u&&u.origDataId||e,l=this.dataRefCount.get(c);l>1?this.dataRefCount.set(c,l-1):(this.dataRefCount.delete(c),null!=r&&(this.numBytesInGPU-=this.computeBytes(o,s),this.textureManager.releaseTexture(r,o,i,a)));const h=this.texData.get(e);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=Mz){return(0,d.env)().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>null==this.texData.get(s.dataId).texture&&d.util.sizeFromShape(s.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){d.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return kz(e.shape,r)}packedUnaryOp(e,r,s){const o=new il(e.shape,r),i=this.compileAndRun(o,[e],s);return(0,d.engine)().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const o=AE(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if((0,d.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,LE,e.dtype);const r=new zu(e.shape,LE),s=this.compileAndRun(r,[e]);return(0,d.engine)().makeTensorFromTensorInfo(s)}makeTensorInfo(e,r,s){let o;if("string"===r&&null!=s&&s.length>0&&d.util.isString(s[0])){const i=s.map(a=>d.util.encodeString(a));o=this.write(i,e,r)}else o=this.write(s,e,r);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:r}}makeOutput(e,r,s){return(0,d.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,s),this)}unpackTensor(e){const r=new Nz(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new fz(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const s=[Md(e.shape),...$d(e.shape)],o={dtype:e.dtype,shape:s,dataId:e.dataId},i=[Md(r),...$d(r)],a=new ME(i,s),l=this.runWebGLProgram(a,[o],e.dtype,[s],!0);return{dataId:l.dataId,shape:r,dtype:l.dtype}}decode(e,r){const s=this.texData.get(e),{isPacked:o,shape:i,dtype:a}=s;if(null!=r){const m=d.util.sizeFromShape(i);d.util.assert(m<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const u=O3(i);let c;c=o?new nW(u):new tW(u);const h=[r??sg(u)];return{dtype:a,shape:i,dataId:this.runWebGLProgram(c,[{shape:u,dtype:a,dataId:e}],a,h,!0,r).dataId}}runWebGLProgram(e,r,s,o,i=!1,a){const u=this.makeTensorInfo(e.outputShape,s),c=this.texData.get(u.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===Rd.DENSE){const O=a??sg(e.outputShape);c.texShape=O.map(W=>2*W)}if(null!=e.outTexUsage&&(c.usage=e.outTexUsage),0===d.util.sizeFromShape(u.shape))return c.values=d.util.getTypedArrayFromDType(u.dtype,0),u;const l=[],h=r.map(O=>{if("complex64"===O.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let W=this.texData.get(O.dataId);if(null==W.texture){if(!e.packedInputs&&d.util.sizeFromShape(O.shape)<=(0,d.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:O.shape,texData:null,isUniform:!0,uniformValues:W.values};e.packedInputs&&(W.isPacked=!0,W.shape=O.shape)}if(this.uploadToGPU(O.dataId),!!W.isPacked!=!!e.packedInputs)O=W.isPacked?this.unpackTensor(O):this.packTensor(O),l.push(O),W=this.texData.get(O.dataId);else if(W.isPacked&&!ug(W.shape,O.shape)){const q=O,re=O.shape;O.shape=W.shape,O=this.packedReshape(O,re),l.push(O),W=this.texData.get(O.dataId),q.shape=re}return{shape:O.shape,texData:W,isUniform:!1}});this.uploadToGPU(u.dataId);const f={shape:u.shape,texData:c,isUniform:!1},m=function eW(t,n,e){let r="";n.concat(e).forEach(i=>{const a=null!=i.texData&&null!=i.texData.slice&&i.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!i.isUniform){const u=i.texData.texShape,{useSqueezeShape:c,uniformShape:l,keptDims:h}=P3(t.packedInputs,i.shape,u);let f="",m="",y="";if(1===l.length&&t.packedInputs){const re=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];f=`${re[0]>1}_${re[1]>1}`}else if(2!==l.length||t.packedInputs){if(l.length>2&&!t.packedInputs){const re=d.util.computeStrides(l);y=`${re[0]===u[1]}_${re[re.length-1]===u[1]}`}}else m=`${l[0]>1}_${l[1]>1}`;const w=i.shape.length,E=2===l.length&&d.util.arraysEqual(i.shape,u),D=1===d.util.sizeFromShape(i.shape),O=d.backend_util.getBroadcastDims(i.shape,e.shape),W=!t.packedInputs&&w===e.shape.length&&d.util.arraysEqual(u,e.texData.texShape);r+=`${w}_${W}_${c?h:""}_${l.length}_${D}_${O}_${E}_${f}_${m}_${y}_${t.packedInputs||l.length>2?"":`${u[0]>1}_${u[1]>1}`}_${a}`}else r+=`${i.shape}_${i.isUniform?"uniform":i.texData.texShape}_${a}`});let o=t.constructor.name;return o+="_"+r+"_"+t.userCode+`${(0,d.env)().getNumber("WEBGL_VERSION")}`,o}(e,h,f),y=this.getAndSaveBinary(m,()=>function QU(t,n,e,r){const s=e.map((l,h)=>{const f={logicalShape:l.shape,texShape:l.isUniform?null:l.texData.texShape,isUniform:l.isUniform,isPacked:!l.isUniform&&l.texData.isPacked,flatOffset:null};return null!=l.texData&&null!=l.texData.slice&&l.texData.slice.flatOffset>0&&(f.flatOffset=l.texData.slice.flatOffset),{name:n.variableNames[h],shapeInfo:f}}),o=s.map(l=>l.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=gU(s,i,n),u=function GV(t,n){const e=Wu(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(rn(t,()=>t.shaderSource(e,n)),rn(t,()=>t.compileShader(e)),(0,d.env)().get("ENGINE_COMPILE_ONLY"))return e;if(!1===t.getShaderParameter(e,t.COMPILE_STATUS))throw pE(n,t.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(t.gl,a),c=t.createProgram(u);return(0,d.env)().get("ENGINE_COMPILE_ONLY")?{program:n,fragmentShader:u,source:a,webGLProgram:c,inShapeInfos:o,outShapeInfo:i,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:n,fragmentShader:u,source:a,webGLProgram:c,inShapeInfos:o,outShapeInfo:i},SE(t,n,c))}(this.gpgpu,e,h,f)),w=null!=this.activeTimers;let E;w&&(E=this.startTimer()),(0,d.env)().get("ENGINE_COMPILE_ONLY")||function JU(t,n,e,r,s){n.program.enableShapeUniforms||(EE(n.inShapeInfos,e),EE([n.outShapeInfo],[r]));const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):t.setOutputMatrixTexture(o.texture,i[0],i[1]),t.setProgram(n.webGLProgram),1===(0,d.env)().getNumber("WEBGL_VERSION")&&null!==n.infLoc&&t.gl.uniform1f(n.infLoc,1/0),null!==n.nanLoc&&t.gl.uniform1f(n.nanLoc,NaN),e.forEach((u,c)=>{const l=n.program.variableNames[c],h=n.uniformLocations[l],f=n.uniformLocations[`offset${l}`],m=n.inShapesLocations[`${l}Shape`],y=n.inTexShapesLocations[`${l}TexShape`];if(m){const{uniformShape:w}=P3(n.program.packedInputs,u.shape,u.texData.texShape);switch(w.length){case 1:t.gl.uniform1iv(m,new Int32Array(w));break;case 2:t.gl.uniform2iv(m,new Int32Array(w));break;case 3:t.gl.uniform3iv(m,new Int32Array(w));break;case 4:t.gl.uniform4iv(m,new Int32Array(w))}}if(y&&t.gl.uniform2i(y,u.texData.texShape[0],u.texData.texShape[1]),null!=h){if(u.isUniform){if(d.util.sizeFromShape(u.shape)<2)t.gl.uniform1f(h,u.uniformValues[0]);else{let w=u.uniformValues;w instanceof Float32Array||(w=new Float32Array(w)),t.gl.uniform1fv(h,w)}return}null!=u.texData.slice&&null!=f&&t.gl.uniform1i(f,u.texData.slice.flatOffset),t.setInputMatrixTexture(u.texData.texture.texture,h,c)}});const a=n.outShapeLocation;if(a)switch(r.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(r.shape))}if(n.outShapeStridesLocation){const u=d.util.computeStrides(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(n.outShapeStridesLocation,new Int32Array(u));break;case 3:t.gl.uniform2iv(n.outShapeStridesLocation,new Int32Array(u));break;case 4:t.gl.uniform3iv(n.outShapeStridesLocation,new Int32Array(u))}}n.outTexShapeLocation&&t.gl.uniform2i(n.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),n.program.customUniforms&&s&&n.program.customUniforms.forEach((u,c)=>{const l=n.customUniformLocations[c],h=s[c];if("float"===u.type)t.gl.uniform1fv(l,h);else if("vec2"===u.type)t.gl.uniform2fv(l,h);else if("vec3"===u.type)t.gl.uniform3fv(l,h);else if("vec4"===u.type)t.gl.uniform4fv(l,h);else if("int"===u.type)t.gl.uniform1iv(l,h);else if("ivec2"===u.type)t.gl.uniform2iv(l,h);else if("ivec3"===u.type)t.gl.uniform3iv(l,h);else{if("ivec4"!==u.type)throw Error(`uniform type ${u.type} is not supported yet.`);t.gl.uniform4iv(l,h)}}),t.executeProgram()}(this.gpgpu,y,h,f,o),l.forEach(O=>this.disposeIntermediateTensorInfo(O)),w&&(E=this.endTimer(E),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(E)}));const D=(0,d.env)().get("WEBGL_FLUSH_THRESHOLD");if(D>0){const O=d.util.now();O-this.lastGlFlushTime>D&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=O)}if(!(0,d.env)().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&!1===i){const O=this.unpackTensor(u);return this.disposeIntermediateTensorInfo(u),O}return u}compileAndRun(e,r,s,o,i=!1){return this.runWebGLProgram(e,r,s=s||r[0].dtype,o,i)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,d.env)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,d.tidy)(()=>{if(!(0,d.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=(0,d.env)().getBool("DEBUG");(0,d.env)().set("DEBUG",!1);const r=this.abs((0,d.scalar)(1e-8)).dataSync()[0];if((0,d.env)().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:s,dtype:o,values:i,texture:a,usage:u,isPacked:c}=r;if(null!=a)return;const l=null!=this.activeTimers;let h;l&&(h=d.util.now());let f=r.texShape;if(null==f&&(f=function iU(t,n=!1){let e=(0,d.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=(0,d.env)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&(0,d.env)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),n&&(e*=2,r*=2,1===(t=t.map((a,u)=>u>=t.length-2?d.util.nearestLargerEven(t[u]):t[u])).length&&(t=[2,t[0]])),2!==t.length&&(t=d.util.squeezeShape(t).newShape);let s=d.util.sizeFromShape(t),o=null;t.length<=1&&s<=e?o=[1,s]:2===t.length&&t[0]<=e&&t[1]<=e?o=t:3===t.length&&t[0]*t[1]<=e&&t[2]<=e?o=[t[0]*t[1],t[2]]:3===t.length&&t[0]<=e&&t[1]*t[2]<=e?o=[t[0],t[1]*t[2]]:4===t.length&&t[0]*t[1]*t[2]<=e&&t[3]<=e?o=[t[0]*t[1]*t[2],t[3]]:4===t.length&&t[0]<=e&&t[1]*t[2]*t[3]<=e&&(o=[t[0],t[1]*t[2]*t[3]]);const i=null!=o&&Math.max(...o)>r&&Math.min(...o)<=(n?2:1)&&Math.min(...o)>0;if(null==o||i)if(n){const a=Md(t);let u=2,c=2;t.length&&([u,c]=$d(t)),s=a*(u/2)*(c/2),o=d.util.sizeToSquarishShape(s).map(l=>2*l)}else o=d.util.sizeToSquarishShape(s);return o}(s,c),r.texShape=f),null!=i){const m=O3(s);let y,w=f[1],E=f[0];const D=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(c||!D)&&([w,E]=Od(f[0],f[1])),y=c?new iW(m,D):new oW(m,D);const O=D?[E,w]:f,W=this.makeTensorInfo(O,o),q=this.texData.get(W.dataId);q.usage=D?pi.PIXELS:pi.UPLOAD,q.texShape=O,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(W.dataId),w,E,i);const Ae=this.runWebGLProgram(y,[W],o,[[E,w]],!0),Be=this.texData.get(Ae.dataId);r.texShape=Be.texShape,r.isPacked=Be.isPacked,r.usage=Be.usage,(0,d.env)().get("ENGINE_COMPILE_ONLY")?this.disposeData(Ae.dataId):(r.texture=Be.texture,r.values=null,this.texData.delete(Ae.dataId)),this.disposeIntermediateTensorInfo(W),l&&(this.uploadWaitMs+=d.util.now()-h)}else{const m=this.acquireTexture(f,u,o,c);r.texture=m}}convertAndCacheOnCPU(e,r){const s=this.texData.get(e),{dtype:o}=s;return this.releaseGPUData(e),null!=r&&(s.values=function Lz(t,n){if("float32"===n||"complex64"===n)return t;if("int32"===n||"bool"===n){const e="int32"===n?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<e.length;++r)e[r]=Math.round(t[r]);return e}throw new Error(`Unknown dtype ${n}`)}(r,o)),s.values}acquireTexture(e,r,s,o){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,o)}computeBytes(e,r){return e[0]*e[1]*d.util.bytesPerElement(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return(0,bs.Z)(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,s]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(s));return Promise.all(r)}for(const[,s]of Object.entries(e.binaryCache)){const o=new Promise(i=>{try{e.checkCompletion_(s),i(!0)}catch(a){throw a}});r.push(o)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return(0,bs.Z)(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield(0,d.nextFrame)(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(pE(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:r,customUniformLocations:s,infLoc:o,nanLoc:i,inShapesLocations:a,inTexShapesLocations:u,outShapeLocation:c,outShapeStridesLocation:l,outTexShapeLocation:h}=SE(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=r,e.customUniformLocations=s,e.infLoc=o,e.nanLoc=i,e.inShapesLocations=a,e.inTexShapesLocations=u,e.outShapeLocation=c,e.outShapeStridesLocation=l,e.outTexShapeLocation=h}}}return t.nextDataId=0,t})();d.device_util.isBrowser()&&(0,d.registerBackend)("webgl",()=>new Pz,2);const V3="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class Ud{constructor(n,e,r){this.variableNames=["A","B"],this.outputShape=d.backend_util.assertAndGetBroadcastShape(e,r),this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${n}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const Tf="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class Nf{constructor(n,e,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=d.backend_util.assertAndGetBroadcastShape(e,r);const o=this.outputShape.length;this.enableShapeUniforms=To(o);let i="";if(s)if(0===o||1===d.util.sizeFromShape(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${Hr(o)} coords = getOutputCoords();\n        `,1===o)i+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const u=No("coords",o);i+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${u[o-2]} + 1) >= outShape[${o} - 2];\n            bool nextColOutOfBounds =\n              (${u[o-1]} + 1) >= outShape[${o} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${u[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${u[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${n}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function mi(t){const{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Vz={kernelName:d.Identity,backendName:"webgl",kernelFunc:mi};function xc(t){const{inputs:n,backend:e}=t,{real:r,imag:s}=n,o=e.makeTensorInfo(r.shape,"complex64"),i=e.texData.get(o.dataId),a=mi({inputs:{x:r},backend:e}),u=mi({inputs:{x:s},backend:e});return i.complexTensorInfos={real:a,imag:u},o}const Uz={kernelName:d.Complex,backendName:"webgl",kernelFunc:xc},BE="return (a < 0.) ? b * a : a;",VE="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",zz={kernelName:d.LeakyRelu,backendName:"webgl",kernelFunc:function Wz(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{alpha:o}=r,i=e.makeTensorInfo([],"float32",d.util.createScalarValue(o,"float32")),a=(0,d.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Nf(VE,s.shape,i.shape):new Ud(BE,s.shape,i.shape),u=e.runWebGLProgram(a,[s,i],"float32");return e.disposeIntermediateTensorInfo(i),u}},UE="return (a < 0.) ? b * a : a;",WE="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",jz={kernelName:d.Prelu,backendName:"webgl",kernelFunc:function Hz(t){const{inputs:n,backend:e}=t,{x:r,alpha:s}=n,o=(0,d.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Nf(WE,r.shape,s.shape):new Ud(UE,r.shape,s.shape);return e.runWebGLProgram(o,[r,s],"float32")}},Wd="if (isnan(x)) return x;";function vr({opSnippet:t,packedOpSnippet:n,cpuKernelImpl:e,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,u=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&null!=e){const h=a.texData.get(i.dataId),f=e(h.values,u);return a.makeTensorInfo(i.shape,u,f)}let l;return l=(0,d.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new il(i.shape,n):new zu(i.shape,t),a.runWebGLProgram(l,[i],u)}}function ro({opSnippet:t,packedOpSnippet:n,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:u,b:c}=i,l=a;if(r&&"complex64"===u.dtype){const y=l.texData.get(u.dataId),w=l.texData.get(c.dataId),[E,D]=[[y.complexTensorInfos.real,w.complexTensorInfos.real],[y.complexTensorInfos.imag,w.complexTensorInfos.imag]].map(W=>{const[q,re]=W,pe={dataId:q.dataId,dtype:q.dtype,shape:u.shape},Ae={dataId:re.dataId,dtype:re.dtype,shape:c.shape},Be=new Ud(t,u.shape,c.shape);return l.runWebGLProgram(Be,[pe,Ae],(0,d.upcastType)(q.dtype,re.dtype))}),O=xc({inputs:{real:E,imag:D},backend:l});return l.disposeIntermediateTensorInfo(E),l.disposeIntermediateTensorInfo(D),O}const h=o||(0,d.upcastType)(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||l.shouldExecuteOnCPU([u,c]))&&null!=s){const y=l.texData.get(u.dataId).values,w=l.texData.get(c.dataId).values,E="string"===u.dtype?d.backend_util.fromUint8ToStringArray(y):y,D="string"===u.dtype?d.backend_util.fromUint8ToStringArray(w):w,[O,W]=s(u.shape,c.shape,E,D,h),q=l.makeTensorInfo(W,h);return l.texData.get(q.dataId).values=O,q}let m;return m=(0,d.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new Nf(n,u.shape,c.shape,e):new Ud(t,u.shape,c.shape),l.runWebGLProgram(m,[u,c],h)}}function kf(t,n=!1){if("linear"===t)return n?Ez:xz;if("relu"===t)return n?Iz:wz;if("elu"===t)return n?_z:bz;if("relu6"===t)return n?Dz:Cz;if("prelu"===t)return n?WE:UE;if("leakyrelu"===t)return n?VE:BE;if("sigmoid"===t)return n?Tz:Sz;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class zE{constructor(n,e,r,s=!1,o=!1,i=!1,a=null,u=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=To(this.outputShape.length);const h=Math.ceil((s?n[1]:n[2])/2),f=s?"i * 2, rc.y":"rc.y, i * 2",m=o?"rc.z, i * 2":"i * 2, rc.z",y=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],w=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let E="",D="";a&&(E=u?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:c?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,D="result = activation(result);");const O=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let W="rc.x",q="rc.x";n[0]<e[0]?W=`int(min(float(rc.x), ${n[0]-1}.))`:e[0]<n[0]&&(q=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`\n      ${E}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${h}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${h}; i++) {\n          int batchA = ${W};\n          int batchB = ${q};\n          vec4 a = getMatrixA(batchA, ${f});\n          vec4 b = getMatrixB(batchB, ${m});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${y[0]} * ${w[0]});\n          result += (${y[1]} * ${w[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${O}\n\n        ${D}\n\n        setOutput(result);\n      }\n    `}}const HE={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class jE{constructor(n,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=d.backend_util.assertAndGetBroadcastShape(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${n}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const GE="return a * b;";function U3(t){const{inputs:n,backend:e}=t,{a:r,b:s}=n,o=d.backend_util.upcastType(r.dtype,s.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),u=e.texData.get(s.dataId),c=new jE(HE.REAL,r.shape,s.shape),l=new jE(HE.IMAG,r.shape,s.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:s.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:s.shape}],f=e.runWebGLProgram(c,h,"float32"),m=e.runWebGLProgram(l,h,"float32"),y=xc({inputs:{real:f,imag:m},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),y}if(e.shouldExecuteOnCPU([r,s])){const a=e.texData.get(r.dataId),u=e.texData.get(s.dataId),[c,l]=HW(r.shape,s.shape,a.values,u.values,o),h=e.makeTensorInfo(l,o);return e.texData.get(h.dataId).values=c,h}let i;return i=(0,d.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Nf(GE,r.shape,s.shape):new Ud(GE,r.shape,s.shape),e.runWebGLProgram(i,[r,s],o)}const Gz={kernelName:d.Multiply,backendName:"webgl",kernelFunc:U3};function qt(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{shape:o}=r,i=e,a=d.util.sizeFromShape(s.shape),u=d.util.inferFromImplicitShape(o,a),c=d.util.sizeFromShape(u);d.util.assert(a===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const l=i.texData.get(s.dataId);return!l.isPacked||ug(s.shape,u)||null!==l.texture&&ug(l.shape,u)?(i.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype}):function Kz(t,n,e){const r=[Md(t.shape),...$d(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},o=[Md(n),...$d(n)],i=new ME(o,r),c=e.runWebGLProgram(i,[s],t.dtype,[r],!0);return{dataId:c.dataId,shape:n,dtype:c.dtype}}(s,u,i)}const Xz={kernelName:d.Reshape,backendName:"webgl",kernelFunc:qt};class KE{constructor(n,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=n;this.outputShape=[s,i];const a=4*Math.floor(r/4),u=r%4;let c="sumValue += dot(values, ones);";if(null!=e){const h=1/e;c=`sumValue += dot(values * ${d.util.isInt(h)?h.toPrecision(2):h}, ones);`}let l="";o%r>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===u}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}class qz{constructor(n,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=n;this.outputShape=[s,i];let a="0.0",u="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",u="min"):"max"===e&&(a="-1.0 / 1e-20",u="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?c="sumValue":"prod"===e?c="prodValue":"all"===e?c="allValue":"any"===e&&(c="anyValue");const l=4*Math.floor(r/4),h=r%4;let f=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${u}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${u}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,m="vec4";"all"===e?(a="1.0",f="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",m="bvec4"):"any"===e&&(a="0.0",f="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",m="bvec4");let y="";o%r>0&&(y=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${y}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${m} values = ${m}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${f}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===h}) {\n          ${m} values = ${m}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${f}\n        } else if (${2===h}) {\n          ${m} values = ${m}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${f}\n        } else if (${3===h}) {\n          ${m} values = ${m}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${f}\n        }\n        setOutput(${c});\n      }\n    `}}function al(t,n,e,r){const s=function Yz(t){const n=[];for(;0===n.length||1!==n[n.length-1].outSize;){const e=n.length?n[n.length-1].outSize:t[1],r=d.backend_util.computeOptimalWindowSize(e);n.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return n}(t.shape);let o=t;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:u,outSize:c}=s[i];let l,h;l="mean"===e?0===i?new KE({windowSize:u,inSize:a,batchSize:t.shape[0],outSize:c},a):new KE({windowSize:u,inSize:a,batchSize:t.shape[0],outSize:c}):new qz({windowSize:u,inSize:a,batchSize:t.shape[0],outSize:c},e),h=o,o=r.runWebGLProgram(l,[o],n),h.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(h)}return o}class Zz{constructor(n,e){this.variableNames=["A"];const r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[e[i]];this.outputShape=r,this.rank=r.length;const s=Hr(this.rank),o=function Qz(t){const n=t.length;if(n>6)throw Error(`Transpose for rank ${n} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(n);for(let s=0;s<t.length;s++)r[t[s]]=e[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class Jz{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(n.length);for(let l=0;l<r.length;l++)r[l]=n[e[l]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Hr(this.rank),o=OE("rc",this.rank),i=new Array(this.rank);for(let l=0;l<e.length;l++)i[e[l]]=o[l];const a=`vec2(${i.slice(-2).join()})`,u=`++${o[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${u}) {\n        result[1] = ${c};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${c};\n        if(${u}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function pg(t,n,e){const r=(0,d.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Jz(t.shape,n):new Zz(t.shape,n);return e.runWebGLProgram(r,[t],t.dtype)}function mg(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r;return function eH(t,n,e,r){const o=t.shape.length,i=d.util.parseAxisParam(n,t.shape);let a=i;const u=d.backend_util.getAxesPermutation(a,o),c=null!=u;let l=t;c&&(l=pg(t,u,r),a=d.backend_util.getInnerMostAxes(a.length,o)),d.backend_util.assertAxesAreInnerMostDims("sum",a,o);const[h,f]=d.backend_util.computeOutAndReduceShapes(l.shape,a);let m=h;e&&(m=d.backend_util.expandShapeToKeepDim(h,i));const y=d.util.sizeFromShape(f),D=qt({inputs:{x:l},attrs:{shape:[d.util.sizeFromShape(t.shape)/y,y]},backend:r}),W=al(D,(0,d.sumOutType)(t.dtype),"sum",r),q=qt({inputs:{x:W},attrs:{shape:m},backend:r});return r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(W),c&&r.disposeIntermediateTensorInfo(l),q}(s,o,i,e)}const tH={kernelName:d.Sum,backendName:"webgl",kernelFunc:mg};function ko(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{perm:o}=r,i=e,u=new Array(s.shape.length);for(let l=0;l<u.length;l++)u[l]=s.shape[o[l]];let c;if(i.shouldExecuteOnCPU([s])){const h=i.texData.get(s.dataId).values,f=B3(h,s.shape,s.dtype,o,u);c=i.makeTensorInfo(u,s.dtype),i.texData.get(c.dataId).values=f}else c=pg(s,o,i);return c}const nH={kernelName:d.Transpose,backendName:"webgl",kernelFunc:ko},XE=1e3;function gg({a:t,b:n,transposeA:e,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){const c=t.shape.length,l=n.shape.length,h=e?t.shape[c-2]:t.shape[c-1],f=r?n.shape[l-1]:n.shape[l-2],m=e?t.shape[c-1]:t.shape[c-2],y=r?n.shape[l-2]:n.shape[l-1],w=t.shape.slice(0,-2),E=n.shape.slice(0,-2),D=d.util.sizeFromShape(w),O=d.util.sizeFromShape(E),q=d.broadcast_util.assertAndGetBroadcastShape(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([m,y]);d.util.assert(h===f,()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${e} and transposeB=${r} must match.`);const re=e?[D,h,m]:[D,m,h],pe=r?[O,y,f]:[O,f,y],Ae=qt({inputs:{x:t},backend:s,attrs:{shape:re}}),Be=qt({inputs:{x:n},backend:s,attrs:{shape:pe}}),Ke=[Ae,Be],Ge=Math.max(D,O),ft=e?Ae.shape[1]:Ae.shape[2],yt=null!=o,pt=null!=i,wt="leakyrelu"===u,vt=null!=u?kf(u,!0):null;let Et;if((1===m||1===y)&&ft>XE&&!1===(yt||pt||wt||null!=vt)){let _t=Ae,Ot=Be;e&&(_t=ko({inputs:{x:Ae},backend:s,attrs:{perm:[0,2,1]}}),Ke.push(_t)),r&&(Ot=ko({inputs:{x:Be},backend:s,attrs:{perm:[0,2,1]}}),Ke.push(Ot));const zt=1===y;let $t=_t;1!==y&&($t=qt({inputs:{x:_t},backend:s,attrs:{shape:[Ge,ft,1]}}),Ke.push($t));const jt=1===y?2:1;let Ut=Ot;zt&&(Ut=qt({inputs:{x:Ot},backend:s,attrs:{shape:[Ge,1,ft]}}),Ke.push(Ut));const Kt=U3({inputs:{a:$t,b:Ut},backend:s});Et=mg({inputs:{x:Kt},backend:s,attrs:{axis:jt,keepDims:!0}}),Ke.push(Kt)}else{const _t=(0,d.upcastType)(t.dtype,n.dtype),Ot=new zE(re,pe,[Ge,m,y],e,r,yt,vt,pt,wt),Rt=[Ae,Be];if(null!=o&&Rt.push(o),pt&&Rt.push(i),wt){const zt=s.makeTensorInfo([],"float32",d.util.createScalarValue(a,"float32"));Rt.push(zt),Ke.push(zt)}Et=s.runWebGLProgram(Ot,Rt,_t)}const mt=qt({inputs:{x:Et},backend:s,attrs:{shape:q}});Ke.push(Et);for(const _t of Ke)s.disposeIntermediateTensorInfo(_t);return mt}const sH={kernelName:d._FusedMatMul,backendName:"webgl",kernelFunc:function rH(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o,bias:i,preluActivationWeights:a}=n,{transposeA:u,transposeB:c,activation:l,leakyreluAlpha:h}=r;return gg({a:s,b:o,transposeA:u,transposeB:c,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:h,activation:l})}},qE="return abs(x);",iH={kernelName:d.Abs,backendName:"webgl",kernelFunc:function oH(t){const{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const o=e.texData.get(r.dataId),i=AE(o.values);return e.makeTensorInfo(r.shape,r.dtype,i)}let s;return s=(0,d.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new il(r.shape,qE):new zu(r.shape,qE),e.runWebGLProgram(s,[r],r.dtype)}},uH=vr({opSnippet:Li+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),cH={kernelName:d.Acos,backendName:"webgl",kernelFunc:uH},dH=vr({opSnippet:Li+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),hH={kernelName:d.Acosh,backendName:"webgl",kernelFunc:dH},YE="return a + b;",fH=ro({opSnippet:YE,packedOpSnippet:YE,supportsComplex:!0,cpuKernelImpl:EW}),pH={kernelName:d.Add,backendName:"webgl",kernelFunc:fH};class mH{constructor(n,e){this.outputShape=[],this.outputShape=n,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class gH{constructor(n,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.variableNames=e.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const yH={kernelName:d.AddN,backendName:"webgl",kernelFunc:function yg(t){const{inputs:n,backend:e}=t,r=n;if(1===r.length)return mi({inputs:{x:r[0]},backend:e});if(r.length>(0,d.env)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(r.length/2),c=yg({inputs:r.slice(0,u),backend:e}),l=yg({inputs:r.slice(u),backend:e});return yg({inputs:[c,l],backend:e})}const s=r.map(u=>u.dtype).reduce((u,c)=>(0,d.upcastType)(u,c)),o=r.map(u=>u.shape),a=(0,d.env)().getBool("WEBGL_PACK")?new gH(r[0].shape,o):new mH(r[0].shape,o);return e.runWebGLProgram(a,r,s)}},xH={kernelName:d.All,backendName:"webgl",kernelFunc:function vH(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,u=d.util.parseAxisParam(o,s.shape);let c=u;const l=d.backend_util.getAxesPermutation(c,a);let h=s;null!=l&&(h=ko({inputs:{x:s},backend:e,attrs:{perm:l}}),c=d.backend_util.getInnerMostAxes(c.length,a)),d.backend_util.assertAxesAreInnerMostDims("all",c,a);const[f,m]=d.backend_util.computeOutAndReduceShapes(h.shape,c),w=qt({inputs:{x:h},backend:e,attrs:{shape:[-1,d.util.sizeFromShape(m)]}}),E=al(w,w.dtype,"all",e);let D;return D=qt(i?{inputs:{x:E},backend:e,attrs:{shape:d.backend_util.expandShapeToKeepDim(f,u)}}:{inputs:{x:E},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(E),null!=l&&e.disposeIntermediateTensorInfo(h),D}},wH={kernelName:d.Any,backendName:"webgl",kernelFunc:function bH(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,u=d.util.parseAxisParam(o,s.shape);let c=u;const l=d.backend_util.getAxesPermutation(c,a);let h=s;null!=l&&(h=ko({inputs:{x:s},backend:e,attrs:{perm:l}}),c=d.backend_util.getInnerMostAxes(c.length,a)),d.backend_util.assertAxesAreInnerMostDims("any",c,a);const[f,m]=d.backend_util.computeOutAndReduceShapes(h.shape,c),w=qt({inputs:{x:h},backend:e,attrs:{shape:[-1,d.util.sizeFromShape(m)]}}),E=al(w,w.dtype,"any",e);let D;return D=qt(i?{inputs:{x:E},backend:e,attrs:{shape:d.backend_util.expandShapeToKeepDim(f,u)}}:{inputs:{x:E},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(E),null!=l&&e.disposeIntermediateTensorInfo(h),D}};class CH{constructor(n,e,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:i}=n;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class SH{constructor(n,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,d.util.assert(n.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(n[n.length-1]/e);this.outputShape=n.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,u=a.length,c=Hr(u),l=No("coords",u);let h,f;if(1===i){f=u+1;const Be=Hr(f);h=`\n        ${Be} sourceLocR = ${Be}(${l.join()}, 0);\n        ++${l[u-1]};\n        ${Be} sourceLocG = ${Be}(${l.join()}, 0);\n        ++${l[u-2]};\n        ${Be} sourceLocA = ${Be}(${l.join()}, 0);\n        --${l[u-1]};\n        ${Be} sourceLocB = ${Be}(${l.join()}, 0);\n        --${l[u-2]};`}else f=u,h=`\n        ${c} sourceLocR = coords;\n        ++${l[u-1]};\n        ${c} sourceLocG = coords;\n        ++${l[u-2]};\n        ${c} sourceLocA = coords;\n        --${l[u-1]};\n        ${c} sourceLocB = coords;\n        --${l[u-2]};`;const m=["x","y","z","w","u","v"].slice(0,f),y="."+m[f-1],w=m.map(Be=>"int "+Be),E=No("sourceLocR",f-1).concat("inIdx.r"),D=No("sourceLocG",f-1).concat("inIdx.g"),O=No("sourceLocB",f-1).concat("inIdx.b"),W=No("sourceLocA",f-1).concat("inIdx.a"),q="max"===r?"greaterThan":"lessThan",re=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${E.join()}),\n                             getBestIndicesAChannel(${D.join()}),\n                             getBestIndicesAChannel(${O.join()}),\n                             getBestIndicesAChannel(${W.join()})));`,pe=`vec4(\n            getAChannel(${E.join()}),\n            hasNextCol ? getAChannel(${D.join()}) : 0.,\n            hasNextRow ? getAChannel(${O.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${W.join()}) : 0.)`,Ae=s?"":`\n      float getBestIndicesAChannel(${w.join()}) {\n        return getChannel(getBestIndicesA(${m.join()}),\n                                          vec2(${m.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${w.join()}) {\n        return getChannel(getA(${m.join()}),\n                               vec2(${m.slice(-2).join()}));\n      }\n      ${Ae}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${l[u-1]} < ${a[u-1]-1};\n        bool hasNextRow = ${l[u-2]} < ${a[u-2]-1};\n        ${h}\n        ivec4 srcIdx = ivec4(sourceLocR${y}, sourceLocG${y},\n          sourceLocB${y}, sourceLocA${y}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${pe};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${re}\n          vec4 candidate = ${pe};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${q}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function ZE(t,n,e,r=null){let s=n.shape[0],o=n.shape[1];null!=r&&(s=r.shape[0],o=r.shape[1]);const i=d.backend_util.computeOptimalWindowSize(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},u=new CH(a,e,null==r),c=[n];null!=r&&c.push(r);const l=t.runWebGLProgram(u,c,"int32");if(1===l.shape[1])return l;const h=ZE(t,n,e,l);return t.disposeIntermediateTensorInfo(l),h}function QE(t,n,e,r=null){const s=null!=r?r.shape:n.shape,i=d.backend_util.computeOptimalWindowSize(s[s.length-1]),a=new SH(s,i,e,null==r),c=t.runWebGLProgram(a,null==r?[n]:[n,r],"int32");if(c.shape.length===n.shape.length){const l=QE(t,n,e,c);return t.disposeIntermediateTensorInfo(c),l}return c}function JE(t,n,e,r){const s=[e];if(d.backend_util.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,n.shape.length),!(0,d.env)().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){const o=[],i=t.texData.get(n.dataId);let u=n;null!==i&&i.isPacked&&(u=t.unpackTensor(n),o.push(u));const[c,l]=d.backend_util.computeOutAndReduceShapes(u.shape,s),h=d.util.sizeFromShape(l),f=qt({inputs:{x:u},backend:t,attrs:{shape:[-1,h]}});o.push(f);const m=ZE(t,f,r);o.push(m);const y=qt({inputs:{x:m},backend:t,attrs:{shape:c}});return o.forEach(w=>t.disposeIntermediateTensorInfo(w)),y}return QE(t,n,r)}const _H={kernelName:d.ArgMax,backendName:"webgl",kernelFunc:function EH(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;let i=d.util.parseAxisParam(o,s.shape);const a=d.backend_util.getAxesPermutation(i,s.shape.length);let u=s;const c=[];null!=a&&(u=ko({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(u),i=d.backend_util.getInnerMostAxes(i.length,u.shape.length)),d.backend_util.assertAxesAreInnerMostDims("argMax",[i[0]],u.shape.length);const l=JE(e,u,i[0],"max");return c.forEach(h=>e.disposeIntermediateTensorInfo(h)),l}},DH={kernelName:d.ArgMin,backendName:"webgl",kernelFunc:function IH(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o}=r;let i=d.util.parseAxisParam(o,s.shape);const a=d.backend_util.getAxesPermutation(i,s.shape.length);let u=s;const c=[];null!=a&&(u=ko({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(u),i=d.backend_util.getInnerMostAxes(i.length,u.shape.length)),d.backend_util.assertAxesAreInnerMostDims("argMin",[i[0]],u.shape.length);const l=JE(e,u,i[0],"min");return c.forEach(h=>e.disposeIntermediateTensorInfo(h)),l}},NH=vr({opSnippet:Li+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),kH={kernelName:d.Asin,backendName:"webgl",kernelFunc:NH},RH=vr({opSnippet:Li+"return log(x + sqrt(x * x + 1.0));"}),OH={kernelName:d.Asinh,backendName:"webgl",kernelFunc:RH},$H=vr({opSnippet:Li+"\n  return atan(x);\n"}),FH={kernelName:d.Atan,backendName:"webgl",kernelFunc:$H},BH=ro({opSnippet:V3+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Tf+"\n  return result;\n"}),VH={kernelName:d.Atan2,backendName:"webgl",kernelFunc:BH},WH=vr({opSnippet:Li+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),zH={kernelName:d.Atanh,backendName:"webgl",kernelFunc:WH};class Af{constructor(n,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=n.filterWidth,a=n.strideHeight,u=n.strideWidth,c=n.dilationHeight,l=n.dilationWidth,h=n.effectiveFilterHeight,f=n.effectiveFilterWidth,m=n.padInfo.top,y=n.padInfo.left;this.outputShape=n.outShape;const w="avg"===e;let O="0.0";if(w||(O="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${u});\n        const ivec2 pads = ivec2(${m}, ${y});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${h};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${f};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?o?`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`:`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`:`wR * ${f} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let q=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(q="avgValue / count");const re=4*Math.floor(i/4),pe=i%4,Ae=`\n      if (${w}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${u});\n      const ivec2 pads = ivec2(${m}, ${y});\n      const float initializationValue = ${O};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${O});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${h};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${re}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${Ae}\n          }\n\n          int xC = xCCorner + ${re};\n          if (${1===pe}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${Ae}\n          } else if (${2===pe}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${Ae}\n          } else if (${3===pe}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${Ae}\n          }\n        }\n        setOutput(${q});\n      }\n    `}}class W3{constructor(n,e,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const i=n.filterWidth,a=n.strideDepth,u=n.strideHeight,c=n.strideWidth,l=n.dilationDepth,h=n.dilationHeight,f=n.dilationWidth,m=n.effectiveFilterDepth,y=n.effectiveFilterHeight,w=n.effectiveFilterWidth,E=n.padInfo.front,D=n.padInfo.top,O=n.padInfo.left;this.outputShape=n.outShape;const W="avg"===e;let q="0.0";if(W||(q="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${u}, ${c});\n        const ivec3 pads = ivec3(${E}, ${D}, ${O});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${m};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${y};\n                wR += ${h}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${w};\n                  wC += ${f}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?o?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${y} * ${w} +\n                      wR * ${w} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let pe=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(pe="avgValue / count");const Ae=4*Math.floor(i/4),Be=i%4,Ke=`\n      if (${W}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${u}, ${c});\n      const ivec3 pads = ivec3(${E}, ${D}, ${O});\n      const float initializationValue = ${q};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${q});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${m};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${y};\n            wR += ${h}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${Ae}; wC += 4) {\n              int xC = xCCorner + wC * ${f};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${f}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${f}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${f}, ch)\n              );\n\n              ${Ke}\n            }\n\n            int xC = xCCorner + ${Ae};\n            if (${1===Be}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${Ke}\n            } else if (${2===Be}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${f}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${Ke}\n            } else if (${3===Be}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${f}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${f}, ch),\n                initializationValue\n              );\n\n              ${Ke}\n            }\n          }\n          setOutput(${pe});\n        }\n      }\n    `}}const jH={kernelName:d.AvgPool,backendName:"webgl",kernelFunc:function HH(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;If(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=r;d.util.assert(d.backend_util.eitherStridesOrDilationsAreOne(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=d.backend_util.computePool2DInfo(s.shape,o,i,1,a,u);if(1===l.filterWidth&&1===l.filterHeight&&d.util.arraysEqual(l.inShape,l.outShape))return mi({inputs:{x:s},backend:e});const h=new Af(l,"avg",!1);return e.runWebGLProgram(h,[s],"float32")}},KH={kernelName:d.AvgPool3D,backendName:"webgl",kernelFunc:function GH(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:u,dataFormat:c}=r,h=d.backend_util.computePool3DInfo(s.shape,o,i,[1,1,1],a,u,c),f=new W3(h,"avg",!1);return e.runWebGLProgram(f,[s],"float32")}};class XH{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const u=n.effectiveFilterHeight,c=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${u-1-n.padInfo.top}, ${c-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${u};\n            wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c};\n            wC+= ${n.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class qH{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const h=n.effectiveFilterDepth,f=n.effectiveFilterHeight,m=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${h-1-n.padInfo.front}, ${f-1-n.padInfo.top}, ${m-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterDepth*n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${f};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${m};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const ZH={kernelName:d.AvgPool3DGrad,backendName:"webgl",kernelFunc:function YH(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o,{filterSize:a,strides:u,pad:c,dimRoundingMode:l}=r,f=d.backend_util.computePool3DInfo(i.shape,a,u,[1,1,1],c,l),m=new qH(f);return e.runWebGLProgram(m,[s],i.dtype)}},JH={kernelName:d.AvgPoolGrad,backendName:"webgl",kernelFunc:function QH(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o;If([s,o],"avgPoolGrad");const{filterSize:a,strides:u,pad:c}=r,l=d.backend_util.computePool2DInfo(i.shape,a,u,1,c),h=new XH(l);return e.runWebGLProgram(h,[s],i.dtype)}},tj={kernelName:d.BatchMatMul,backendName:"webgl",kernelFunc:function ej(t){const{inputs:n,backend:e,attrs:r}=t,{a:s,b:o}=n,{transposeA:i,transposeB:a}=r;return gg({a:s,b:o,transposeA:i,transposeB:a,backend:e})}};class nj{constructor(n,e,r,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],d.backend_util.assertAndGetBroadcastShape(n,e),d.backend_util.assertAndGetBroadcastShape(n,r);let a="0.0";null!=s&&(d.backend_util.assertAndGetBroadcastShape(n,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";null!=o&&(d.backend_util.assertAndGetBroadcastShape(n,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${u};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class rj{constructor(n,e,r,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],d.backend_util.assertAndGetBroadcastShape(n,e),d.backend_util.assertAndGetBroadcastShape(n,r);let a="vec4(0.0)";null!=s&&(d.backend_util.assertAndGetBroadcastShape(n,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";null!=o&&(d.backend_util.assertAndGetBroadcastShape(n,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${u};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const oj={kernelName:d.FusedBatchNorm,backendName:"webgl",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=t;d.util.assert(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),d.util.assert(null==i||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),d.util.assert(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=e;null==u&&(u=.001);const c=[r,s,o];let l=null;null!=i&&(l=i.shape,c.push(i));let h=null;null!=a&&(h=a.shape,c.push(a));const f=(0,d.env)().getBool("WEBGL_PACK_NORMALIZATION")?new rj(r.shape,s.shape,o.shape,l,h,u):new nj(r.shape,s.shape,o.shape,l,h,u);return n.runWebGLProgram(f,c,c[0].dtype)}};class ij{constructor(n){this.variableNames=["source"],this.outputShape=n,this.rank=n.length;const e=Hr(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function aj(t){if(1===t)return"sourceLoc";if(t<=6)return z3.slice(0,t).map(n=>"sourceLoc."+n).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let s;s=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${n.map((i,a)=>`sourceLoc.${z3[a]} = start[${a}] + coords.${z3[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}}const z3=["x","y","z","w","u","v"];class uj{constructor(n){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=Hr(this.rank),r=No("coords",this.rank),s=No("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${o})`,a=`\n      result.x = ${i};\n      if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${i};\n        --${s[this.rank-1]};\n      }\n    `,u=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${i};\n        if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,c=this.rank<=4?`sourceLoc = coords +\n            ${e}(${n.map((l,h)=>`start[${h}]`).join()});`:n.map((l,h)=>`${s[h]} = ${r[h]} + start[${h}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${c}\n        vec4 result = vec4(0.);\n        ${a}\n        ${u}\n        setOutput(result);\n      }\n    `}}function zd(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,size:i}=r,[a,u]=d.slice_util.parseSliceParams(s,o,i);if(d.slice_util.assertParamsValid(s,a,u),0===d.util.sizeFromShape(u))return e.makeTensorInfo(u,s.dtype,[]);if(e.shouldExecuteOnCPU([s])||"string"===s.dtype){const h=e.texData.get(s.dataId),f=ez(h.values,a,u,s.shape,s.dtype);return e.makeTensorInfo(u,s.dtype,f)}const{isPacked:c}=e.texData.get(s.dataId),l=d.slice_util.isSliceContinous(s.shape,a,u);if(c||!l){const h=(0,d.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new uj(u):new ij(u);return e.runWebGLProgram(h,[s],s.dtype,[a])}return e.uploadToGPU(s.dataId),function cj(t,n,e,r){const s=r.texData.get(t.dataId),o=r.makeTensorInfo(e,t.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=e,i.dtype=t.dtype;let a=d.slice_util.computeFlatOffset(n,d.util.computeStrides(t.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||t.dataId};const u=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,u+1),o}(s,a,u,e)}const lj={kernelName:d.Slice,backendName:"webgl",kernelFunc:zd},hj={kernelName:d.BatchToSpaceND,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,crops:i}=r;d.util.assert(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((O,W)=>O*W),u=d.backend_util.getReshaped(s.shape,o,a),c=d.backend_util.getPermuted(u.length,o.length),l=d.backend_util.getReshapedPermuted(s.shape,o,a),h=d.backend_util.getSliceBeginCoords(i,o.length),f=d.backend_util.getSliceSize(l,i,o.length),m=[],y=qt({inputs:{x:s},backend:e,attrs:{shape:u}}),w=ko({inputs:{x:y},backend:e,attrs:{perm:c}}),E=qt({inputs:{x:w},backend:e,attrs:{shape:l}}),D=zd({inputs:{x:E},backend:e,attrs:{begin:h,size:f}});return m.push(y),m.push(w),m.push(E),m.forEach(O=>e.disposeIntermediateTensorInfo(O)),D}},pj={kernelName:d.Bincount,backendName:"webgl",kernelFunc:function fj(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i}=r,a=e.readSync(s.dataId),u=e.readSync(o.dataId),c=kE(a,u,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,c)}},gj={kernelName:d.BroadcastArgs,backendName:"webgl",kernelFunc:function mj(t){const{inputs:n,backend:e}=t,{s0:r,s1:s}=n,o=e.readSync(r.dataId),i=e.readSync(s.dataId),a=d.backend_util.assertAndGetBroadcastShape(Array.from(o),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},e_=ro({opSnippet:"return float(a != b);",cpuKernelImpl:GW,dtype:"bool"}),yj={kernelName:d.NotEqual,backendName:"webgl",kernelFunc:e_};function Rf(t){const{inputs:n,backend:e}=t,{input:r}=n;return mi({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const vj={kernelName:d.Real,backendName:"webgl",kernelFunc:Rf},wj={kernelName:d.Cast,backendName:"webgl",kernelFunc:function H3(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return mi({inputs:{x:s},backend:e});const i=d.zeros(s.shape),a=H3({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),u=xc({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),u}if("complex64"===s.dtype){const i=Rf({inputs:{input:s},backend:e}),a=H3({inputs:{x:i},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(i),a}if(!d.util.hasEncodingLoss(s.dtype,o)){const i=mi({inputs:{x:s},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(e.shouldExecuteOnCPU([s])){const i=e.texData.get(s.dataId).values,[a,u,c]=IW(i,s.shape,s.dtype,o);return e.makeTensorInfo(a,u,c)}if("int32"===o)return function bj(t,n){const e=new zu(t.shape,"return float(int(x));"),r=n.runWebGLProgram(e,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,e);if("bool"===o){const i=e.makeTensorInfo([],"bool",d.util.getTypedArrayFromDType("bool",1)),u=e_({inputs:{a:s,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),u}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},t_="return ceil(x);",Cj=vr({opSnippet:t_,packedOpSnippet:t_,cpuKernelImpl:DW}),Sj={kernelName:d.Ceil,backendName:"webgl",kernelFunc:Cj};class Ej{constructor(n){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class _j{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const Dj={kernelName:d.ClipByValue,backendName:"webgl",kernelFunc:function Ij(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{clipValueMin:o,clipValueMax:i}=r;let a;return a=(0,d.env)().getBool("WEBGL_PACK_CLIP")?new _j(s.shape):new Ej(s.shape),e.runWebGLProgram(a,[s],s.dtype,[[o],[i]])}};class Tj{constructor(n){this.variableNames=["real","imag"],this.outputShape=n,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function n_(t,n){return{dataId:n.dataId,dtype:n.dtype,shape:t.shape}}const kj={kernelName:d.ComplexAbs,backendName:"webgl",kernelFunc:function Nj(t){const{inputs:n,backend:e}=t,{x:r}=n,s=e.texData.get(r.dataId),o=new Tj(r.shape),i=[n_(r,s.complexTensorInfos.real),n_(r,s.complexTensorInfos.imag)];return e.runWebGLProgram(o,i,i[0].dtype)}};class Aj{constructor(n){this.outputShape=[],this.outputShape=d.backend_util.computeOutShape(n,1),this.variableNames=n.map((i,a)=>`T${a}`);const e=new Array(n.length-1);e[0]=n[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+n[i][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++)r.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${e[i-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class Rj{constructor(n,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=d.backend_util.computeOutShape(n,e);const r=this.outputShape,s=r.length,o=Hr(s),i=No("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=n.map((w,E)=>`T${E}`);const u=new Array(n.length-1);u[0]=n[0][e];for(let w=1;w<u.length;w++)u[w]=u[w-1]+n[w][e];const c=a[e],l=a.slice(-2),h=a.join();let f=`if (${c} < ${u[0]}) {\n        return getChannel(\n            getT0(${h}), vec2(${l.join()}));\n        }`;for(let w=1;w<u.length;w++){const E=u[w-1];f+=`\n        if (${c} < ${u[w]}  && ${c} >= ${u[w-1]}) {\n          return getChannel(\n            getT${w}(${vg(a,c,E)}),\n            vec2(${vg(l,c,E)}));\n        }`}const y=u[u.length-1];f+=`\n        return getChannel(\n          getT${u.length}(${vg(a,c,y)}),\n          vec2(${vg(l,c,y)}));`,this.userCode=`\n      float getValue(${a.map(w=>"int "+w)}) {\n        ${f}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[s-1]} = ${i[s-1]} + 1;\n        if (${i[s-1]} < ${r[s-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[s-2]} = ${i[s-2]} + 1;\n        if (${i[s-2]} < ${r[s-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[s-1]} = ${i[s-1]} - 1;\n        if (${i[s-2]} < ${r[s-2]} &&\n            ${i[s-1]} < ${r[s-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function vg(t,n,e){const r=t.indexOf(n);return t.map((o,i)=>i===r?`${o} - ${e}`:o).join()}function xg(t){const{inputs:n,backend:e}=t,{input:r}=n;return mi({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const Oj={kernelName:d.Imag,backendName:"webgl",kernelFunc:xg};function Of(t,n,e){const r=t[0].dtype;if("complex64"===r){const h=t.map(E=>Rf({inputs:{input:E},backend:e})),f=t.map(E=>xg({inputs:{input:E},backend:e})),m=Of(h,n,e),y=Of(f,n,e),w=xc({inputs:{real:m,imag:y},backend:e});return h.forEach(E=>e.disposeIntermediateTensorInfo(E)),f.forEach(E=>e.disposeIntermediateTensorInfo(E)),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),w}let s=e.shouldExecuteOnCPU(t);if("string"===r&&(s=!0),s){const h=t.map(O=>{const q=[-1,d.util.sizeFromShape(O.shape.slice(n))];return qt({inputs:{x:O},backend:e,attrs:{shape:q}})}),f=h.map(O=>({vals:e.readSync(O.dataId),shape:O.shape})),m=d.backend_util.computeOutShape(h.map(O=>O.shape),1),w=TW(f,m,r,1===h[0].shape[0]),E=d.backend_util.computeOutShape(t.map(O=>O.shape),n),D=e.makeTensorInfo(E,r,w);return h.forEach(O=>e.disposeIntermediateTensorInfo(O)),D}const o=(0,d.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(t.length>o){const h=[];for(let m=0;m<t.length;m+=o){const y=t.slice(m,m+o);h.push(Of(y,n,e))}const f=Of(h,n,e);for(const m of h)e.disposeIntermediateTensorInfo(m);return f}if((0,d.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].shape.length>1){const h=new Rj(t.map(f=>f.shape),n);return e.runWebGLProgram(h,t,r)}const{tensors2D:i,outShape:a}=function Mj(t,n,e){const r=d.backend_util.computeOutShape(t.map(o=>o.shape),n);return{tensors2D:t.map(o=>qt({inputs:{x:o},attrs:{shape:[-1,d.util.sizeFromShape(o.shape.slice(n))]},backend:e})),outShape:r}}(t,n,e),u=new Aj(i.map(h=>h.shape)),c=e.runWebGLProgram(u,i,r);i.forEach(h=>e.disposeIntermediateTensorInfo(h));const l=qt({inputs:{x:c},attrs:{shape:a},backend:e});return e.disposeIntermediateTensorInfo(c),l}function r_(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r,o=d.util.parseAxisParam(s,n[0].shape)[0],i=n.map(c=>c.shape);d.backend_util.assertParamsConsistent(i,o);const a=d.backend_util.computeOutShape(n.map(c=>c.shape),o);if(0===d.util.sizeFromShape(a))return e.makeTensorInfo(a,n[0].dtype,[]);const u=n.filter(c=>d.util.sizeFromShape(c.shape)>0);return 1===u.length?mi({inputs:{x:u[0]},backend:e}):Of(u,o,e)}const $j={kernelName:d.Concat,backendName:"webgl",kernelFunc:r_};class s_{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=n.outShape;const i=n.padInfo.top,a=n.padInfo.left,u=n.strideHeight,c=n.strideWidth,l=n.dilationHeight,h=n.dilationWidth,f=n.filterHeight,m=n.filterWidth,y=4*Math.floor(n.inChannels/4),w=n.inChannels%4,E="channelsLast"===n.dataFormat,D=E?1:2,O=E?2:3,W=E?3:1;let q="",re="";r&&(q=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,re="result = activation(result);");const pe=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${q}\n\n      const ivec2 strides = ivec2(${u}, ${c});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${W}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${D}], coords[${O}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${f}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${m}; wC++) {\n            int xC = xCCorner + wC * ${h};\n\n            if (xC < 0 || xC >= ${n.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${y}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${E}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===w}) {\n\n              if (${E}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${y}) *\n                    getW(wR, wC, ${y}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${y}, xR, xC) *\n                    getW(wR, wC, ${y}, d2);\n              }\n\n            } else if (${2===w}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${y}, d2),\n                getW(wR, wC, ${y} + 1, d2)\n              );\n\n              if (${E}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${y}),\n                  getX(batch, xR, xC, ${y} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${y}, xR, xC),\n                  getX(batch, ${y} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===w}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${y}, d2),\n                getW(wR, wC, ${y} + 1, d2),\n                getW(wR, wC, ${y} + 2, d2)\n              );\n\n              if (${E}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${y}),\n                  getX(batch, xR, xC, ${y} + 1),\n                  getX(batch, xR, xC, ${y} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${y}, xR, xC),\n                  getX(batch, ${y} + 1, xR, xC),\n                  getX(batch, ${y} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${pe}\n        ${re}\n        setOutput(result);\n      }\n    `}}class Fj{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const e=n.padInfo.front,r=n.padInfo.top,s=n.padInfo.left,o=n.strideDepth,i=n.strideHeight,a=n.strideWidth,u=n.dilationDepth,c=n.dilationHeight,l=n.dilationWidth,h=n.filterDepth,f=n.filterHeight,m=n.filterWidth,y=4*Math.floor(n.inChannels/4),w=n.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${i}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${h}; wF++) {\n          int xF = xFCorner + wF * ${u};\n\n          if (xF < 0 || xF >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${f}; wR++) {\n            int xR = xRCorner + wR * ${c};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${m}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${y}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===w}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${y}) *\n                  getW(wF, wR, wC, ${y}, d2);\n              } else if (${2===w}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${y}),\n                  getX(batch, xF, xR, xC, ${y} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${y}, d2),\n                  getW(wF, wR, wC, ${y} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===w}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${y}),\n                  getX(batch, xF, xR, xC, ${y} + 1),\n                  getX(batch, xF, xR, xC, ${y} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${y}, d2),\n                  getW(wF, wR, wC, ${y} + 1, d2),\n                  getW(wF, wR, wC, ${y} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class o_{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=To(this.outputShape.length);const i=n.padInfo.left,a=n.strideWidth,u=n.dilationWidth,c=n.filterHeight,l=n.filterWidth,h=l;let f="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let E=0;E<l;E++)f+=`\n           vec4 xTexelC${2*E};\n           int xTexelC${2*E}Ready;\n           vec4 xTexelC${2*E+1};\n           int xTexelC${2*E+1}Ready;\n           vec4 xC${E};`;f+=`\n     for (int r = 0; r < ${c}; r++) {\n      for (int d1 = 0; d1 < ${n.inChannels}; d1 += 2) {\n       `;for(let E=0;E<l;E++)f+=`\n           xTexelC${2*E} = vec4(0.0);\n           xTexelC${2*E}Ready = 0;\n           xTexelC${2*E+1} = vec4(0.0);\n           xTexelC${2*E+1}Ready = 0;\n           xC${E} = vec4(0.0);`;f+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let E=0;E<(h+1)/2;E++){const D=2*E;if(f+=`\n           xC = xCCorner + ${D*u};\n           `,1===a){if(D<l&&(i%2==1?(f+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${D}Ready == 0) {\n                   xTexelC${D} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${D}.zw = vec2(0.0);\n                   }\n                   xTexelC${D}Ready = 1;\n                 }\n               `,f+=1===u&&D>0?`\n                 xC${D} = vec4(xTexelC${D-2}.zw, xTexelC${D}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${D} = vec4(previous.zw, xTexelC${D}.xy);\n                   } else {\n                     xC${D} = vec4(0.0, 0.0, xTexelC${D}.xy);\n                   }\n                   `):f+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${D}Ready == 0) {\n                   xTexelC${D} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${D}.zw = vec2(0.0);\n                   }\n                   xTexelC${D}Ready = 1;\n                 }\n\n                 xC${D} = xTexelC${D};\n                 `,D+1<l)){const O=i%2==0?d.util.nearestLargerEven(u):u;u%2==0&&i%2==1||u%2!=0&&i%2!=1?(f+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${O};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${D+1}Ready == 0) {\n                     xTexelC${D+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${D+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${D+1}Ready = 1;\n                   }\n                   `,f+=u>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${D+1} = vec4(previous.zw, xTexelC${D+1}.xy);\n                     } else {\n                      xC${D+1} = vec4(0.0, 0.0, xTexelC${D+1}.xy);\n                     }\n                     `:`\n                     xC${D+1} = vec4(xTexelC${D}.zw, xTexelC${D+1}.xy);\n                     `):f+=1===O?`\n                     xC${D+1} = xTexelC${D};\n                     `:`\n                     xCOffset = xC + ${O};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${D+1}Ready == 0) {\n                       xTexelC${D+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${D+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${D+1}Ready = 1;\n                     }\n\n                     xC${D+1} = xTexelC${D+1};\n                     `}}else D<l&&(i%2==1?(f+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${D}Ready == 0) {\n                   xTexelC${D} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${D}.zw = vec2(0.0);\n                   }\n                   xTexelC${D}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${D+1}Ready == 0) {\n                   xTexelC${D+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${D+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${D+1}Ready = 1;\n                 }\n\n                 xC${D} = vec4(xTexelC${D}.zw, xTexelC${D+1}.zw);\n               `,D+1<l&&(f+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${D+1} = vec4(xTexelC${D+1}.xy, final.xy);\n                 `)):(f+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${D}Ready == 0) {\n                   xTexelC${D} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${D}.zw = vec2(0.0);\n                   }\n                   xTexelC${D}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${D+1}Ready == 0) {\n                   xTexelC${D+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${D+1}.zw = vec2(0.);\n                   }\n                   xTexelC${D+1}Ready = 1;\n                 }\n\n                 xC${D} = vec4(\n                   xTexelC${D}.xy, xTexelC${D+1}.xy);\n               `,D+1<l&&(f+=`\n                   xC${D+1} = vec4(xTexelC${D}.zw, xTexelC${D+1}.zw);\n                 `)));D<l&&(f+=`\n             wTexel = getW(r, ${D}, d1, d2);\n             dotProd += xC${D}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${n.inChannels}) {\n               dotProd += xC${D}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,D+1<l&&(f+=`\n               wTexel = getW(r, ${D+1}, d1, d2);\n               dotProd += xC${D+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${n.inChannels}) {\n                 dotProd += xC${D+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}f+="\n     }\n   ",f+="\n     }\n   ",f+="\n     }\n   ";let m="",y="";r&&(m=s?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:o?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,y="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${m}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${f}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${w}\n         ${y}\n         setOutput(result);\n       }\n     `}}class Pj{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=n,this.enableShapeUniforms=To(this.outputShape.length);const{dataFormat:r}=e,s=Do(),o="channelsLast"===r,i=o?1:2,a=o?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${n[2]} && pos < ${n[1]}) {`;let c="";for(let l=0;l<=1;l++)for(let h=0;h<=1;h++)c+=`\n          blockIndex = rc.z + ${h};\n          pos = rc.y + ${l};\n\n          ${u}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${i}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${o}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*l+h}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*l+h}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${c}\n\n        ${s.output} = result;\n      }\n    `}}function bg(t,n){const e=t.length;return e>=3?n?[...t.slice(0,-3),t[e-3]*t[e-2],t[e-1]]:[...t.slice(0,-3),t[e-3],t[e-2]*t[e-1]]:!n&&1===e&&t[0]>1?[t[0],1]:null}function i_({x:t,filter:n,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const u=t.shape,c=r.texData.get(t.dataId),l=e.inChannels,h=u[0]*u[1]*u[2],f=e.outChannels,m="channelsLast"===e.dataFormat;let E;const D=[];if(null!=o){const q=bg(o.shape,m);null!=q&&(o=qt({inputs:{x:o},backend:r,attrs:{shape:q}}),D.push(o))}if(null!=s){const q=bg(s.shape,m);null!=q&&(s=qt({inputs:{x:s},backend:r,attrs:{shape:q}}),D.push(s))}if((1!==h&&1!==f||!(l>XE))&&c.isPacked&&m&&null!=c.texture&&u[2]%2!=0&&d.util.arraysEqual(c.shape.slice(-3),u.slice(-3))){const re={dataId:t.dataId,shape:[1,u[0]*u[1]*(u[2]+1),e.inChannels],dtype:t.dtype},pe=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,d.util.assert(ug(c.shape,re.shape),()=>`packed reshape ${c.shape} to ${re.shape} isn't free`);const Ae=qt({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});D.push(Ae);const Be=gg({a:re,b:Ae,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),Ke=r.texData.get(Be.dataId);d.util.assert(Ke.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=pe,Ke.shape=e.outShape,E=mi({inputs:{x:Be},backend:r}),E.shape=e.outShape,D.push(Be)}else{const q=e.outHeight*e.outWidth,re=qt({inputs:{x:t},backend:r,attrs:{shape:m?[e.batchSize,q,e.inChannels]:[e.batchSize,e.inChannels,q]}}),pe=qt({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),Ae=gg({a:m?re:pe,b:m?pe:re,transposeA:!m,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});E=qt({inputs:{x:Ae},backend:r,attrs:{shape:e.outShape}}),D.push(re),D.push(pe),D.push(Ae)}for(const q of D)r.disposeIntermediateTensorInfo(q);return E}function a_({x:t,filter:n,convInfo:e,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:u,filterHeight:c,inChannels:l,outWidth:h,outHeight:f,dataFormat:m}=e,y="channelsLast"===m,w=u*c*l,E=f*h,D=[e.batchSize,w,E],q=[];if(null!=o){const mt=bg(o.shape,y);null!=mt&&(o=qt({inputs:{x:o},backend:r,attrs:{shape:mt}}),q.push(o))}if(null!=s){const mt=bg(s.shape,y);null!=mt&&(s=qt({inputs:{x:s},backend:r,attrs:{shape:mt}}),q.push(s))}const re=qt({inputs:{x:n},backend:r,attrs:{shape:[1,w,d.util.sizeFromShape(n.shape)/w]}});q.push(re);const pe=new Pj(D,e),Be=r.runWebGLProgram(pe,[t],"float32",[t.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),Ke=qt({inputs:{x:Be},backend:r,attrs:{shape:D}});q.push(Be),q.push(Ke);const Ge=null!=s,ft=null!=o,yt="leakyrelu"===a,pt=a?kf(a,!0):null,wt=new zE(y?Ke.shape:re.shape,y?re.shape:Ke.shape,y?[e.batchSize,E,e.outChannels]:[e.batchSize,e.outChannels,E],!0,!1,Ge,pt,ft,yt),vt=y?[Ke,re]:[re,Ke];if(s&&vt.push(s),ft&&vt.push(o),yt){const mt=r.makeTensorInfo([],"float32",d.util.createScalarValue(i,"float32"));vt.push(mt),q.push(mt)}const xt=r.runWebGLProgram(wt,vt,"float32"),Et=qt({inputs:{x:xt},backend:r,attrs:{shape:e.outShape}});q.push(xt);for(const mt of q)r.disposeIntermediateTensorInfo(mt);return Et}const Bj={kernelName:d.Conv2D,backendName:"webgl",kernelFunc:function Lj(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dataFormat:u,dilations:c,dimRoundingMode:l}=r,h=d.backend_util.convertConv2DDataFormat(u),f=d.backend_util.computeConv2DInfo(s.shape,o.shape,i,c,a,l,!1,h);let m;if(1!==f.filterHeight||1!==f.filterWidth||1!==f.dilationHeight||1!==f.dilationWidth||1!==f.strideHeight||1!==f.strideWidth||"SAME"!==f.padInfo.type&&"VALID"!==f.padInfo.type)if(f.strideWidth<=2&&"channelsLast"===h&&(0,d.env)().getBool("WEBGL_EXP_CONV")){const w=new o_(f);m=e.runWebGLProgram(w,[s,o],"float32",[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]])}else if((0,d.env)().getBool("WEBGL_CONV_IM2COL"))m=a_({x:s,filter:o,convInfo:f,backend:e});else{const w=new s_(f);m=e.runWebGLProgram(w,[s,o],"float32")}else m=i_({x:s,filter:o,convInfo:f,backend:e});const y=qt({inputs:{x:m},backend:e,attrs:{shape:f.outShape}});return e.disposeIntermediateTensorInfo(m),y}};class Vj{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===n.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Uj{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,r=n.filterWidth,i="channelsLast"===n.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${i?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${i?1:2}], coords[${i?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Wj{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yF = 0; yF < ${n.outDepth}; yF++) {\n            int xF = wF + yF * ${n.strideDepth} - ${n.padInfo.front};\n\n            if (xF < 0 || xF >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${n.outHeight}; yR++) {\n              int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${n.outWidth}; yC++) {\n                int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class zj{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterDepth,r=n.filterHeight,s=n.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-n.padInfo.front}, ${r-1-n.padInfo.top}, ${s-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${n.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${n.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const jj={kernelName:d.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:function Hj(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,dataFormat:u,dimRoundingMode:c,filterShape:l}=r,h=d.backend_util.convertConv2DDataFormat(u),f=d.backend_util.computeConv2DInfo(s.shape,l,i,1,a,c,!1,h),m=new Vj(f);return e.runWebGLProgram(m,[s,o],"float32")}},Kj={kernelName:d.Conv2DBackpropInput,backendName:"webgl",kernelFunc:function Gj(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{inputShape:i,strides:a,pad:u,dataFormat:c,dimRoundingMode:l}=r,h=d.backend_util.convertConv2DDataFormat(c),f=d.backend_util.computeConv2DInfo(i,o.shape,a,1,u,l,!1,h),m=new Uj(f);return e.runWebGLProgram(m,[s,o],"float32")}},qj={kernelName:d.Conv3D,backendName:"webgl",kernelFunc:function Xj(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:u}=r,c=d.backend_util.computeConv3DInfo(s.shape,o.shape,i,u,a),l=new Fj(c);return e.runWebGLProgram(l,[s,o],"float32")}},Zj={kernelName:d.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:function Yj(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,pad:a,filterShape:u}=r,c=d.backend_util.computeConv3DInfo(s.shape,u,i,1,a),l=new Wj(c);return e.runWebGLProgram(l,[s,o],"float32")}},Jj={kernelName:d.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:function Qj(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{pad:i,strides:a,inputShape:u}=r,c=d.backend_util.computeConv3DInfo(u,o.shape,a,1,i),l=new zj(c);return e.runWebGLProgram(l,[s,o],"float32")}},tG=vr({opSnippet:Wd+"\n  return cos(x);\n"}),nG={kernelName:d.Cos,backendName:"webgl",kernelFunc:tG},rG=vr({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),sG={kernelName:d.Cosh,backendName:"webgl",kernelFunc:rG};class oG{constructor(n,e,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,u,c]=n,[l]=e,[h,f]=r;this.outputShape=[l,h,f,c];const m="bilinear"===s?1:0,[y,w]=[a-1+".0",u-1+".0"],[E,D,O]=h>1?[""+(a-1)/(h-1),"(y2-y1) * height_ratio",`y1*${y} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${y}`],[W,q,re]=f>1?[""+(u-1)/(f-1),"(x2-x1) * width_ratio",`x1*${w} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${w}`];this.userCode=`\n      const float height_ratio = float(${E});\n      const float width_ratio = float(${W});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${D};\n        float width_scale = ${q};\n\n        float in_y = ${O};\n        if( in_y < 0.0 || in_y > ${y} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${re};\n        if( in_x < 0.0 || in_x > ${w} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${m} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const aG={kernelName:d.CropAndResize,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{image:s,boxes:o,boxInd:i}=n,{cropSize:a,method:u,extrapolationValue:c}=r,l=new oG(s.shape,o.shape,a,u,c);return e.runWebGLProgram(l,[s,o,i],"float32")}};var Hd=(()=>(function(t){t.Prod="*",t.Sum="+"}(Hd||(Hd={})),Hd))();class u_{constructor(n,e,r,s){this.op=n,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,a=r?this.op===Hd.Prod?"1.0":"0.0":`getX(${c_(o,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let c="",l="";r?(c=s?"end != "+(u-1):"end != 0",l=s?"end + 1":"end - 1"):(c=s?`end + pow2 < ${u}`:"end >= pow2",l=s?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Hr(o)} coords = getOutputCoords();\n        int end = ${l_(o,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${c}) {\n          int idx = ${l};\n          ${l_(o,"coords",this.op)} = idx;\n          val ${this.op}= getX(${c_(o,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function c_(t,n,e){if(1===t)return`${n}`;if(2===t)return`${n}.x, ${n}.y`;if(3===t)return`${n}.x, ${n}.y, ${n}.z`;if(4===t)return`${n}.x, ${n}.y, ${n}.z, ${n}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}function l_(t,n,e){if(1===t)return`${n}`;if(2===t)return`${n}.y`;if(3===t)return`${n}.z`;if(4===t)return`${n}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}function d_(t,n,e,r,s,o){const i=n.shape.length,a=d.backend_util.getAxesPermutation([r],i);let u=n;null!=a&&(u=ko({inputs:{x:n},backend:e,attrs:{perm:a}}));const c=d.backend_util.getInnerMostAxes(1,i)[0];if(c!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${n.shape.length-1} but got axis=${r}`);const l=u.shape[c];let h=mi({inputs:{x:u},backend:e});for(let f=0;f<=Math.ceil(Math.log2(l))-1;f++){const m=new u_(t,u.shape,!1,o),w=h;h=e.runWebGLProgram(m,[h],h.dtype,[[f]]),e.disposeIntermediateTensorInfo(w)}if(s){const f=new u_(t,u.shape,s,o),m=h;h=e.runWebGLProgram(f,[h],h.dtype),e.disposeIntermediateTensorInfo(m)}if(null!=a){const m=ko({inputs:{x:h},backend:e,attrs:{perm:d.backend_util.getUndoAxesPermutation(a)}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(u),m}return h}const cG={kernelName:d.Cumprod,backendName:"webgl",kernelFunc:function uG(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;return d_(Hd.Prod,s,e,o,i,a)}},dG={kernelName:d.Cumsum,backendName:"webgl",kernelFunc:function lG(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;return d_(Hd.Sum,s,e,o,i,a)}},fG={kernelName:d.DenseBincount,backendName:"webgl",kernelFunc:function hG(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,weights:o}=n,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const u=e.readSync(s.dataId),c=e.readSync(o.dataId),l=kE(u,c,o.dtype,o.shape,i);return e.makeTensorInfo([i],o.dtype,l)}if(2===s.shape.length){const u=e.bufferSync(s),c=e.bufferSync(o),l=_W(u,c,i,a);return e.makeTensorInfo(l.shape,o.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class pG{constructor(n,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=n,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const gG={kernelName:d.DepthToSpace,backendName:"webgl",kernelFunc:function mG(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockSize:o,dataFormat:i}=r,a=s.shape[0],h=("NHWC"===i?s.shape[1]:s.shape[2])*o,f=("NHWC"===i?s.shape[2]:s.shape[3])*o,m=("NHWC"===i?s.shape[3]:s.shape[1])/(o*o),w=new pG("NHWC"===i?[a,h,f,m]:[a,m,h,f],o,i);return e.runWebGLProgram(w,[s],s.dtype)}};class h_{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=To(this.outputShape.length);const i=n.filterHeight,a=n.filterWidth,u=n.outChannels/n.inChannels;let c="",l="";r&&(c=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,l="result = activation(result);");const h=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${c}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${u};\n        int q = d2 - d1 * ${u};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${h}\n        ${l}\n        setOutput(result);\n      }\n    `}}class f_{constructor(n,e=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=To(this.outputShape.length);const i=n.outChannels/n.inChannels,a=n.padInfo.left,u=n.strideWidth,c=n.dilationWidth,l=n.filterHeight,h=n.filterWidth,f=h;let m="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let D=0;D<h;D++)m+=`\n          vec4 xTexelC${2*D};\n          int xTexelC${2*D}Ready;\n          vec4 xTexelC${2*D+1};\n          int xTexelC${2*D+1}Ready;\n          vec4 xC${D};`;m+=`\n    for (int r = 0; r < ${l}; r++) {\n      `;for(let D=0;D<h;D++)m+=`\n          xTexelC${2*D} = vec4(0.0);\n          xTexelC${2*D}Ready = 0;\n          xTexelC${2*D+1} = vec4(0.0);\n          xTexelC${2*D+1}Ready = 0;\n          xC${D} = vec4(0.0);`;m+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let D=0;D<(f+1)/2;D++){const O=2*D;if(m+=`\n          xC = xCCorner + ${O*c};\n          `,1===u){if(O<h&&(a%2==1?(m+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${O}Ready == 0) {\n                  xTexelC${O} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${O}.zw = vec2(0.0);\n                  }\n                  xTexelC${O}Ready = 1;\n                }\n              `,m+=1===c&&O>0?`\n                xC${O} = vec4(xTexelC${O-2}.zw, xTexelC${O}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${O} = vec4(previous.zw, xTexelC${O}.xy);\n                  } else {\n                    xC${O} = vec4(0.0, 0.0, xTexelC${O}.xy);\n                  }\n                  `):m+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${O}Ready == 0) {\n                  xTexelC${O} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${O}.zw = vec2(0.0);\n                  }\n                  xTexelC${O}Ready = 1;\n                }\n\n                xC${O} = xTexelC${O};\n                `,O+1<h)){const W=a%2==0?d.util.nearestLargerEven(c):c;c%2==0&&a%2==1||c%2!=0&&a%2!=1?(m+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${W};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${O+1}Ready == 0) {\n                    xTexelC${O+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${O+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${O+1}Ready = 1;\n                  }\n                  `,m+=c>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${O+1} = vec4(previous.zw, xTexelC${O+1}.xy);\n                    } else {\n                     xC${O+1} = vec4(0.0, 0.0, xTexelC${O+1}.xy);\n                    }\n                    `:`\n                    xC${O+1} = vec4(xTexelC${O}.zw, xTexelC${O+1}.xy);\n                    `):m+=1===W?`\n                    xC${O+1} = xTexelC${O};\n                    `:`\n                    xCOffset = xC + ${W};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${O+1}Ready == 0) {\n                      xTexelC${O+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${O+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${O+1}Ready = 1;\n                    }\n\n                    xC${O+1} = xTexelC${O+1};\n                    `}}else O<h&&(a%2==1?(m+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${O}Ready == 0) {\n                  xTexelC${O} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${O}.zw = vec2(0.0);\n                  }\n                  xTexelC${O}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${O+1}Ready == 0) {\n                  xTexelC${O+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${O+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${O+1}Ready = 1;\n                }\n\n                xC${O} = vec4(xTexelC${O}.zw, xTexelC${O+1}.zw);\n              `,O+1<h&&(m+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${O+1} = vec4(xTexelC${O+1}.xy, final.xy);\n                `)):(m+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${O}Ready == 0) {\n                  xTexelC${O} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${O}.zw = vec2(0.0);\n                  }\n                  xTexelC${O}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${O+1}Ready == 0) {\n                  xTexelC${O+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${O+1}.zw = vec2(0.);\n                  }\n                  xTexelC${O+1}Ready = 1;\n                }\n\n                xC${O} = vec4(\n                  xTexelC${O}.xy, xTexelC${O+1}.xy);\n              `,O+1<h&&(m+=`\n                  xC${O+1} = vec4(xTexelC${O}.zw, xTexelC${O+1}.zw);\n                `)));O<h&&(m+=`\n            wTexel = getW(r, ${O}, d1, q);\n            dotProd += xC${O} * vec4(wTexel.xz, wTexel.xz);\n          `,O+1<h&&(m+=`\n              wTexel = getW(r, ${O+1}, d1, q);\n              dotProd += xC${O+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}m+="\n    }\n  ",m+="\n      }\n    ";let y="",w="";r&&(y=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,w="result = activation(result);");const E=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${y}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${m}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${E}\n        ${w}\n        setOutput(result);\n      }\n    `}}const vG={kernelName:d.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:function yG(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:u,dimRoundingMode:c}=r;let l=u;null==l&&(l=[1,1]),d.util.assert(d.backend_util.eitherStridesOrDilationsAreOne(i,l),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const h=d.backend_util.computeConv2DInfo(s.shape,o.shape,i,l,a,c,!0);let f;return f=(0,d.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new f_(h):new h_(h),e.runWebGLProgram(f,[s,o],"float32",[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]])}};class xG{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${n.outChannels/n.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class bG{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const e=n.filterHeight,r=n.filterWidth,u=n.outChannels/n.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${u}; dm++) {\n              int d2 = d1 * ${u} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const CG={kernelName:d.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:function wG(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,dy:o}=n,{strides:i,dilations:a,pad:u,dimRoundingMode:c,filterShape:l}=r,h=d.backend_util.computeConv2DInfo(s.shape,l,i,a,u,c,!0),f=new xG(h);return e.runWebGLProgram(f,[s,o],"float32")}},EG={kernelName:d.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:function SG(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,filter:o}=n,{strides:i,dilations:a,pad:u,dimRoundingMode:c,inputShape:l}=r,h=d.backend_util.computeConv2DInfo(l,o.shape,i,a,u,c,!0),f=new bG(h);return e.runWebGLProgram(f,[s,o],"float32")}};class _G{constructor(n){this.variableNames=["X"],this.outputShape=[n,n],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const DG={kernelName:d.Diag,backendName:"webgl",kernelFunc:function IG(t){const{inputs:n,backend:e}=t,{x:r}=n,s=[...r.shape,...r.shape],o=d.util.sizeFromShape(r.shape),i=qt({inputs:{x:r},backend:e,attrs:{shape:[o]}}),a=new _G(o),u=e.runWebGLProgram(a,[i],i.dtype),c=qt({inputs:{x:u},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(u),c}};class TG{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const{inHeight:e,inWidth:r,padInfo:s,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:u,dilationHeight:c,dilationWidth:l}=n,{top:h,left:f}=s;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${h}, ${f});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${c};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${u}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const kG={kernelName:d.Dilation2D,backendName:"webgl",kernelFunc:function NG(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o}=n,{strides:i,pad:a,dilations:u}=r,c=d.backend_util.computeDilation2DInfo(s.shape,o.shape,i,a,"NHWC",u);let l;const h=new TG(c);l=e.runWebGLProgram(h,[s,o],"float32");const f=qt({inputs:{x:l},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(l),f}},RG={kernelName:d.Einsum,backendName:"webgl",kernelFunc:function AG(t){const{inputs:n,backend:e,attrs:r}=t,{equation:s}=r,o=n,{allDims:i,summedDims:a,idDims:u}=d.backend_util.decodeEinsumEquation(s,o.length);d.backend_util.checkEinsumDimSizes(i.length,u,o);const{path:c,steps:l}=d.backend_util.getEinsumComputePath(a,u),h=l.length;let f=null,m=i.length;const y=[];for(let w=0;w<h;++w){for(const E of l[w]){const{permutationIndices:D,expandDims:O}=d.backend_util.getEinsumPermutation(m,u[E]);let W;d.backend_util.isIdentityPermutation(D)?W=o[E]:(W=ko({inputs:{x:o[E]},backend:e,attrs:{perm:D}}),y.push(W));const q=W.shape.slice();for(let re=0;re<O.length;++re)q.splice(O[re],0,1);d.util.arraysEqual(W.shape,q)||(W=qt({inputs:{x:W},backend:e,attrs:{shape:q}}),y.push(W)),null===f?f=W:(f=U3({inputs:{a:W,b:f},backend:e}),y.push(f))}w<h-1&&(c[w]>=0&&(f=mg({inputs:{x:f},backend:e,attrs:{axis:c[w]-(i.length-m),keepDims:!1}}),y.push(f)),m--)}for(const w of y)w!==f&&e.disposeIntermediateTensorInfo(w);return f}},OG=vr({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),MG={kernelName:d.Elu,backendName:"webgl",kernelFunc:OG},LG={kernelName:d.EluGrad,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e}=t,{dy:r,y:s}=n,o=(0,d.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Nf("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new Ud("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,s.shape);return e.runWebGLProgram(o,[r,s],r.dtype)}},BG=ro({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:NW}),VG={kernelName:d.Equal,backendName:"webgl",kernelFunc:BG},WG=vr({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${d.backend_util.ERF_P};\n  float a1 = ${d.backend_util.ERF_A1};\n  float a2 = ${d.backend_util.ERF_A2};\n  float a3 = ${d.backend_util.ERF_A3};\n  float a4 = ${d.backend_util.ERF_A4};\n  float a5 = ${d.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),zG={kernelName:d.Erf,backendName:"webgl",kernelFunc:WG},p_=vr({opSnippet:Wd+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:kW,dtype:"float32"}),jG={kernelName:d.Exp,backendName:"webgl",kernelFunc:p_};function j3(t){const{inputs:n,attrs:e,backend:r}=t,{dim:s}=e,{input:o}=n,i=o.shape.length,a=o.shape.slice();let u=s;return s<0&&(d.util.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),qt({inputs:{x:o},backend:r,attrs:{shape:a}})}const GG={kernelName:d.ExpandDims,backendName:"webgl",kernelFunc:j3},m_="return exp(x) - 1.0;",KG=vr({opSnippet:m_,packedOpSnippet:m_,cpuKernelImpl:AW}),XG={kernelName:d.Expm1,backendName:"webgl",kernelFunc:KG};class g_{constructor(n,e,r){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let a;if("real"===n)a="return real * expR - imag * expI;";else{if("imag"!==n)throw new Error(`FFT component must be either "real" or "imag", got ${n}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function y_(t,n,e){const r=e.texData.get(t.dataId),s=d.util.sizeFromShape(t.shape),o=t.shape[t.shape.length-1],a=qt({inputs:{x:t},backend:e,attrs:{shape:[s/o,o]}}),u=a.shape,c=new g_("real",u,n),l=new g_("imag",u,n),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],f=e.runWebGLProgram(c,h,"float32"),m=e.runWebGLProgram(l,h,"float32"),y=xc({inputs:{real:f,imag:m},backend:e});e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m);const w=qt({inputs:{x:y},backend:e,attrs:{shape:t.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(y),w}const YG={kernelName:d.FFT,backendName:"webgl",kernelFunc:function qG(t){const{inputs:n,backend:e}=t,{input:r}=n;return y_(r,!1,e)}};class ZG{constructor(n,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=n,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Mf(t){const{backend:n,attrs:e}=t,{shape:r,value:s}=e;let{dtype:o}=e;if(o=o||d.util.inferDtype(s),"string"===o){const i=d.util.getArrayFromDType(o,d.util.sizeFromShape(r));return i.fill(s),n.makeTensorInfo(r,o,i)}{const i=new ZG(r,s);return n.runWebGLProgram(i,[],o,[[s]])}}const QG={kernelName:d.Fill,backendName:"webgl",kernelFunc:Mf};class JG{constructor(n){this.variableNames=["Image"],this.outputShape=[];const e=n[2];this.outputShape=n,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const eK={kernelName:d.FlipLeftRight,backendName:"webgl",kernelFunc:({inputs:t,backend:n})=>{const{image:e}=t,r=n,s=new JG(e.shape);return r.runWebGLProgram(s,[e],e.dtype)}},v_="return floor(x);",tK=vr({opSnippet:v_,packedOpSnippet:v_,cpuKernelImpl:RW}),nK={kernelName:d.Floor,backendName:"webgl",kernelFunc:tK},rK=ro({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),sK={kernelName:d.FloorDiv,backendName:"webgl",kernelFunc:rK};class oK{constructor(n){this.variableNames=["A"];const e=Do(),[r,s]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class iK{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Do(),[r,s]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const aK={kernelName:d.FromPixels,backendName:"webgl",kernelFunc:function uK(t){const{inputs:n,backend:e,attrs:r}=t;let{pixels:s}=n;const{numChannels:o}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[u,c]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],l=[c,u],h=[c,u,o];if(a||i){const w=(0,d.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==jd||w!==G3)&&(G3=w,jd=document.createElement("canvas").getContext("2d",{willReadFrequently:G3})),jd.canvas.width=u,jd.canvas.height=c,jd.drawImage(s,0,0,u,c),s=jd.canvas}const f=e.makeTensorInfo(l,"int32");e.texData.get(f.dataId).usage=pi.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(f.dataId),s);const m=(0,d.env)().getBool("WEBGL_PACK")?new iK(h):new oK(h),y=e.runWebGLProgram(m,[f],"int32");return e.disposeData(f.dataId),y}};let jd,G3=(0,d.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const lK={kernelName:d.FusedConv2D,backendName:"webgl",kernelFunc:function cK(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:u,pad:c,dataFormat:l,dilations:h,dimRoundingMode:f,activation:m,leakyreluAlpha:y}=r,w=d.backend_util.convertConv2DDataFormat(l),E=d.backend_util.computeConv2DInfo(s.shape,o.shape,u,h,c,f,!1,w);let D;const O=[],W=null!=i,q=null!=a,re="leakyrelu"===m,pe=()=>{const Be=[s,o],Ke=(Ge,ft)=>{if("NCHW"===ft&&1===Ge.shape.length&&1!==Ge.shape[0]){const yt=qt({inputs:{x:Ge},backend:e,attrs:{shape:[Ge.shape[0],1,1]}});return O.push(yt),yt}return Ge};if(W&&Be.push(Ke(i,l)),q&&Be.push(Ke(a,l)),re){const Ge=e.makeTensorInfo([],"float32",d.util.createScalarValue(y,"float32"));Be.push(Ge),O.push(Ge)}return Be};if(1!==E.filterHeight||1!==E.filterWidth||1!==E.dilationHeight||1!==E.dilationWidth||1!==E.strideHeight||1!==E.strideWidth||"SAME"!==E.padInfo.type&&"VALID"!==E.padInfo.type)if(E.strideWidth<=2&&"channelsLast"===w&&(0,d.env)().getBool("WEBGL_EXP_CONV")){const Be=m?kf(m,!0):null,Ke=new o_(E,W,Be,q,re),Ge=[[E.padInfo.top,E.padInfo.left],[E.strideHeight,E.strideWidth],[E.dilationHeight,E.dilationWidth],[E.inHeight,E.inWidth]],ft=pe();D=e.runWebGLProgram(Ke,ft,"float32",Ge)}else if((0,d.env)().getBool("WEBGL_CONV_IM2COL"))D=a_({x:s,filter:o,convInfo:E,backend:e,bias:i,activation:m,preluActivationWeights:a,leakyreluAlpha:y});else{const Be=m?kf(m,!1):null,Ke=new s_(E,W,Be,q,re),Ge=pe();D=e.runWebGLProgram(Ke,Ge,"float32")}else D=i_({x:s,filter:o,convInfo:E,backend:e,bias:i,activation:m,preluActivationWeights:a,leakyreluAlpha:y});const Ae=qt({inputs:{x:D},backend:e,attrs:{shape:E.outShape}});return O.push(D),O.forEach(Be=>e.disposeIntermediateTensorInfo(Be)),Ae}},hK={kernelName:d.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:function dK(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:u,pad:c,dilations:l,dimRoundingMode:h,activation:f,leakyreluAlpha:m}=r,y=[];let w=l;null==w&&(w=[1,1]),d.util.assert(d.backend_util.eitherStridesOrDilationsAreOne(u,w),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${w}'`);const E=d.backend_util.computeConv2DInfo(s.shape,o.shape,u,w,c,h,!0),D=(0,d.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&E.strideWidth<=2&&E.outChannels/E.inChannels==1,O=f?kf(f,D):null,W=[s,o],q=null!=i,re=null!=a,pe="leakyrelu"===f;if(q&&W.push(i),re&&W.push(a),pe){const Ge=e.makeTensorInfo([],"float32",d.util.createScalarValue(m,"float32"));W.push(Ge),y.push(Ge)}let Ae;Ae=D?new f_(E,q,O,re,pe):new h_(E,q,O,re,pe);const Ke=e.runWebGLProgram(Ae,W,"float32",[[E.padInfo.top,E.padInfo.left],[E.strideHeight,E.strideWidth],[E.dilationHeight,E.dilationWidth],[E.inHeight,E.inWidth]]);return y.forEach(Ge=>e.disposeIntermediateTensorInfo(Ge)),Ke}};class fK{constructor(n,e,r,s){this.sliceDim=n,this.strides=e,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const o=Hr(r.length);let i="\n    int index;";for(let a=0;a<this.sliceDim;a++)i+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${i}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const mK={kernelName:d.GatherNd,backendName:"webgl",kernelFunc:function pK(t){const{inputs:n,backend:e}=t,{params:r,indices:s}=n,o=s.shape,i=o[o.length-1],a=d.util.sizeFromShape(r.shape),[u,c,l,h]=d.backend_util.prepareAndValidate(r,s),f=qt({inputs:{x:s},backend:e,attrs:{shape:[c,i]}}),m=qt({inputs:{x:r},backend:e,attrs:{shape:[d.util.sizeFromShape(r.shape)/l,l]}});if(e.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const D=e.readSync(s.dataId),O=e.bufferSync(r),W=OW(D,O,r.dtype,c,i,l,h,r.shape,a);return e.makeTensorInfo(u,r.dtype,W.values)}const y=new fK(i,h,[c,l],r.shape),w=e.runWebGLProgram(y,[m,f],m.dtype),E=qt({inputs:{x:w},backend:e,attrs:{shape:u}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(w),E}};class gK{constructor(n,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=Hr(this.rank),s=function yK(t,n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<t.length;s++)r.push(2===s?"index":`${e[s]}`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${n[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function x_(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,indices:o}=n,{axis:i,batchDims:a}=r,u=d.util.parseAxisParam(i,s.shape)[0];if((0,d.env)().get("DEBUG")){const O=e.readSync(o.dataId),W=s.shape[u];for(let q=0;q<O.length;++q){const re=O[q];d.util.assert(re<=W-1&&re>=0,()=>`GatherV2: the index value ${re} is not in [0, ${W-1}]`)}}const c=d.backend_util.segment_util.collectGatherOpShapeInfo(s,o,u,a),l=d.util.sizeFromShape(o.shape),h=[],f=qt({inputs:{x:s},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),m=qt({inputs:{x:o},backend:e,attrs:{shape:[c.batchSize,l/c.batchSize]}});h.push(f),h.push(m);const y=[c.batchSize,c.outerSize,l/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([s,o])||"string"===s.dtype){const O=e.bufferSync(m),W=e.bufferSync(f),q=MW(W,O,y);return h.forEach(re=>e.disposeIntermediateTensorInfo(re)),e.makeTensorInfo(c.outputShape,q.dtype,q.values)}const w=new gK(f.shape,y),E=e.runWebGLProgram(w,[f,m],f.dtype);h.push(E);const D=qt({inputs:{x:E},backend:e,attrs:{shape:c.outputShape}});return h.forEach(O=>e.disposeIntermediateTensorInfo(O)),D}const vK={kernelName:d.GatherV2,backendName:"webgl",kernelFunc:x_},xK=ro({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:$W,dtype:"bool"}),bK={kernelName:d.Greater,backendName:"webgl",kernelFunc:xK},wK=ro({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:FW}),CK={kernelName:d.GreaterEqual,backendName:"webgl",kernelFunc:wK},EK={kernelName:d.IFFT,backendName:"webgl",kernelFunc:function SK(t){const{inputs:n,backend:e}=t,{input:r}=n;return y_(r,!0,e)}},_K=vr({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),IK={kernelName:d.IsFinite,backendName:"webgl",kernelFunc:_K},DK=vr({opSnippet:"return float(isinf(x));",dtype:"bool"}),TK={kernelName:d.IsInf,backendName:"webgl",kernelFunc:DK},NK=vr({opSnippet:"return float(isnan(x));",dtype:"bool"}),kK={kernelName:d.IsNan,backendName:"webgl",kernelFunc:NK},AK=ro({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:PW,dtype:"bool"}),RK={kernelName:d.Less,backendName:"webgl",kernelFunc:AK},OK=ro({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:LW,dtype:"bool"}),MK={kernelName:d.LessEqual,backendName:"webgl",kernelFunc:OK},FK={kernelName:d.LinSpace,backendName:"webgl",kernelFunc:function $K(t){const{backend:n,attrs:e}=t,{start:r,stop:s,num:o}=e,i=BW(r,s,o);return n.makeTensorInfo([i.length],"float32",i)}},LK=vr({opSnippet:Wd+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:VW}),BK={kernelName:d.Log,backendName:"webgl",kernelFunc:LK},UK=vr({opSnippet:Wd+"\n  return log(1.0 + x);\n"}),WK={kernelName:d.Log1p,backendName:"webgl",kernelFunc:UK},zK=ro({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),HK={kernelName:d.LogicalAnd,backendName:"webgl",kernelFunc:zK},jK=vr({opSnippet:"return float(!(x >= 1.0));"}),GK={kernelName:d.LogicalNot,backendName:"webgl",kernelFunc:jK},KK=ro({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),XK={kernelName:d.LogicalOr,backendName:"webgl",kernelFunc:KK};class qK{constructor(n,e,r,s,o){this.variableNames=["x"],this.outputShape=[];const i=e,a=n[3]-1;let u;this.outputShape=n;const c=`float(${r}) + float(${s}) * sum`;u=.5===o?`inversesqrt(${c})`:1===o?`1.0/(${c})`:`exp(log(${c}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${u};\n        setOutput(val);\n      }\n    `}}class YK{constructor(n,e,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,a=n[3]-1;let u;this.outputShape=n;const c=`float(${r}) + float(${s}) * sum`;u=.5===o?`inversesqrt(${c})`:1===o?`1.0/(${c})`:`exp(log(${c}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${u};\n        setOutput(result);\n      }\n    `}}const QK={kernelName:d.LRN,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{depthRadius:o,bias:i,alpha:a,beta:u}=r,c=(0,d.env)().getBool("WEBGL_PACK_NORMALIZATION")?new YK(s.shape,o,i,a,u):new qK(s.shape,o,i,a,u);return e.runWebGLProgram(c,[s],s.dtype)}};class JK{constructor(n,e,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=n,this.depth=n[3],this.depthRadius=e,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${o})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const tX={kernelName:d.LRNGrad,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s,y:o,dy:i}=n,{depthRadius:a,bias:u,alpha:c,beta:l}=r,h=new JK(s.shape,a,u,c,l);return e.runWebGLProgram(h,[s,o,i],s.dtype)}};function b_(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,u=d.util.parseAxisParam(o,s.shape);let c=u;const l=d.backend_util.getAxesPermutation(c,a),h=null!=l,f=e.shouldExecuteOnCPU([s]);let m=s;if(h){if(f){const W=e.texData.get(m.dataId).values,q=new Array(a);for(let Ae=0;Ae<q.length;Ae++)q[Ae]=s.shape[l[Ae]];const re=B3(W,s.shape,s.dtype,l,q);m=e.makeTensorInfo(q,s.dtype),e.texData.get(m.dataId).values=re}else m=pg(s,l,e);c=d.backend_util.getInnerMostAxes(c.length,a)}d.backend_util.assertAxesAreInnerMostDims("max",c,a);const[y,w]=d.backend_util.computeOutAndReduceShapes(m.shape,c);let D,E=y;if(i&&(E=d.backend_util.expandShapeToKeepDim(y,u)),f){const W=e.texData.get(m.dataId).values,q=UW(W,d.util.sizeFromShape(w),E,s.dtype);D=e.makeTensorInfo(E,s.dtype),e.texData.get(D.dataId).values=q}else D=function nX(t,n,e,r){const s=d.util.sizeFromShape(n),a=qt({inputs:{x:t},attrs:{shape:[d.util.sizeFromShape(t.shape)/s,s]},backend:r}),u=al(a,t.dtype,"max",r),c=qt({inputs:{x:u},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(u),c}(m,w,E,e);return h&&e.disposeIntermediateTensorInfo(m),D}const rX={kernelName:d.Max,backendName:"webgl",kernelFunc:b_},iX=ro({opSnippet:V3+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Tf+"\n  return result;\n",cpuKernelImpl:WW}),aX={kernelName:d.Maximum,backendName:"webgl",kernelFunc:iX},cX={kernelName:d.MaxPool,backendName:"webgl",kernelFunc:function uX(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n;If(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=r;d.util.assert(d.backend_util.eitherStridesOrDilationsAreOne(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=d.backend_util.computePool2DInfo(s.shape,o,i,1,a,u);if(1===l.filterWidth&&1===l.filterHeight&&d.util.arraysEqual(l.inShape,l.outShape))return mi({inputs:{x:s},backend:e});const h=new Af(l,"max",!1);return e.runWebGLProgram(h,[s],s.dtype)}},dX={kernelName:d.MaxPool3D,backendName:"webgl",kernelFunc:function lX(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{filterSize:o,strides:i,pad:a,dataFormat:u,dimRoundingMode:c}=r,h=d.backend_util.computePool3DInfo(s.shape,o,i,[1,1,1],a,c,u),f=new W3(h,"max",!1);return e.runWebGLProgram(f,[s],s.dtype)}};class hX{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const o=n.effectiveFilterHeight,i=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${o-1-n.padInfo.top}, ${i-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${o*i-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class fX{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const u=n.effectiveFilterDepth,c=n.effectiveFilterHeight,l=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${u-1-n.padInfo.front}, ${c-1-n.padInfo.top}, ${l-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${u};\n           wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${l};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${u*c*l-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${c} * ${l} +\n                  wR * ${l} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const mX={kernelName:d.MaxPool3DGrad,backendName:"webgl",kernelFunc:function pX(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o}=n,i=o,{filterSize:a,strides:u,pad:c,dimRoundingMode:l}=r,f=d.backend_util.computePool3DInfo(i.shape,a,u,[1,1,1],c,l),m=new W3(f,"max",!0),y=e.runWebGLProgram(m,[i],i.dtype),w=new fX(f),E=e.runWebGLProgram(w,[s,y],i.dtype);return e.disposeIntermediateTensorInfo(y),E}},yX={kernelName:d.MaxPoolGrad,backendName:"webgl",kernelFunc:function gX(t){const{inputs:n,backend:e,attrs:r}=t,{dy:s,input:o,output:i}=n,a=o;If([o,i],"maxPoolGrad");const{filterSize:u,strides:c,pad:l,dimRoundingMode:h}=r,f=d.backend_util.computePool2DInfo(a.shape,u,c,1,l,h),y=new Af(f,"max",!0),w=e.runWebGLProgram(y,[a],a.dtype),E=new hX(f),D=e.runWebGLProgram(E,[s,w],a.dtype);return e.disposeIntermediateTensorInfo(w),D}},xX={kernelName:d.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=n,u=e;d.util.assert(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];d.util.assert(d.backend_util.eitherStridesOrDilationsAreOne(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const l=d.backend_util.computePool2DInfo(r.shape,s,o,c,i),[h,f]=function vX(t,n,e,r){let s=new Af(e,"max",!1);const o=r.runWebGLProgram(s,[t],"float32");return s=new Af(e,"max",!0,!0,n),[o,r.runWebGLProgram(s,[t],"float32")]}(r,a,l,u);return[h,f]}},wX={kernelName:d.Mean,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{x:r}=t,{keepDims:s,axis:o}=n,i=e,a=r.shape.length,u=d.util.parseAxisParam(o,r.shape);let c=u;const l=d.backend_util.getAxesPermutation(c,a),h=null!=l,f=i.shouldExecuteOnCPU([r]),m=[];let y=r;if(h){if(f){const q=i.texData.get(y.dataId).values,re=new Array(a);for(let Be=0;Be<re.length;Be++)re[Be]=r.shape[l[Be]];const pe=B3(q,r.shape,r.dtype,l,re);y=i.makeTensorInfo(re,r.dtype),i.texData.get(y.dataId).values=pe}else y=pg(r,l,i);m.push(y),c=d.backend_util.getInnerMostAxes(c.length,a)}d.backend_util.assertAxesAreInnerMostDims("sum",c,a);const[w,E]=d.backend_util.computeOutAndReduceShapes(y.shape,c);let D=w;s&&(D=d.backend_util.expandShapeToKeepDim(w,u));const O=function bX(t,n,e,r){const s=d.util.sizeFromShape(n),a=qt({inputs:{x:t},attrs:{shape:[d.util.sizeFromShape(t.shape)/s,s]},backend:r}),u=al(a,"float32","mean",r),c=qt({inputs:{x:u},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(u),c}(y,E,D,i);for(const W of m)i.disposeIntermediateTensorInfo(W);return O}},SX={kernelName:d.Min,backendName:"webgl",kernelFunc:function CX(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,u=d.util.parseAxisParam(o,s.shape);let c=u;const l=d.backend_util.getAxesPermutation(c,a);let h=s;null!=l&&(h=ko({inputs:{x:s},backend:e,attrs:{perm:l}}),c=d.backend_util.getInnerMostAxes(c.length,s.shape.length)),d.backend_util.assertAxesAreInnerMostDims("min",c,a);const[f,m]=d.backend_util.computeOutAndReduceShapes(h.shape,c),w=qt({inputs:{x:h},backend:e,attrs:{shape:[-1,d.util.sizeFromShape(m)]}}),E=al(w,w.dtype,"min",e);let D;return D=qt(i?{inputs:{x:E},backend:e,attrs:{shape:d.backend_util.expandShapeToKeepDim(f,u)}}:{inputs:{x:E},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(E),null!=l&&e.disposeIntermediateTensorInfo(h),D}},IX=ro({opSnippet:V3+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Tf+"\n  return result;\n",cpuKernelImpl:zW}),DX={kernelName:d.Minimum,backendName:"webgl",kernelFunc:IX};class TX{constructor(n,e,r){this.variableNames=["x"],this.outputShape=e.map((l,h)=>l[0]+n[h]+l[1]);const s=n.length,o=Hr(s),i=e.map(l=>l[0]).join(","),a=e.map((l,h)=>l[0]+n[h]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c="reflect"===r?0:1;this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${c};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${u}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${c};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${c};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class NX{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((y,w)=>y[0]+n[w]+y[1]);const s=n.length,o=Hr(s),i=e.map(y=>y[0]).join(","),a=e.map((y,w)=>y[0]+n[w]).join(","),u=No("rc",s),c=No("source",s),l=`${u[s-1]} < ${this.outputShape[s-1]}`,h=1===s?"source":`vec2(${c.slice(-2).join()})`,f="reflect"===r?0:1;let m="";if(1===s){const y=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${f};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${f};\n        }\n        source -= start;\n      `;m=`\n        ${o} rc = outputLoc;\n        ${y}\n        result[0] = getChannel(getX(${c.join()}), ${h});\n        ${u[s-1]} += 1;\n        if(${l}) {\n          ${y}\n          result[1] = getChannel(getX(${c.join()}), ${h});\n        }\n      `}else{const y=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${f}) +\n                gte * ((end - 1) * 2 - source + ${f});\n        source -= start;\n      `;m=`\n        ${o} rc = outputLoc;\n        ${y}\n        result[0] = getChannel(getX(${c.join()}), ${h});\n        ${u[s-1]} += 1;\n        if(${l}) {\n          ${y}\n          result[1] = getChannel(getX(${c.join()}), ${h});\n        }\n        rc = outputLoc;\n        ${u[s-2]} += 1;\n        if(${u[s-2]} < ${this.outputShape[s-2]}) {\n          ${y}\n          result[2] = getChannel(getX(${c.join()}), ${h});\n          ${u[s-1]} += 1;\n          if(${l}) {\n            ${y}\n            result[3] = getChannel(getX(${c.join()}), ${h});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${m}\n        setOutput(result);\n      }\n    `}}const AX={kernelName:d.MirrorPad,backendName:"webgl",kernelFunc:({inputs:t,backend:n,attrs:e})=>{const{x:r}=t,{paddings:s,mode:o}=e,i=(0,d.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new NX(r.shape,s,o):new TX(r.shape,s,o);return n.runWebGLProgram(i,[r],r.dtype)}},MX=ro({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+Tf+"\n  return result;\n"}),$X={kernelName:d.Mod,backendName:"webgl",kernelFunc:MX};class FX{constructor(n,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[n,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const w_=ro({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),PX={kernelName:d.RealDiv,backendName:"webgl",kernelFunc:w_},C_="return a - b;",S_=ro({opSnippet:C_,packedOpSnippet:C_,supportsComplex:!0,cpuKernelImpl:uz}),LX={kernelName:d.Sub,backendName:"webgl",kernelFunc:S_};function E_(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{dim:o}=r,i=d.util.parseAxisParam([o],s.shape),a=b_({inputs:{x:s},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),u=d.backend_util.expandShapeToKeepDim(a.shape,i),c=qt({inputs:{x:a},backend:e,attrs:{shape:u}}),l=S_({inputs:{a:s,b:c},backend:e}),h=p_({inputs:{x:l},backend:e}),f=mg({inputs:{x:h},backend:e,attrs:{axis:i,keepDims:!1}}),m=qt({inputs:{x:f},backend:e,attrs:{shape:u}}),y=w_({inputs:{a:h,b:m},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),y}const BX={kernelName:d.Softmax,backendName:"webgl",kernelFunc:E_},UX={kernelName:d.Multinomial,backendName:"webgl",kernelFunc:function VX(t){const{inputs:n,backend:e,attrs:r}=t,{logits:s}=n,{numSamples:o,seed:i,normalized:a}=r,u=a?s:E_({inputs:{logits:s},backend:e,attrs:{dim:s.shape.length-1}}),h=new FX(u.shape[0],u.shape[1],o),m=e.runWebGLProgram(h,[u],"int32",[[i]]);return a||e.disposeIntermediateTensorInfo(u),m}},WX=Li+"\n  return -x;\n",jX={kernelName:d.Neg,backendName:"webgl",kernelFunc:function HX(t){const{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId),[i,a]=jW(o.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,i)}let s;return s=(0,d.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new il(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new zu(r.shape,WX),e.runWebGLProgram(s,[r],r.dtype)}},GX=d.kernel_impls.nonMaxSuppressionV3Impl,XX={kernelName:d.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function KX(t){d.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=r,c=e.readSync(s.dataId),l=e.readSync(o.dataId),{selectedIndices:h}=GX(c,l,i,a,u);return e.makeTensorInfo([h.length],"int32",new Int32Array(h))}},qX=d.kernel_impls.nonMaxSuppressionV4Impl,ZX={kernelName:d.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function YX(t){d.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:c}=r,l=e.readSync(s.dataId),h=e.readSync(o.dataId),{selectedIndices:f,validOutputs:m}=qX(l,h,i,a,u,c);return[e.makeTensorInfo([f.length],"int32",new Int32Array(f)),e.makeTensorInfo([],"int32",new Int32Array([m]))]}},QX=d.kernel_impls.nonMaxSuppressionV5Impl,eq={kernelName:d.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function JX(t){d.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:e,attrs:r}=t,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:c}=r,l=e.readSync(s.dataId),h=e.readSync(o.dataId),f=i,m=a,y=u,w=c,{selectedIndices:E,selectedScores:D}=QX(l,h,f,m,y,w);return[e.makeTensorInfo([E.length],"int32",new Int32Array(E)),e.makeTensorInfo([D.length],"float32",new Float32Array(D))]}};class tq{constructor(n,e,r,s){this.variableNames=["indices"],this.outputShape=[n,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const rq={kernelName:d.OneHot,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{indices:s}=n,{dtype:o,depth:i,onValue:a,offValue:u}=r,c=d.util.sizeFromShape(s.shape),l=new tq(c,i,a,u),h=qt({inputs:{x:s},backend:e,attrs:{shape:[c]}}),f=e.runWebGLProgram(l,[h],o);e.disposeIntermediateTensorInfo(h);const y=qt({inputs:{x:f},backend:e,attrs:{shape:[...s.shape,i]}});return e.disposeIntermediateTensorInfo(f),y}};function wg(t){const{inputs:n,backend:e}=t,{x:r}=n;if("complex64"===r.dtype){const s=Rf({inputs:{input:r},backend:e}),o=wg({inputs:{x:s},backend:e}),i=xg({inputs:{input:r},backend:e}),a=wg({inputs:{x:i},backend:e}),u=xc({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}return Mf({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const sq={kernelName:d.ZerosLike,backendName:"webgl",kernelFunc:wg},oq={kernelName:d.OnesLike,backendName:"webgl",kernelFunc:function __(t){const{inputs:n,backend:e}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const s=Rf({inputs:{input:r},backend:e}),o=__({inputs:{x:s},backend:e}),i=xg({inputs:{input:r},backend:e}),a=wg({inputs:{x:i},backend:e}),u=xc({inputs:{real:o,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}return Mf({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},aq={kernelName:d.Pack,backendName:"webgl",kernelFunc:function iq(t){const{inputs:n,backend:e,attrs:r}=t,{axis:s}=r;if(1===n.length)return j3({inputs:{input:n[0]},backend:e,attrs:{dim:s}});const o=n[0].shape,i=n[0].dtype;n.forEach(l=>{d.util.assertShapesMatch(o,l.shape,"All tensors passed to stack must have matching shapes"),d.util.assert(i===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=r_({inputs:n.map(l=>{const h=j3({inputs:{input:l},backend:e,attrs:{dim:s}});return a.push(h),h}),backend:e,attrs:{axis:s}});return a.forEach(l=>e.disposeIntermediateTensorInfo(l)),c}};class uq{constructor(n,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((c,l)=>c[0]+n[l]+c[1]);const s=n.length,o=Hr(s),i=e.map(c=>c[0]).join(","),a=e.map((c,l)=>c[0]+n[l]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${u}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class cq{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((w,E)=>w[0]+n[E]+w[1]);const s=n.length,o=Hr(s),i=e.map(w=>w[0]).join(","),a=e.map((w,E)=>w[0]+n[E]).join(","),u=No("rc",s),c=No("source",s),l=`${u[s-1]} < ${this.outputShape[s-1]}`,h=1===s?"source":`vec2(${c.slice(-2).join()})`,f=[`${o} rc = outputLoc;`,`${u[s-1]} += 1;\n       if(${l}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${u[s-2]} += 1;\n       if(${u[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${u[s-1]} += 1;\n         if(${l}) {`],m=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let y="";for(let w=0,E=1===s?2:4;w<E;w++)y+=`\n        ${f[w]}\n        if (${m}) {\n          result[${w}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${w}] = getChannel(getX(${c.join()}), ${h});\n        }\n      `;y+=1===s?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${y}\n        setOutput(result);\n      }\n    `}}const I_=t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{paddings:o,constantValue:i}=r;if(0===d.util.sizeFromShape(s.shape))return Mf({backend:e,attrs:{shape:o.map((l,h)=>l[0]+s.shape[h]+l[1]),value:i,dtype:s.dtype}});const a=(0,d.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cq(s.shape,o,i):new uq(s.shape,o,i);return e.runWebGLProgram(a,[s],s.dtype,[[i]])},lq={kernelName:d.PadV2,backendName:"webgl",kernelFunc:I_},fq=ro({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+Tf+"\n  return result;\n"}),pq={kernelName:d.Pow,backendName:"webgl",kernelFunc:fq},gq={kernelName:d.Prod,backendName:"webgl",kernelFunc:function mq(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,u=[],c=d.util.parseAxisParam(o,s.shape);let l=c;const h=d.backend_util.getAxesPermutation(l,a);let m,f=s;if(null!=h&&(f=ko({inputs:{x:s},backend:e,attrs:{perm:h}}),l=d.backend_util.getInnerMostAxes(l.length,a),u.push(f)),d.backend_util.assertAxesAreInnerMostDims("prod",l,a),e.shouldExecuteOnCPU([f])){const y=e.texData.get(f.dataId).values,{outVals:w,outShape:E,outDtype:D}=KW(f.shape,f.dtype,y,l);m=e.makeTensorInfo(E,D,w)}else{const[y,w]=d.backend_util.computeOutAndReduceShapes(f.shape,l),E=d.util.sizeFromShape(w),D=qt({inputs:{x:f},backend:e,attrs:{shape:[-1,E]}}),W=al(D,(0,d.sumOutType)(s.dtype),"prod",e);m=qt({inputs:{x:W},backend:e,attrs:{shape:y}}),u.push(D),u.push(W)}if(i){u.push(m);const y=d.backend_util.expandShapeToKeepDim(m.shape,c);m=qt({inputs:{x:m},backend:e,attrs:{shape:y}})}return u.forEach(y=>e.disposeIntermediateTensorInfo(y)),m}},vq={kernelName:d.RaggedGather,backendName:"webgl",kernelFunc:function yq(t){const{inputs:n,backend:e,attrs:r}=t,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=n,{outputRaggedRank:a}=r,u=s.map(D=>e.readSync(D.dataId)),c=s.map(D=>D.shape),l=e.readSync(o.dataId),h=e.readSync(i.dataId),[f,m,y]=XW(u,c,l,o.shape,o.dtype,h,i.shape,a),w=f.map(D=>e.makeTensorInfo([D.length],"int32",D)),E=e.makeTensorInfo(y,o.dtype,m);return w.concat([E])}},bq={kernelName:d.RaggedTensorToTensor,backendName:"webgl",kernelFunc:function xq(t){const{inputs:n,backend:e,attrs:r}=t,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=n,{rowPartitionTypes:u}=r,c=e.readSync(s.dataId),l=e.readSync(o.dataId),h=e.readSync(i.dataId),f=a.map(E=>e.readSync(E.dataId)),m=a.map(E=>E.shape),[y,w]=qW(c,s.shape,l,o.shape,o.dtype,h,i.shape,f,m,u);return e.makeTensorInfo(y,o.dtype,w)}},D_=t=>{const{backend:n,attrs:e}=t,{start:r,stop:s,step:o,dtype:i}=e,a=YW(r,s,o,i);return n.makeTensorInfo([a.length],i,a)},wq={kernelName:d.Range,backendName:"webgl",kernelFunc:D_},Cq=vr({opSnippet:"return 1.0 / x;"}),Sq={kernelName:d.Reciprocal,backendName:"webgl",kernelFunc:Cq},_q=vr({opSnippet:Li+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Iq={kernelName:d.Relu,backendName:"webgl",kernelFunc:_q},Tq=vr({opSnippet:Li+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Nq={kernelName:d.Relu6,backendName:"webgl",kernelFunc:Tq};class kq{constructor(n,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,u,c]=n;this.outputShape=[i,e,r,c];const l=[s&&e>1?a-1:a,s&&r>1?u-1:u],h=[s&&e>1?e-1:e,s&&r>1?r-1:r];let f;f=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/h[0]},\n          ${l[1]/h[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${f};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class Aq{constructor(n,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,u,c]=n;this.outputShape=[i,e,r,c];const l=[s&&e>1?a-1:a,s&&r>1?u-1:u],h=[s&&e>1?e-1:e,s&&r>1?r-1:r];let f;f=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/h[0]},\n          ${l[1]/h[1]},\n          ${l[1]/h[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,\n                                     ${u}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${f};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const Oq={kernelName:d.ResizeBilinear,backendName:"webgl",kernelFunc:function Rq(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r,[u,c]=a,l=(0,d.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Aq(s.shape,u,c,o,i):new kq(s.shape,u,c,o,i);return e.runWebGLProgram(l,[s],"float32")}};class Mq{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=n,u=[r&&i>1?s-1:s,r&&a>1?o-1:o],c=[r&&i>1?i-1:i,r&&a>1?a-1:a],l=u[0]/c[0],h=u[1]/c[1],f=1/l,m=1/h,y=2*Math.ceil(f)+2,w=2*Math.ceil(m)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${h});\n\n        const float invHeightScale = float(${f});\n        const float invWidthScale = float(${m});\n\n        const int winHeight = int(${y});\n        const int winWidth = int(${w});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Fq={kernelName:d.ResizeBilinearGrad,backendName:"webgl",kernelFunc:function $q(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r,a=new Mq(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class Pq{constructor(n,e,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,u,c]=n;this.outputShape=[i,e,r,c];const l=[s&&e>1?a-1:a,s&&r>1?u-1:u],h=[s&&e>1?e-1:e,s&&r>1?r-1:r];let m;m=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/h[0]},\n          ${l[1]/h[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${m};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class Lq{constructor(n,e,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,u,c]=n;this.outputShape=[i,e,r,c];const l=[s&&e>1?a-1:a,s&&r>1?u-1:u],h=[s&&e>1?e-1:e,s&&r>1?r-1:r];let m;m=o?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/h[0]},\n          ${l[1]/h[1]},\n          ${l[1]/h[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,\n                                     ${u}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${m};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const Vq={kernelName:d.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:function Bq(t){const{inputs:n,backend:e,attrs:r}=t,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r,[u,c]=a,l=(0,d.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Lq(s.shape,u,c,o,i):new Pq(s.shape,u,c,o,i);return e.runWebGLProgram(l,[s],s.dtype)}};class Uq{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,o]=e,[,i,a]=n,u=[r&&i>1?s-1:s,r&&a>1?o-1:o],c=[r&&i>1?i-1:i,r&&a>1?a-1:a],l=u[0]/c[0],h=u[1]/c[1],f=1/l,m=1/h,y=2*Math.ceil(f)+2,w=2*Math.ceil(m)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${h});\n\n        const float invHeightScale = float(${f});\n        const float invWidthScale = float(${m});\n\n        const int winHeight = int(${y});\n        const int winWidth = int(${w});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${u[0]}) *\n                (float(dyR) / float(${c[0]}));\n\n            float sourceFracCol =\n                float(${u[1]}) *\n                  (float(dyC) / float(${c[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const zq={kernelName:d.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:function Wq(t){const{inputs:n,backend:e,attrs:r}=t,{images:s,dy:o}=n,{alignCorners:i}=r,a=new Uq(o.shape,s.shape,i);return e.runWebGLProgram(a,[o],o.dtype)}};class Hq{constructor(n,e){this.variableNames=["x"];const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=n,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${n[0]} - coord - 1));\n        }\n      `);const o=n.map((a,u)=>(a=>-1!==e.indexOf(a)&&1!==n[a]?`${n[a]} - coords[${a}] - 1`:`coords[${a}]`)(u)).join(","),i=Hr(r);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class jq{constructor(n,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=n;const s=No("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=Hr(r);function f(y){const w=n.map((O,W)=>function m(y,w){return-1!==e.indexOf(y)&&1!==n[y]?`${n[y]} - ${w[y]} - 1`:`${w[y]}`}(W,y));return`getChannel(getX(${w.join(",")}), vec2(${w.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${n[0]} - rc - 1),\n            ${n[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${n[0]} - (rc  + 1) - 1),\n                ${n[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function u(y){return f(y)}(s.slice())};\n          if(${o}){\n            result.g = ${function c(y){return y[r-1]="("+y[r-1]+" + 1)",f(y)}(s.slice())};\n          }\n          if(${i}) {\n            result.b = ${function l(y){return y[r-2]="("+y[r-2]+" + 1)",f(y)}(s.slice())};\n            if(${o}) {\n              result.a = ${function h(y){return y[r-1]="("+y[r-1]+" + 1)",y[r-2]="("+y[r-2]+" + 1)",f(y)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const Kq={kernelName:d.Reverse,backendName:"webgl",kernelFunc:function Gq(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{dims:o}=r,i=s.shape.length,a=d.util.parseAxisParam(o,s.shape);if(0===i)return mi({inputs:{x:s},backend:e});const u=(0,d.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jq(s.shape,a):new Hq(s.shape,a);return e.runWebGLProgram(u,[s],s.dtype)}};class Xq{constructor(n,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=n[1],s=n[2];this.outputShape=n;let o="";o="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const qq={kernelName:d.RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{const{image:r}=t,{radians:s,fillValue:o,center:i}=n,a=e,u=new Xq(r.shape,o),[c,l]=d.backend_util.getImageCenter(i,r.shape[1],r.shape[2]),h=[[c,l,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(u,[r],r.dtype,h)}},Yq=vr({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),Zq={kernelName:d.Round,backendName:"webgl",kernelFunc:Yq},Qq=vr({opSnippet:"return inversesqrt(x);",cpuKernelImpl:ZW}),Jq={kernelName:d.Rsqrt,backendName:"webgl",kernelFunc:Qq};class T_{constructor(n,e,r,s,o,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const u=Hr(o.length),c=Hr(i.length);let l="";1===r?l="i":2===r&&(l="i, j");let f="";1===s?f="i":2===s&&(f="i, coords[1]"),this.userCode=`\n        ${u} strides = ${u}(${o});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${n}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${l}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${f});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const tY={kernelName:d.ScatterNd,backendName:"webgl",kernelFunc:function eY(t){const{inputs:n,backend:e,attrs:r}=t,{indices:s,updates:o}=n,{shape:i}=r,{sliceRank:a,numUpdates:u,sliceSize:c,strides:l,outputSize:h}=d.backend_util.calculateShapes(o,s,i),f=[h/c,c];if(0===h)return e.makeTensorInfo(i,s.dtype);const m=qt({inputs:{x:s},backend:e,attrs:{shape:[u,a]}}),y=qt({inputs:{x:o},backend:e,attrs:{shape:[u,c]}}),w=e.makeTensorInfo([],"float32",new Float32Array([0])),E=new T_(u,a,m.shape.length,y.shape.length,l,f),D=e.runWebGLProgram(E,[y,m,w],y.dtype),O=qt({inputs:{x:D},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(D),e.disposeIntermediateTensorInfo(w),O}};class nY{constructor(n,e,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[n,r];const i=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=2===(0,d.env)().getNumber("WEBGL_VERSION")?"while (left < right) {":i;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===s?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const sY={kernelName:d.SearchSorted,backendName:"webgl",kernelFunc:function rY(t){const{inputs:n,backend:e,attrs:r}=t,{sortedSequence:s,values:o}=n,{side:i}=r,a=new nY(s.shape[0],s.shape[1],o.shape[1],i);return e.runWebGLProgram(a,[s,o],"int32",[[s.shape[1]]])}};class oY{constructor(n,e,r){let s,o;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)o="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],c=[];for(let l=0;l<e.length;l++)c.push(`${a[l]}`),l<n&&u.push(`${a[l]}`);s=u.join(),o=c.join()}const i=Hr(r);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}const aY={kernelName:d.Select,backendName:"webgl",kernelFunc:function iY(t){const{inputs:n,backend:e}=t,{condition:r,t:s,e:o}=n,i=new oY(r.shape.length,s.shape,s.shape.length);return e.runWebGLProgram(i,[r,s,o],(0,d.upcastType)(s.dtype,o.dtype))}},cY=vr({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${d.backend_util.SELU_SCALEALPHA};\n  float scale = ${d.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),lY={kernelName:d.Selu,backendName:"webgl",kernelFunc:cY},hY=vr({opSnippet:Wd+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:JW}),fY={kernelName:d.Sigmoid,backendName:"webgl",kernelFunc:hY},pY=vr({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),mY={kernelName:d.Sign,backendName:"webgl",kernelFunc:pY},yY=vr({opSnippet:Wd+"\n  return sin(x);\n"}),vY={kernelName:d.Sin,backendName:"webgl",kernelFunc:yY},xY=vr({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),bY={kernelName:d.Sinh,backendName:"webgl",kernelFunc:xY},wY=vr({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),CY={kernelName:d.Softplus,backendName:"webgl",kernelFunc:wY},EY={kernelName:d.SpaceToBatchND,backendName:"webgl",kernelFunc:t=>{const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{blockShape:o,paddings:i}=r;d.util.assert(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((D,O)=>D*O),u=[[0,0]];u.push(...i);for(let D=1+o.length;D<s.shape.length;++D)u.push([0,0]);const c=[],l=I_({inputs:{x:s},backend:e,attrs:{paddings:u,constantValue:0}}),h=d.backend_util.getReshaped(l.shape,o,a,!1),f=d.backend_util.getPermuted(h.length,o.length,!1),m=d.backend_util.getReshapedPermuted(l.shape,o,a,!1),y=qt({inputs:{x:l},backend:e,attrs:{shape:h}}),w=ko({inputs:{x:y},backend:e,attrs:{perm:f}}),E=qt({inputs:{x:w},backend:e,attrs:{shape:m}});return c.push(l),c.push(y),c.push(w),c.forEach(D=>e.disposeIntermediateTensorInfo(D)),E}},IY={kernelName:d.SparseFillEmptyRows,backendName:"webgl",kernelFunc:function _Y(t){const{inputs:n,backend:e}=t,{indices:r,values:s,denseShape:o,defaultValue:i}=n;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=e.readSync(r.dataId),u=e.readSync(s.dataId),c=e.readSync(o.dataId),l=e.readSync(i.dataId)[0],[h,f,m,y,w]=tz(a,r.shape,r.dtype,u,s.dtype,c,l);return[e.makeTensorInfo(f,r.dtype,h),e.makeTensorInfo([f[0]],s.dtype,m),e.makeTensorInfo([y.length],"bool",new Uint8Array(y.map(E=>Number(E)))),e.makeTensorInfo([w.length],r.dtype,new Int32Array(w))]}},TY={kernelName:d.SparseReshape,backendName:"webgl",kernelFunc:function DY(t){const{inputs:n,backend:e}=t,{inputIndices:r,inputShape:s,newShape:o}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(e.readSync(s.dataId)),a=e.readSync(r.dataId),u=Array.from(e.readSync(o.dataId)),[c,l,h]=nz(a,r.shape,r.dtype,i,u);return[e.makeTensorInfo(l,r.dtype,c),e.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}},kY={kernelName:d.SparseSegmentMean,backendName:"webgl",kernelFunc:function NY(t){const{inputs:n,backend:e}=t,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const i=e.readSync(r.dataId),a=e.readSync(s.dataId),u=e.readSync(o.dataId),[c,l]=RE(i,r.shape,r.dtype,a,u,!0);return e.makeTensorInfo(l,r.dtype,c)}},RY={kernelName:d.SparseSegmentSum,backendName:"webgl",kernelFunc:function AY(t){const{inputs:n,backend:e}=t,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const i=e.readSync(r.dataId),a=e.readSync(s.dataId),u=e.readSync(o.dataId),[c,l]=RE(i,r.shape,r.dtype,a,u);return e.makeTensorInfo(l,r.dtype,c)}},MY={kernelName:d.SparseToDense,backendName:"webgl",kernelFunc:function OY(t){const{inputs:n,backend:e,attrs:r}=t,{sparseIndices:s,sparseValues:o,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:u,numUpdates:c,sliceSize:l,strides:h,outputSize:f}=d.backend_util.calculateShapes(o,s,a);if("string"===o.dtype){const D=e.bufferSync(s),O=e.bufferSync(o),W=d.util.decodeString(e.readSync(i.dataId)[0]),q=QW(D,O,a,f,l,c,u,h,W,!1);return e.makeTensorInfo(a,q.dtype,q.values)}const y=new T_(c,u,s.shape.length,o.shape.length,h,[f,1],!1),w=e.runWebGLProgram(y,[o,s,i],o.dtype),E=qt({inputs:{x:w},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(w),E}},FY={kernelName:d.SplitV,backendName:"webgl",kernelFunc:function $Y(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{numOrSizeSplits:o,axis:i}=r,a=d.util.parseAxisParam(i,s.shape)[0],u=d.backend_util.prepareSplitSize(s,o,a),l=new Array(s.shape.length).fill(0),h=s.shape.slice();return u.map(f=>{const m=[...h];m[a]=f;const y=zd({inputs:{x:s},backend:e,attrs:{begin:l,size:m}});return l[a]+=f,y})}},N_="return sqrt(x);",PY=vr({opSnippet:N_,packedOpSnippet:N_,cpuKernelImpl:rz}),LY={kernelName:d.Sqrt,backendName:"webgl",kernelFunc:PY},BY=vr({opSnippet:"return x * x;"}),VY={kernelName:d.Square,backendName:"webgl",kernelFunc:BY},k_="return (a - b) * (a - b);",UY=ro({opSnippet:k_,packedOpSnippet:k_}),WY={kernelName:d.SquaredDifference,backendName:"webgl",kernelFunc:UY},HY={kernelName:d.Step,backendName:"webgl",kernelFunc:function zY({inputs:t,attrs:n,backend:e}){const{x:r}=t,o=new zu(r.shape,Li+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `);return e.runWebGLProgram(o,[r],r.dtype)}};class jY{constructor(n,e,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=Hr(r.length),i=Hr(r.length);let a="";if(1===s)a="coords * strides + begin";else{let u=0;a=r.map((c,l)=>(u++,1===r.length?`coords * strides[${l}] + begin[${l}]`:`coords[${u-1}] * strides[${l}] + begin[${l}]`)).join(",")}this.userCode=`\n      ${o} begin = ${o}(${n});\n      ${o} strides = ${o}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const KY={kernelName:d.StridedSlice,backendName:"webgl",kernelFunc:function GY(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{begin:o,end:i,strides:a,beginMask:u,endMask:c,ellipsisMask:l,newAxisMask:h,shrinkAxisMask:f}=r,{finalShapeSparse:m,finalShape:y,isIdentity:w,sliceDim0:E,isSimpleSlice:D,begin:O,end:W,strides:q}=d.slice_util.sliceInfo(s.shape,o,i,a,u,c,l,h,f);let re;if(w)re=qt({inputs:{x:s},backend:e,attrs:{shape:y}});else if(E||D){d.util.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const Ae=d.slice_util.computeOutShape(O,W,q),Be=zd({inputs:{x:s},backend:e,attrs:{begin:O,size:Ae}});re=qt({inputs:{x:Be},backend:e,attrs:{shape:y}}),e.disposeIntermediateTensorInfo(Be)}else if(e.shouldExecuteOnCPU([s])){const Be=e.readSync(s.dataId),Ke=(0,d.buffer)(s.shape,s.dtype,Be),Ge=sz(m,Ke,q,O);re=e.makeTensorInfo(y,s.dtype,Ge.values)}else{const Be=new jY(O,q,m);re=e.runWebGLProgram(Be,[s],s.dtype)}const pe=qt({inputs:{x:re},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(re),pe}},qY={kernelName:d.StringNGrams,backendName:"webgl",kernelFunc:function XY(t){const{inputs:n,backend:e,attrs:r}=t,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:c}=r,{data:l,dataSplits:h}=n,f=e.readSync(l.dataId),m=e.readSync(h.dataId),[y,w]=oz(f,m,s,o,i,a,u,c);return[e.makeTensorInfo([y.length],"string",y),e.makeTensorInfo(h.shape,"int32",w)]}},ZY={kernelName:d.StringSplit,backendName:"webgl",kernelFunc:function YY(t){const{inputs:n,backend:e,attrs:r}=t,{skipEmpty:s}=r,{input:o,delimiter:i}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=e.readSync(o.dataId),u=e.readSync(i.dataId)[0],[c,l,h]=iz(a,u,s),f=l.length;return[e.makeTensorInfo([f,2],"int32",c),e.makeTensorInfo([f],"string",l),e.makeTensorInfo([2],"int32",new Int32Array(h))]}},JY={kernelName:d.StringToHashBucketFast,backendName:"webgl",kernelFunc:function QY(t){const{inputs:n,backend:e,attrs:r}=t,{numBuckets:s}=r,{input:o}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=e.readSync(o.dataId),a=az(i,s);return e.makeTensorInfo(o.shape,"int32",a)}},eZ=vr({opSnippet:"return tan(x);"}),tZ={kernelName:d.Tan,backendName:"webgl",kernelFunc:eZ},nZ=vr({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),rZ={kernelName:d.Tanh,backendName:"webgl",kernelFunc:nZ};class sZ{constructor(n,e){this.variableNames=["A"];const r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[i]*e[i];this.outputShape=r,this.rank=r.length;const s=Hr(this.rank),o=function oZ(t){const n=t.length;if(n>5)throw Error(`Tile for rank ${n} is not yet supported`);if(1===n)return`imod(resRC, ${t[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<t.length;s++)r.push(`imod(${e[s]}, ${t[s]})`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function A_(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{reps:o}=r;if("string"===s.dtype||s.shape.length>5){const u=e.readSync(s.dataId),c="string"===s.dtype?u.map(f=>d.util.decodeString(f)):u,l=(0,d.buffer)(s.shape,s.dtype,c),h=cz(l,o);return e.makeTensorInfo(h.shape,h.dtype,h.values)}const i=new sZ(s.shape,o);return e.runWebGLProgram(i,[s],s.dtype)}const iZ={kernelName:d.Tile,backendName:"webgl",kernelFunc:A_};class aZ{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=n,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class uZ{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=n,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function ul(t,n){null!==n&&t.disposeIntermediateTensorInfo(n)}function R_(t){let n=1;for(;n<t;)n*=2;return n}const lZ={kernelName:d.TopK,backendName:"webgl",kernelFunc:function cZ(t){const{inputs:n,backend:e,attrs:r}=t,{x:s}=n,{k:o,sorted:i}=r,a=(0,d.env)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=(0,d.env)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,l=c[c.length-1];if(e.shouldExecuteOnCPU([s])||l<a||o>u){const Ge=e.readSync(s.dataId),[ft,yt]=lz(Ge,c,s.dtype,o,i);return[e.makeTensorInfo(ft.shape,ft.dtype,ft.values),e.makeTensorInfo(yt.shape,yt.dtype,yt.values)]}if(0===o)return c[c.length-1]=0,[e.makeTensorInfo(c,s.dtype,[]),e.makeTensorInfo(c,"int32",[])];if(1===l)return[s,Mf({attrs:{shape:c,dtype:"int32",value:0},backend:e})];const h=e.texData.get(s.dataId),f=null!==h&&h.isPacked,m=f?e.unpackTensor(s):s,w=d.util.sizeFromShape(c)/l,E=qt({inputs:{x:m},attrs:{shape:[w,l]},backend:e});f&&ul(e,m);const D=R_(o),O=R_(l);let W=null;const q=()=>null===W?[E,E]:[E,W],re=(Ge,ft,yt)=>{const pt=q(),wt=new aZ(yt),Et=W;W=e.runWebGLProgram(wt,pt,"int32",[[l],[null===W?1:0],[Number.NEGATIVE_INFINITY],[Ge],[ft]]),ul(e,Et)};for(let Ge=1;Ge<D;Ge*=2){const ft=2*Ge;for(let yt=Ge;yt>=1;yt/=2)re(ft,yt,[w,O])}for(let Ge=O;Ge>D;Ge/=2){const ft=q(),yt=new uZ([w,Ge/2]),vt=W;W=e.runWebGLProgram(yt,ft,"int32",[[l],[null===W?1:0],[D]]),ul(e,vt);const xt=D/2,Et=2*xt;for(let mt=xt;mt>=1;mt/=2)re(Et,mt,W.shape)}let pe=W;W=zd({inputs:{x:W},backend:e,attrs:{begin:0,size:[w,o]}}),ul(e,pe);let Ae=x_({inputs:{x:E,indices:W},backend:e,attrs:{axis:1,batchDims:1}});ul(e,E);const Be=c.slice(0,-1);Be.push(o),pe=W,W=qt({inputs:{x:W},attrs:{shape:Be},backend:e}),ul(e,pe);const Ke=Ae;return Ae=qt({inputs:{x:Ae},attrs:{shape:Be},backend:e}),ul(e,Ke),[Ae,W]}};class dZ{constructor(n,e,r,s,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===r?1:2;let u;switch(s){case"constant":default:u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${u} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${u} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${u} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${n} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${n}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const fZ={kernelName:d.Transform,backendName:"webgl",kernelFunc:function hZ(t){const{inputs:n,backend:e,attrs:r}=t,{image:s,transforms:o}=n,{interpolation:i,fillMode:a,fillValue:u,outputShape:c}=r,[l,h,f,m]=s.shape,[y,w]=c??[h,f],D=new dZ(h,f,i,a,u,[l,y,w,m]);return e.runWebGLProgram(D,[s,o],"float32")}},mZ={kernelName:d.Unique,backendName:"webgl",kernelFunc:function pZ(t){const{inputs:n,attrs:e,backend:r}=t,{axis:s}=e,{x:o}=n;If(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:u,indices:c}=dz(i,s,o.shape,o.dtype);return[r.makeTensorInfo(u,o.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},yZ={kernelName:d.Unpack,backendName:"webgl",kernelFunc:function gZ(t){const{inputs:n,backend:e,attrs:r}=t,{value:s}=n;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,u=s.shape[o],c=new Array(a-1);let l=0;for(let w=0;w<a;w++)w!==o&&(c[l++]=i.shape[w]);const h=[],f=new Array(a).fill(0),m=i.shape.slice();m[o]=1;const y=new Array(u);for(let w=0;w<y.length;w++){f[o]=w;const E=zd({inputs:{x:i},backend:e,attrs:{begin:f,size:m}}),D=qt({inputs:{x:E},backend:e,attrs:{shape:c}});y[w]=D,h.push(E)}return h.forEach(w=>e.disposeIntermediateTensorInfo(w)),y}};class vZ{constructor(n,e){this.variableNames=["x","segmentIds"];const r=n.windowSize,s=n.batchSize,o=n.inSize,i=n.numSegments,a=i*Math.ceil(o/r);this.outputShape=[s,a];const l=4*Math.floor(r/4),h=r%4,f="\n        sumValue += dot(values, segFilter);\n    ";let m="";o%r>0&&(m=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let y="";o%r>0&&(y=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${m}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${y}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${f}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===h}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${f}\n        } else if (${2===h}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${f}\n        } else if (${3===h}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${f}\n        }\n        setOutput(sumValue);\n      }\n    `}}const bZ={kernelName:d.UnsortedSegmentSum,backendName:"webgl",kernelFunc:function xZ(t){const{inputs:n,backend:e,attrs:r}=t,{x:s,segmentIds:o}=n,{numSegments:i}=r,a=s.shape.length,u=[];let c=0;const l=d.backend_util.getAxesPermutation([c],a);let h=s;null!=l&&(h=ko({inputs:{x:s},backend:e,attrs:{perm:l}}),u.push(h),c=d.backend_util.getInnerMostAxes(1,a)[0]);const f=d.backend_util.segment_util.computeOutShape(h.shape,c,i),m=d.util.sizeFromShape([h.shape[c]]),y=qt({inputs:{x:h},backend:e,attrs:{shape:[-1,m]}});u.push(y);const w=(0,d.sumOutType)(s.dtype),E=(q,re,pe,Ae,Be)=>{const Ke=q.shape[0],Ge=q.shape[1],ft=d.backend_util.segment_util.segOpComputeOptimalWindowSize(Ge,Be),pt=new vZ({windowSize:ft,inSize:Ge,batchSize:Ke,numSegments:Be},re),wt=e.compileAndRun(pt,[q,pe],Ae);if(u.push(wt),wt.shape[1]===Be)return wt;const vt=D_({backend:e,attrs:{start:0,stop:Be,step:1,dtype:"float32"}}),xt=A_({inputs:{x:vt},backend:e,attrs:{reps:[Ge/ft]}});return u.push(vt),u.push(xt),E(wt,re,xt,Ae,Be)},O=qt({inputs:{x:E(y,"unsortedSegmentSum",o,w,i)},backend:e,attrs:{shape:f}});let W=O;if(null!=l){u.push(O);const q=d.backend_util.getUndoAxesPermutation(l);W=ko({inputs:{x:W},backend:e,attrs:{perm:q}})}return u.forEach(q=>e.disposeIntermediateTensorInfo(q)),W}},wZ=[sH,iH,cH,hH,pH,yH,xH,wH,_H,DH,kH,OH,FH,VH,zH,jH,KH,ZH,JH,tj,oj,hj,pj,gj,wj,Sj,Dj,Uz,kj,$j,Bj,jj,Kj,qj,Zj,Jj,nG,sG,aG,cG,dG,fG,gG,vG,CG,EG,DG,kG,RG,MG,LG,VG,zG,jG,GG,XG,YG,QG,eK,nK,sK,aK,lK,hK,mK,vK,bK,CK,Vz,EK,Oj,IK,TK,kK,zz,RK,MK,FK,BK,WK,HK,GK,XK,QK,tX,rX,aX,cX,dX,mX,yX,xX,wX,SX,DX,AX,$X,UX,Gz,jX,XX,ZX,eq,yj,rq,oq,aq,lq,pq,jz,gq,vq,bq,wq,vj,PX,Sq,Iq,Nq,Xz,Oq,Fq,Vq,zq,Kq,qq,Zq,Jq,tY,sY,aY,lY,fY,mY,vY,bY,lj,BX,CY,EY,IY,TY,kY,RY,MY,FY,LY,VY,WY,HY,KY,qY,ZY,JY,LX,tH,tZ,rZ,iZ,lZ,fZ,nH,mZ,yZ,bZ,sq];for(const t of wZ)(0,d.registerKernel)(t);var CZ=M(5103);let O_=(()=>{class t{static getColorViaIndex(e){return this.availableColors[e%this.availableColors.length]}}return t.availableColors=["#03045E","#00B4D8","#CAF0F8","#90E0EF"],t})();const SZ=["video"],EZ=["canvasElement"];function _Z(t,n){1&t&&(yr(0,"div",9),li(1,"div",10),Mr())}const IZ=function(){return["/home"]};let DZ=(()=>{class t{constructor(e){this.elRef=e,this.classes=[],this.viewModel=new p$,this.model=null,this.devicesList=null,this.canvasRef=null,this.video=null,this.graphModel=null}ngOnInit(){var e=this;return(0,bs.Z)(function*(){yield e.loadModel(),yield e.startWebCam(),e.startDetectThings()})()}get cameraWidth(){return this.viewModel.cameraWidth}get cameraHeight(){return this.viewModel.cameraHeight}get isVertical(){return window.innerHeight>window.innerWidth}loadModel(){var e=this;return(0,bs.Z)(function*(){e.model?.dispose(),yield CZ.load({base:"lite_mobilenet_v2"}).then(r=>{e.model=r,e.startWebCam()})})()}startWebCam(){var e=this;return(0,bs.Z)(function*(){e.devicesList=yield navigator.mediaDevices.enumerateDevices(),e.video&&(e.videoInput=e.video.nativeElement),yield navigator.mediaDevices.getUserMedia({video:{facingMode:"user"},audio:!1}).then(r=>{e.videoInput.srcObject=r;let{width:s,height:o}=r.getTracks()[0].getSettings();e.viewModel.cameraWidth=s??1,e.viewModel.cameraHeight=o??1}).catch(r=>console.log(r)),e.viewModel.isCameraLoaded=!0})()}startDetectThings(){var e=this;return(0,bs.Z)(function*(){e.canvasRef?.nativeElement.setAttribute("width",e.viewModel.cameraWidth.toString()),e.canvasRef?.nativeElement.setAttribute("height",e.viewModel.cameraHeight.toString());let r=e.canvasRef?.nativeElement.getContext("2d");setInterval((0,bs.Z)(function*(){r&&e.detectThings(r)}),30)})()}detectThings(e){var r=this;return(0,bs.Z)(function*(){console.log(r.canvasRef?.nativeElement.width+" "+r.canvasRef?.nativeElement.height),r.classes=[],e.clearRect(0,0,r.canvasRef?.nativeElement.width??0,r.canvasRef?.nativeElement.height??0);let s=[];r.video?.nativeElement&&(yield r.model?.detect(r.video?.nativeElement).then(o=>{s=o})),r.classes=r.classes.concat(s.map(o=>r.classes.includes(o.class)?null:o.class).filter(o=>null!=o)),s.forEach(o=>{e.beginPath(),e.fillStyle=O_.getColorViaIndex(r.classes.indexOf(o.class)),e.lineWidth=4,e.strokeStyle=O_.getColorViaIndex(r.classes.indexOf(o.class)),e.roundRect(...o.bbox,5),e.font="25px Chakra Petch",e.fillText(o.class,o.bbox[0]+30,o.bbox[1]+30),e.stroke(),e.closePath()})})()}}return t.\u0275fac=function(e){return new(e||t)(Rn(eu))},t.\u0275cmp=ns({type:t,selectors:[["app-object-detector"]],viewQuery:function(e,r){if(1&e&&(Kh(SZ,7),Kh(EZ,7)),2&e){let s;ld(s=dd())&&(r.video=s.first),ld(s=dd())&&(r.canvasRef=s.first)}},decls:10,vars:5,consts:[[1,"camera-displayer"],["class","loader-container",4,"ngIf"],[1,"back-container",3,"routerLink"],["id","webcam","autoplay","","muted","","playsinline","",1,"video-placeholder",3,"width","height"],["video",""],[1,"canvas-container"],["canvas",""],["id","canvas",1,"canvas-main"],["canvasElement",""],[1,"loader-container"],[1,"loader"]],template:function(e,r){1&e&&(yr(0,"div",0),Wc(1,_Z,2,0,"div",1),yr(2,"div",2),Ps(3,"Back"),Mr(),li(4,"video",3,4),yr(6,"div",5,6),li(8,"canvas",7,8),Mr()()),2&e&&(Eo(1),$i("ngIf",!r.viewModel.isCameraLoaded),Eo(1),$i("routerLink",D0(4,IZ)),Eo(2),$i("width",r.cameraWidth)("height",r.cameraHeight))},dependencies:[Jh,Ed],styles:[".video-placeholder[_ngcontent-%COMP%]{background-color:#000;position:relative;top:0}.devices[_ngcontent-%COMP%]{color:#fff}.camera-displayer[_ngcontent-%COMP%]{display:flex;flex-direction:row;justify-content:center}.canvas-container[_ngcontent-%COMP%]{position:absolute;top:0}.loader-container[_ngcontent-%COMP%]{position:absolute;top:calc(50vh - 120px);z-index:5}.back-container[_ngcontent-%COMP%]{color:#f5f5f5;font-family:Chakra Petch,sans-serif;font-size:x-large;text-align:center;padding-top:10px;padding-bottom:10px;background:rgba(0,0,0,.434);border-radius:5px;position:absolute;bottom:10vh;z-index:5;margin-left:auto;margin-right:auto;width:90vw;max-width:300px}.loader[_ngcontent-%COMP%]{border:16px solid #2828284c;border-top:16px solid #212121;border-radius:50%;width:120px;height:120px;animation:_ngcontent-%COMP%_spin 2s linear infinite}@keyframes _ngcontent-%COMP%_spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}"]}),t})(),TZ=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=Hs({type:t,bootstrap:[lM]}),t.\u0275inj=Ws({imports:[QR,cM,a3.forRoot([{path:"introduction",component:pM},{path:"face-detector",component:f$},{path:"object-detector",component:DZ},{path:"home",component:xM},{path:"",redirectTo:"/home",pathMatch:"full"}],{})]}),t})();ZR().bootstrapModule(TZ).catch(t=>console.error(t))},5103:function(gt,Xe,M){var _e=M(7156).default;!function(we,te,Q){"use strict";const F={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class j{constructor(me,Y){this.modelPath=Y||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(me)}/model.json`}getPrefix(me){return"lite_mobilenet_v2"===me?`ssd${me}`:`ssd_${me}`}load(){var me=this;return _e(function*(){me.model=yield te.loadGraphModel(me.modelPath);const Y=Q.zeros([1,300,300,3],"int32"),le=yield me.model.executeAsync(Y);yield Promise.all(le.map(ee=>ee.data())),le.map(ee=>ee.dispose()),Y.dispose()})()}infer(me,Y,le){var ee=this;return _e(function*(){const A=Q.tidy(()=>(me instanceof Q.Tensor||(me=Q.browser.fromPixels(me)),Q.expandDims(me))),de=A.shape[1],Pe=A.shape[2],xe=yield ee.model.executeAsync(A),Ze=xe[0].dataSync(),ot=xe[1].dataSync();A.dispose(),Q.dispose(xe);const[St,Vt]=ee.calculateMaxScores(Ze,xe[0].shape[1],xe[0].shape[2]),ke=Q.getBackend();"webgl"===Q.getBackend()&&Q.setBackend("cpu");const Oe=Q.tidy(()=>{const $e=Q.tensor2d(ot,[xe[1].shape[1],xe[1].shape[3]]);return Q.image.nonMaxSuppression($e,St,Y,le,le)}),It=Oe.dataSync();return Oe.dispose(),ke!==Q.getBackend()&&Q.setBackend(ke),ee.buildDetectedObjects(Pe,de,ot,St,It,Vt)})()}buildDetectedObjects(me,Y,le,ee,A,de){const Pe=A.length,xe=[];for(let Ze=0;Ze<Pe;Ze++){const ot=[];for(let It=0;It<4;It++)ot[It]=le[4*A[Ze]+It];const St=ot[0]*Y,Vt=ot[1]*me,ke=ot[2]*Y,Oe=ot[3]*me;ot[0]=Vt,ot[1]=St,ot[2]=Oe-Vt,ot[3]=ke-St,xe.push({bbox:ot,class:F[de[A[Ze]]+1].displayName,score:ee[A[Ze]]})}return xe}calculateMaxScores(me,Y,le){const ee=[],A=[];for(let de=0;de<Y;de++){let Pe=Number.MIN_VALUE,xe=-1;for(let Ze=0;Ze<le;Ze++)me[de*le+Ze]>Pe&&(Pe=me[de*le+Ze],xe=Ze);ee[de]=Pe,A[de]=xe}return[ee,A]}detect(me,Y=20,le=.5){var ee=this;return _e(function*(){return ee.infer(me,Y,le)})()}dispose(){null!=this.model&&this.model.dispose()}}we.ObjectDetection=j,we.load=_e(function*(Ie={}){if(null==Q)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const me=Ie.base||"lite_mobilenet_v2",Y=Ie.modelUrl;if(-1===["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(me))throw new Error(`ObjectDetection constructed with invalid base model ${me}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const le=new j(me,Y);return yield le.load(),le}),we.version="2.2.2",Object.defineProperty(we,"__esModule",{value:!0})}(Xe,M(4554),M(1726))},4554:(gt,Xe,M)=>{"use strict";M.r(Xe),M.d(Xe,{GraphModel:()=>je,deregisterOp:()=>ce,loadGraphModel:()=>at,loadGraphModelSync:()=>Lt,registerOp:()=>se,version_converter:()=>Un});var _e={};M.r(_e),M.d(_e,{json:()=>Zt});var we={};M.r(we),M.d(we,{json:()=>yn});var te={};M.r(te),M.d(te,{json:()=>Mn});var Q={};M.r(Q),M.d(Q,{json:()=>cr});var F={};M.r(F),M.d(F,{json:()=>kn});var j={};M.r(j),M.d(j,{json:()=>dn});var Ie={};M.r(Ie),M.d(Ie,{json:()=>un});var me={};M.r(me),M.d(me,{json:()=>Fn});var Y={};M.r(Y),M.d(Y,{json:()=>ds});var le={};M.r(le),M.d(le,{json:()=>Zn});var ee={};M.r(ee),M.d(ee,{json:()=>Ne});var A={};M.r(A),M.d(A,{json:()=>rt});var de={};M.r(de),M.d(de,{json:()=>lt});var Pe={};M.r(Pe),M.d(Pe,{json:()=>Nt});var xe={};M.r(xe),M.d(xe,{json:()=>wn});var Ze={};M.r(Ze),M.d(Ze,{json:()=>zn});var ot={};M.r(ot),M.d(ot,{json:()=>Jn});var St={};M.r(St),M.d(St,{json:()=>wr});var Vt={};M.r(Vt),M.d(Vt,{json:()=>$r});var ke={};M.r(ke),M.d(ke,{OP_SCOPE_SUFFIX:()=>Re.zvA,abs:()=>Re.WnP,acos:()=>Re.Khb,acosh:()=>Re.__u,add:()=>Re.IHx,addN:()=>Re.QBD,all:()=>Re.$6P,any:()=>Re.YjB,argMax:()=>Re.NqF,argMin:()=>Re.vHJ,asin:()=>Re.ZRM,asinh:()=>Re.VfV,atan:()=>Re.z4N,atan2:()=>Re.fvJ,atanh:()=>Re.C80,avgPool:()=>Re.wS1,avgPool3d:()=>Re.uR5,basicLSTMCell:()=>Re.zEQ,batchNorm:()=>Re.tgs,batchNorm2d:()=>Re.Dxk,batchNorm3d:()=>Re.JY5,batchNorm4d:()=>Re.p3b,batchToSpaceND:()=>Re.E4h,bincount:()=>Re.yE8,booleanMaskAsync:()=>Re.anm,broadcastArgs:()=>Re.XsQ,broadcastTo:()=>Re.UFq,buffer:()=>Re.f3b,cast:()=>Re.pju,ceil:()=>Re.mDi,clipByValue:()=>Re.iUl,clone:()=>Re.d9v,complex:()=>Re.PYB,concat:()=>Re.zoF,concat1d:()=>Re.gME,concat2d:()=>Re.Izb,concat3d:()=>Re.MNy,concat4d:()=>Re.ZaL,conv1d:()=>Re.PAt,conv2d:()=>Re.Tek,conv2dTranspose:()=>Re.bc,conv3d:()=>Re.pdZ,conv3dTranspose:()=>Re.$QV,cos:()=>Re.mCk,cosh:()=>Re.f9Y,cosineWindow:()=>Re.mew,cumprod:()=>Re.$Gn,cumsum:()=>Re.zbp,denseBincount:()=>Re.ppE,depthToSpace:()=>Re.nTT,depthwiseConv2d:()=>Re.B10,diag:()=>Re.Ka3,dilation2d:()=>Re.WmZ,div:()=>Re.hiC,divNoNan:()=>Re.NTj,dot:()=>Re.AKD,dropout:()=>Re.rvX,einsum:()=>Re.WYO,elu:()=>Re.pyx,enclosingPowerOfTwo:()=>Re.GRh,equal:()=>Re.DgJ,erf:()=>Re.qNN,euclideanNorm:()=>Re.d2q,exp:()=>Re.Qqt,expandDims:()=>Re.dt4,expm1:()=>Re.t$B,eye:()=>Re.iyy,fft:()=>Re.kp_,fill:()=>Re.hlL,floor:()=>Re.GWj,floorDiv:()=>Re.qPi,fused:()=>Re.imm,gather:()=>Re.Iqj,gatherND:()=>Re.dbB,greater:()=>Re.pjt,greaterEqual:()=>Re.brS,ifft:()=>Re.Sxn,imag:()=>Re.asL,image:()=>Re.BHj,inTopKAsync:()=>Re.V3u,irfft:()=>Re.wx0,isFinite:()=>Re.xVT,isInf:()=>Re.UWc,isNaN:()=>Re.i2d,leakyRelu:()=>Re.hi7,less:()=>Re.d9m,lessEqual:()=>Re.zN1,linalg:()=>Re.$r2,linspace:()=>Re.SX3,localResponseNormalization:()=>Re.G9k,log:()=>Re.cM7,log1p:()=>Re.Krr,logSigmoid:()=>Re.e_t,logSoftmax:()=>Re.CmS,logSumExp:()=>Re.l_t,logicalAnd:()=>Re.HvI,logicalNot:()=>Re.hJK,logicalOr:()=>Re.K5V,logicalXor:()=>Re.egP,losses:()=>Re.MB5,lowerBound:()=>Re.eab,matMul:()=>Re.OI3,max:()=>Re.Fp7,maxPool:()=>Re._sB,maxPool3d:()=>Re.YQQ,maxPoolWithArgmax:()=>Re.Ip$,maximum:()=>Re.gWQ,mean:()=>Re.J69,meshgrid:()=>Re.ry_,min:()=>Re.VV$,minimum:()=>Re.LTh,mirrorPad:()=>Re.VdP,mod:()=>Re.wQq,moments:()=>Re.Gi7,movingAverage:()=>Re.p_,mul:()=>Re.dC7,multiRNNCell:()=>Re.rq4,multinomial:()=>Re.SJ_,neg:()=>Re.W76,norm:()=>Re.KOy,notEqual:()=>Re.Quu,oneHot:()=>Re.lfX,ones:()=>Re.iUs,onesLike:()=>Re.JpU,op:()=>Re.op,outerProduct:()=>Re.N2O,pad:()=>Re.vku,pad1d:()=>Re.pNR,pad2d:()=>Re.koy,pad3d:()=>Re.t1L,pad4d:()=>Re.lGY,pool:()=>Re.d_R,pow:()=>Re.sQ3,prelu:()=>Re.AL3,print:()=>Re.S0v,prod:()=>Re.WVs,raggedGather:()=>Re.$gW,raggedTensorToTensor:()=>Re.N89,rand:()=>Re.TN_,randomGamma:()=>Re.wzB,randomNormal:()=>Re.nGf,randomStandardNormal:()=>Re.ruB,randomUniform:()=>Re.LGj,range:()=>Re.w6H,real:()=>Re.kwC,reciprocal:()=>Re.M25,relu:()=>Re.UYe,relu6:()=>Re.btT,reshape:()=>Re.XLQ,reverse:()=>Re.GYS,reverse1d:()=>Re.SDf,reverse2d:()=>Re.diP,reverse3d:()=>Re.sx7,reverse4d:()=>Re.mG2,rfft:()=>Re.QEs,round:()=>Re.NMM,rsqrt:()=>Re.bp0,scalar:()=>Re.iD$,scatterND:()=>Re.snQ,searchSorted:()=>Re.zcT,selu:()=>Re.U8D,separableConv2d:()=>Re.U_I,setdiff1dAsync:()=>Re.ODp,sigmoid:()=>Re.XD2,sign:()=>Re.Xxe,signal:()=>Re.tdS,sin:()=>Re.O$l,sinh:()=>Re.R_K,slice:()=>Re.tPi,slice1d:()=>Re.jZU,slice2d:()=>Re.SmN,slice3d:()=>Re.CnO,slice4d:()=>Re.p0P,softmax:()=>Re.XAC,softplus:()=>Re.Wvh,spaceToBatchND:()=>Re.fBT,sparse:()=>Re.rVs,sparseToDense:()=>Re.ers,spectral:()=>Re.uN7,split:()=>Re.Vl2,sqrt:()=>Re._b3,square:()=>Re.h62,squaredDifference:()=>Re.$i,squeeze:()=>Re.L9e,stack:()=>Re.knu,step:()=>Re.Nbs,stridedSlice:()=>Re.NXj,string:()=>Re.Z_8,sub:()=>Re.luU,sum:()=>Re.Smz,tan:()=>Re.ORZ,tanh:()=>Re.AEp,tensor:()=>Re.XeE,tensor1d:()=>Re.RRF,tensor2d:()=>Re.odF,tensor3d:()=>Re.wOQ,tensor4d:()=>Re.yXz,tensor5d:()=>Re.Bfx,tensor6d:()=>Re.xZs,tile:()=>Re.Gg6,topk:()=>Re.hg7,transpose:()=>Re.p4s,truncatedNormal:()=>Re.Xu6,unique:()=>Re.Two,unsortedSegmentSum:()=>Re.pUJ,unstack:()=>Re.HHK,upperBound:()=>Re.GaM,variable:()=>Re.VD$,where:()=>Re.arb,whereAsync:()=>Re.itS,zeros:()=>Re.lls,zerosLike:()=>Re.P84});var Oe=M(1726);(0,Oe.env)().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,v=>{v&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var ye,$e=M(5861),Ce=(()=>{return(v=Ce||(Ce={}))[v.DT_INVALID=0]="DT_INVALID",v[v.DT_FLOAT=1]="DT_FLOAT",v[v.DT_DOUBLE=2]="DT_DOUBLE",v[v.DT_INT32=3]="DT_INT32",v[v.DT_UINT8=4]="DT_UINT8",v[v.DT_INT16=5]="DT_INT16",v[v.DT_INT8=6]="DT_INT8",v[v.DT_STRING=7]="DT_STRING",v[v.DT_COMPLEX64=8]="DT_COMPLEX64",v[v.DT_INT64=9]="DT_INT64",v[v.DT_BOOL=10]="DT_BOOL",v[v.DT_QINT8=11]="DT_QINT8",v[v.DT_QUINT8=12]="DT_QUINT8",v[v.DT_QINT32=13]="DT_QINT32",v[v.DT_BFLOAT16=14]="DT_BFLOAT16",v[v.DT_QINT16=15]="DT_QINT16",v[v.DT_QUINT16=16]="DT_QUINT16",v[v.DT_UINT16=17]="DT_UINT16",v[v.DT_COMPLEX128=18]="DT_COMPLEX128",v[v.DT_HALF=19]="DT_HALF",v[v.DT_RESOURCE=20]="DT_RESOURCE",v[v.DT_VARIANT=21]="DT_VARIANT",v[v.DT_UINT32=22]="DT_UINT32",v[v.DT_UINT64=23]="DT_UINT64",v[v.DT_FLOAT_REF=101]="DT_FLOAT_REF",v[v.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",v[v.DT_INT32_REF=103]="DT_INT32_REF",v[v.DT_UINT8_REF=104]="DT_UINT8_REF",v[v.DT_INT16_REF=105]="DT_INT16_REF",v[v.DT_INT8_REF=106]="DT_INT8_REF",v[v.DT_STRING_REF=107]="DT_STRING_REF",v[v.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",v[v.DT_INT64_REF=109]="DT_INT64_REF",v[v.DT_BOOL_REF=110]="DT_BOOL_REF",v[v.DT_QINT8_REF=111]="DT_QINT8_REF",v[v.DT_QUINT8_REF=112]="DT_QUINT8_REF",v[v.DT_QINT32_REF=113]="DT_QINT32_REF",v[v.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",v[v.DT_QINT16_REF=115]="DT_QINT16_REF",v[v.DT_QUINT16_REF=116]="DT_QUINT16_REF",v[v.DT_UINT16_REF=117]="DT_UINT16_REF",v[v.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",v[v.DT_HALF_REF=119]="DT_HALF_REF",v[v.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",v[v.DT_VARIANT_REF=121]="DT_VARIANT_REF",v[v.DT_UINT32_REF=122]="DT_UINT32_REF",v[v.DT_UINT64_REF=123]="DT_UINT64_REF",Ce;var v})();!function(v){let p;var g;(g=p=v.CheckpointFormatVersion||(v.CheckpointFormatVersion={}))[g.LEGACY=0]="LEGACY",g[g.V1=1]="V1",g[g.V2=2]="V2"}(ye||(ye={}));const $={};function se(v,p){$[v]={tfOpName:v,category:"custom",inputs:[],attrs:[],customExecutor:p}}function be(v){return $[v]}function ce(v){delete $[v]}function x(v,p,g,C,G){const K=p.inputParams[v];if(K&&void 0!==K.inputIndexStart){const oe=K.inputIndexStart,Ue=0===K.inputIndexEnd?void 0:void 0===K.inputIndexEnd?oe+1:K.inputIndexEnd;if("tensor"===K.type)return He(p.inputNames[K.inputIndexStart],g,C,G);if("tensors"===K.type)return p.inputNames.slice(oe,Ue).map(bt=>He(bt,g,C,G));const ut=He(p.inputNames.slice(oe)[0],g,C,G),tt=ut.dataSync();return"number"===K.type?tt[0]:Oe.util.toNestedArray(ut.shape,tt)}const ae=p.attrParams[v];return ae&&ae.value}function He(v,p,g,C){const[G,K]=et(v);if(null!=C){const oe=C.getHashTableHandleByName(G);if(null!=oe)return oe}const ae=g.currentContextIds.find(oe=>!!p[nt(G,oe)]);return void 0!==ae?p[nt(G,ae)][K]:void 0}function We(v,p){const[g,C,G]=et(v);return[nt(g,p&&p.currentContextId),C,G]}function nt(v,p){return p?`${v}-${p}`:v}function et(v){const p=v.split(":");if(1===p.length)return[v,0,void 0];const C=3===p.length?p[1]:void 0;return[p[0],Number(p[p.length-1]),C]}function Ft(v,p,g){let C=x("pad",v,p,g);if("explicit"===C){C=x("explicitPaddings",v,p,g);const G=[[0,0],[0,0],[0,0],[0,0]];for(let K=0;K<4;K++)G[K][0]=C[2*K],G[K][1]=C[2*K+1];return G}return C}function Yt(v){return v.kept?v:(0,Oe.clone)(v)}const Zt=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],yn=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Mn=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],cr=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],kn=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],dn=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],un=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Fn=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],ds=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],Zn=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Ne=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],rt=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],lt=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],Nt=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],wn=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],zn=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Jn=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],wr=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],$r=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class _r{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const g=[].concat(...[_e,we,te,Q,F,j,Ie,me,Y,le,ee,A,de,Pe,xe,Ze,ot,St,Vt].map(C=>C.json));this.opMappers=g.reduce((C,G)=>(C[G.tfOpName]=G,C),{})}transformGraph(p,g={}){const G=[],K=[],ae=[],oe=p.node.reduce((Ht,ln)=>(Ht[ln.name]=this.mapNode(ln),ln.op.startsWith("Placeholder")?G.push(Ht[ln.name]):"Const"===ln.op?K.push(Ht[ln.name]):(null==ln.input||0===ln.input.length)&&ae.push(Ht[ln.name]),Ht),{});let Ue=[];const ut=[];let tt={},Je={};null!=g&&(tt=this.mapSignatureEntries(g.inputs),Je=this.mapSignatureEntries(g.outputs));const bt=Object.keys(oe);bt.forEach(Ht=>{const ln=oe[Ht];ln.inputNames.forEach((xr,zs)=>{const[ns,,kr]=We(xr),Po=oe[ns];if(null!=Po.outputs){const _i=Po.outputs.indexOf(kr);-1!==_i&&(ln.inputNames[zs]=`${ns}:${_i}`)}ln.inputs.push(Po),Po.children.push(ln)})}),0===Object.keys(Je).length?bt.forEach(Ht=>{const ln=oe[Ht];0===ln.children.length&&ut.push(ln)}):Object.keys(Je).forEach(Ht=>{const[ln]=We(Ht),xr=oe[ln];null!=xr&&(xr.signatureKey=Je[Ht],ut.push(xr))}),Object.keys(tt).length>0?Object.keys(tt).forEach(Ht=>{const[ln]=We(Ht),xr=oe[ln];xr&&(xr.signatureKey=tt[Ht],Ue.push(xr))}):Ue=G;let Wt={};null!=p.library&&null!=p.library.function&&(Wt=p.library.function.reduce((Ht,ln)=>(Ht[ln.signature.name]=this.mapFunction(ln),Ht),{}));const Gt={nodes:oe,inputs:Ue,outputs:ut,weights:K,placeholders:G,signature:g,functions:Wt};return ae.length>0&&(Gt.initNodes=ae),Gt}mapSignatureEntries(p){return Object.keys(p||{}).reduce((g,C)=>(g[p[C].name]=C,g),{})}mapNode(p){const g=be(p.op)||this.opMappers[p.op]||{};null==p.attr&&(p.attr={});const C={name:p.name,op:p.op,category:g.category,inputNames:(p.input||[]).map(G=>G.startsWith("^")?G.slice(1):G),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:p.attr,outputs:g.outputs};return null!=g.inputs&&(C.inputParams=g.inputs.reduce((G,K)=>(G[K.name]={type:K.type,inputIndexStart:K.start,inputIndexEnd:K.end},G),{})),null!=g.attrs&&(C.attrParams=g.attrs.reduce((G,K)=>{const ae=K.type;let oe;switch(K.type){case"string":oe=Yo(p.attr,K.tfName,K.defaultValue),void 0===oe&&K.tfDeprecatedName&&(oe=Yo(p.attr,K.tfDeprecatedName,K.defaultValue));break;case"string[]":oe=Qo(p.attr,K.tfName,K.defaultValue),void 0===oe&&K.tfDeprecatedName&&(oe=Qo(p.attr,K.tfDeprecatedName,K.defaultValue));break;case"number":oe=go(p.attr,K.tfName,K.defaultValue||0),void 0===oe&&K.tfDeprecatedName&&(oe=go(p.attr,K.tfDeprecatedName,K.defaultValue));break;case"number[]":oe=mr(p.attr,K.tfName,K.defaultValue),void 0===oe&&K.tfDeprecatedName&&(oe=mr(p.attr,K.tfDeprecatedName,K.defaultValue));break;case"bool":oe=Fr(p.attr,K.tfName,K.defaultValue),void 0===oe&&K.tfDeprecatedName&&(oe=Fr(p.attr,K.tfDeprecatedName,K.defaultValue));break;case"bool[]":oe=nr(p.attr,K.tfName,K.defaultValue),void 0===oe&&K.tfDeprecatedName&&(oe=nr(p.attr,K.tfDeprecatedName,K.defaultValue));break;case"shape":oe=oo(p.attr,K.tfName,K.defaultValue),void 0===oe&&K.tfDeprecatedName&&(oe=oo(p.attr,K.tfDeprecatedName,K.defaultValue));break;case"shape[]":oe=Ao(p.attr,K.tfName,K.defaultValue),void 0===oe&&K.tfDeprecatedName&&(oe=Ao(p.attr,K.tfDeprecatedName,K.defaultValue));break;case"dtype":oe=Zo(p.attr,K.tfName,K.defaultValue),void 0===oe&&K.tfDeprecatedName&&(oe=Zo(p.attr,K.tfDeprecatedName,K.defaultValue));break;case"dtype[]":oe=bi(p.attr,K.tfName,K.defaultValue),void 0===oe&&K.tfDeprecatedName&&(oe=bi(p.attr,K.tfDeprecatedName,K.defaultValue));break;case"func":oe=is(p.attr,K.tfName,K.defaultValue),void 0===oe&&K.tfDeprecatedName&&(oe=is(p.attr,K.tfDeprecatedName,K.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${K.type} for op: ${p.op}`)}return G[K.name]={value:oe,type:ae},G},{})),C}mapFunction(p){const g=p.nodeDef,G=[];let K={};null!=g&&(K=g.reduce((Je,bt)=>(Je[bt.name]=this.mapNode(bt),"Const"===bt.op&&G.push(Je[bt.name]),Je),{}));const ae=[],oe=[];p.signature.inputArg.forEach(Je=>{const[bt]=We(Je.name),Wt={name:bt,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:os(Je.type),type:"dtype"}},children:[]};Wt.signatureKey=Je.name,ae.push(Wt),K[bt]=Wt}),Object.keys(K).forEach(Je=>{const bt=K[Je];bt.inputNames.forEach((Wt,Gt)=>{const[Ht,,ln]=We(Wt),xr=K[Ht];if(null!=xr.outputs){const zs=xr.outputs.indexOf(ln);-1!==zs&&(bt.inputNames[Gt]=`${Ht}:${zs}`)}bt.inputs.push(xr),xr.children.push(bt)})});const ut=p.ret;p.signature.outputArg.forEach(Je=>{const[bt,Wt]=We(ut[Je.name]),Gt=K[bt];null!=Gt&&(Gt.defaultOutput=Wt,oe.push(Gt))});const tt=this.mapArgsToSignature(p);return{nodes:K,inputs:ae,outputs:oe,weights:G,placeholders:[],signature:tt}}mapArgsToSignature(p){return{methodName:p.signature.name,inputs:p.signature.inputArg.reduce((g,C)=>(g[C.name]=this.mapArgToTensorInfo(C),g),{}),outputs:p.signature.outputArg.reduce((g,C)=>(g[C.name]=this.mapArgToTensorInfo(C,p.ret),g),{})}}mapArgToTensorInfo(p,g){let C=p.name;return null!=g&&(C=g[C]),{name:C,dtype:p.type}}}function Ys(v,p){const g=Array.isArray(v)?String.fromCharCode.apply(null,v):function qs(v){const p=(0,Oe.env)().global;if(typeof p.atob<"u")return p.atob(v);if(typeof Buffer<"u")return new Buffer(v,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(v);return p?g:g.toLowerCase()}function Yo(v,p,g,C=!1){const G=v[p];return null!=G?Ys(G.s,C):g}function Fr(v,p,g){const C=v[p];return C?C.b:g}function go(v,p,g){const C=v[p]||{},G=null!=C.i?C.i:null!=C.f?C.f:g;return"number"==typeof G?G:parseInt(G,10)}function os(v){switch("string"==typeof v&&(v=Ce[v]),v){case Ce.DT_FLOAT:case Ce.DT_HALF:return"float32";case Ce.DT_INT32:case Ce.DT_INT64:case Ce.DT_INT8:case Ce.DT_UINT8:return"int32";case Ce.DT_BOOL:return"bool";case Ce.DT_DOUBLE:return"float32";case Ce.DT_STRING:return"string";default:return null}}function is(v,p,g){const C=v[p];return C&&C.func?C.func.name:g}function Zo(v,p,g){const C=v[p];return C&&C.type?os(C.type):g}function bi(v,p,g){const C=v[p];return C&&C.list&&C.list.type?C.list.type.map(G=>os(G)):g}function Zs(v){if(!v.unknownRank)return null!=v.dim?v.dim.map(p=>"number"==typeof p.size?p.size:parseInt(p.size,10)):[]}function oo(v,p,g){const C=v[p];return C&&C.shape?Zs(C.shape):g}function mr(v,p,g){const C=v[p];return C?((C.list.f&&C.list.f.length?C.list.f:C.list.i)||[]).map(G=>"number"==typeof G?G:parseInt(G,10)):g}function Qo(v,p,g,C=!1){const G=v[p];return G&&G.list&&G.list.s?G.list.s.map(K=>Ys(K,C)):g}function Ao(v,p,g){const C=v[p];return C&&C.list&&C.list.shape?C.list.shape.map(G=>Zs(G)):g}function nr(v,p,g){const C=v[p];return C&&C.list&&C.list.b?C.list.b:g}class Ro{constructor(p,g,C){this.node=p,this.tensorMap=g,this.context=C,this.inputs=[],this.attrs={},this.inputs=p.inputNames.map(G=>this.getInput(G)),null!=p.rawAttrs&&(this.attrs=Object.keys(p.rawAttrs).reduce((G,K)=>(G[K]=this.getAttr(K),G),{}))}getInput(p){return He(p,this.tensorMap,this.context)}getAttr(p,g){const C=this.node.rawAttrs[p];if(null!=C.tensor)return He(p,this.tensorMap,this.context);if(null!=C.i||null!=C.f)return go(this.node.rawAttrs,p,g);if(null!=C.s)return Yo(this.node.rawAttrs,p,g);if(null!=C.b)return Fr(this.node.rawAttrs,p,g);if(null!=C.shape)return oo(this.node.rawAttrs,p,g);if(null!=C.type)return Zo(this.node.rawAttrs,p,g);if(null!=C.list){if(null!=C.list.i||null!=C.list.f)return mr(this.node.rawAttrs,p,g);if(null!=C.list.s)return Qo(this.node.rawAttrs,p,g);if(null!=C.list.shape)return Ao(this.node.rawAttrs,p,g);if(null!=C.list.b)return nr(this.node.rawAttrs,p,g);if(null!=C.list.type)return bi(this.node.rawAttrs,p,g)}return g}}var Re=M(3084);const Ur=(v,p,g,C=ke)=>{switch(v.op){case"BiasAdd":case"AddV2":case"Add":return[C.add(x("a",v,p,g),x("b",v,p,g))];case"AddN":return[C.addN(x("tensors",v,p,g))];case"FloorMod":case"Mod":return[C.mod(x("a",v,p,g),x("b",v,p,g))];case"Mul":return[C.mul(x("a",v,p,g),x("b",v,p,g))];case"RealDiv":case"Div":return[C.div(x("a",v,p,g),x("b",v,p,g))];case"DivNoNan":return[C.divNoNan(x("a",v,p,g),x("b",v,p,g))];case"FloorDiv":return[C.floorDiv(x("a",v,p,g),x("b",v,p,g))];case"Sub":return[C.sub(x("a",v,p,g),x("b",v,p,g))];case"Minimum":return[C.minimum(x("a",v,p,g),x("b",v,p,g))];case"Maximum":return[C.maximum(x("a",v,p,g),x("b",v,p,g))];case"Pow":return[C.pow(x("a",v,p,g),x("b",v,p,g))];case"SquaredDifference":return[C.squaredDifference(x("a",v,p,g),x("b",v,p,g))];default:throw TypeError(`Node type ${v.op} is not implemented`)}},Bn=(v,p,g,C=ke)=>{switch(v.op){case"Abs":case"ComplexAbs":return[C.abs(x("x",v,p,g))];case"Acos":return[C.acos(x("x",v,p,g))];case"Acosh":return[C.acosh(x("x",v,p,g))];case"Asin":return[C.asin(x("x",v,p,g))];case"Asinh":return[C.asinh(x("x",v,p,g))];case"Atan":return[C.atan(x("x",v,p,g))];case"Atan2":return[C.atan2(x("x",v,p,g),x("y",v,p,g))];case"Atanh":return[C.atanh(x("x",v,p,g))];case"Ceil":return[C.ceil(x("x",v,p,g))];case"Complex":return[C.complex(x("real",v,p,g),x("imag",v,p,g))];case"Cos":return[C.cos(x("x",v,p,g))];case"Cosh":return[C.cosh(x("x",v,p,g))];case"Elu":return[C.elu(x("x",v,p,g))];case"Erf":return[C.erf(x("x",v,p,g))];case"Exp":return[C.exp(x("x",v,p,g))];case"Expm1":return[C.expm1(x("x",v,p,g))];case"Floor":return[C.floor(x("x",v,p,g))];case"Log":return[C.log(x("x",v,p,g))];case"Log1p":return[C.log1p(x("x",v,p,g))];case"Imag":return[C.imag(x("x",v,p,g))];case"Neg":return[C.neg(x("x",v,p,g))];case"Reciprocal":return[C.reciprocal(x("x",v,p,g))];case"Real":return[C.real(x("x",v,p,g))];case"Relu":return[C.relu(x("x",v,p,g))];case"Round":return[C.round(x("x",v,p,g))];case"Selu":return[C.selu(x("x",v,p,g))];case"Sigmoid":return[C.sigmoid(x("x",v,p,g))];case"Sin":return[C.sin(x("x",v,p,g))];case"Sign":return[C.sign(x("x",v,p,g))];case"Sinh":return[C.sinh(x("x",v,p,g))];case"Softplus":return[C.softplus(x("x",v,p,g))];case"Sqrt":return[C.sqrt(x("x",v,p,g))];case"Square":return[C.square(x("x",v,p,g))];case"Tanh":return[C.tanh(x("x",v,p,g))];case"Tan":return[C.tan(x("x",v,p,g))];case"ClipByValue":return[C.clipByValue(x("x",v,p,g),x("clipValueMin",v,p,g),x("clipValueMax",v,p,g))];case"Relu6":return[C.relu6(x("x",v,p,g))];case"Rsqrt":return[C.rsqrt(He(v.inputNames[0],p,g))];case"Prod":return[C.prod(x("x",v,p,g),x("axes",v,p,g))];case"LeakyRelu":return[C.leakyRelu(x("x",v,p,g),x("alpha",v,p,g))];case"Prelu":return[C.prelu(x("x",v,p,g),x("alpha",v,p,g))];case"IsNan":return[C.isNaN(He(v.inputNames[0],p,g))];default:throw TypeError(`Node type ${v.op} is not implemented`)}};function Ir(v,p,g=""){if("number"!=typeof v&&"number"!=typeof p){Oe.util.assert(v.length===p.length,()=>g+` Shapes ${v} and ${p} must match`);for(let C=0;C<v.length;C++){const G=v[C],K=p[C];Oe.util.assert(G<0||K<0||G===K,()=>g+` Shapes ${v} and ${p} must match`)}}}function Pr(v){return!("number"==typeof v||v.some(p=>p<0))}function ws(v,p,g){let C=sn(v,g);const G=!Pr(C);if(G&&0===p.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${C}`);if(G&&p.forEach(K=>{C=sn(K.shape,C)}),!Pr(C))throw new Error(`Non-fully-defined elementShape: ${C}`);return C}function sn(v,p){if("number"==typeof v)return p;if("number"==typeof p)return v;if(v.length!==p.length)throw new Error(`Incompatible ranks during merge: ${v} vs. ${p}`);const g=[];for(let C=0;C<v.length;++C){const G=v[C],K=p[C];if(G>=0&&K>=0&&G!==K)throw new Error(`Incompatible shape during merge: ${v} vs. ${p}`);g[C]=G>=0?G:K}return g}class io{constructor(p,g,C,G,K,ae,oe){this.name=p,this.dtype=g,this.maxSize=C,this.elementShape=G,this.identicalElementShapes=K,this.dynamicSize=ae,this.clearAfterRead=oe,this.tensors=[],this.closed_=!1,this.idTensor=(0,Oe.scalar)(0),(0,Oe.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(p){this.tensors.forEach(g=>{(null==p||!p.has(g.tensor.id))&&g.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(p){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(p<0||p>=this.size())throw new Error(`Tried to read from index ${p}, but array size is: ${this.size()}`);const g=this.tensors[p];if(g.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${p} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(g.cleared=!0),g.read=!0,g.tensor}readMany(p){return p.map(g=>this.read(g))}write(p,g){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(p<0||!this.dynamicSize&&p>=this.maxSize)throw new Error(`Tried to write to index ${p}, but array is not resizeable and size is: ${this.maxSize}`);const C=this.tensors[p]||{};if(g.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${p},\n          because the value dtype is ${g.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=g.shape),Ir(this.elementShape,g.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${p}.`),C.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${p}, because it has already been read.`);if(C.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${p}, because it has already been written.`);C.tensor=g,(0,Oe.keep)(g),C.written=!0,this.tensors[p]=C}writeMany(p,g){if(p.length!==g.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${p.length} is not the same as tensors size: ${g.length}.`);p.forEach((C,G)=>this.write(C,g[G]))}gather(p,g){if(g&&g!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${g}`);if(p)p=p.slice(0,this.size());else{p=[];for(let G=0;G<this.size();G++)p.push(G)}if(0===p.length)return(0,Oe.tensor)([],[0].concat(this.elementShape));const C=this.readMany(p);return Ir(this.elementShape,C[0].shape,"TensorArray shape mismatch: "),(0,Oe.stack)(C,0)}concat(p){if(p&&p!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${p}`);if(0===this.size())return(0,Oe.tensor)([],[0].concat(this.elementShape));const g=[];for(let G=0;G<this.size();G++)g.push(G);const C=this.readMany(g);return Ir(this.elementShape,C[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${C[0].shape})`),(0,Oe.concat)(C,0)}scatter(p,g){if(g.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${g.dtype}`);if(p.length!==g.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${p.length} vs. ${g.shape[0]}`);const C=Math.max(...p);if(!this.dynamicSize&&C>=this.maxSize)throw new Error(`Max index must be < array size (${C}  vs. ${this.maxSize})`);this.writeMany(p,(0,Oe.unstack)(g,0))}split(p,g){if(g.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${g.dtype}`);let C=0;const G=p.map(Ue=>(C+=Ue,C));if(C!==g.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${C}, and tensor's shape is: ${g.shape}`);if(!this.dynamicSize&&p.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${p.length}), and the TensorArray is not marked as dynamically resizeable`);const K=0===C?0:g.size/C,ae=[];(0,Oe.tidy)(()=>{g=(0,Oe.reshape)(g,[1,C,K]);for(let Ue=0;Ue<p.length;++Ue)ae[Ue]=(0,Oe.reshape)((0,Oe.slice)(g,[0,0===Ue?0:G[Ue-1],0],[1,p[Ue],K]),this.elementShape);return ae});const oe=[];for(let Ue=0;Ue<p.length;Ue++)oe[Ue]=Ue;this.writeMany(oe,ae)}}class Gr{constructor(p,g,C,G=-1){this.tensors=p,this.elementShape=g,this.elementDtype=C,p?.forEach(K=>{if(C!==K.dtype)throw new Error(`Invalid data types; op elements ${C}, but list elements ${K.dtype}`);Ir(g,K.shape,"TensorList shape mismatch: "),(0,Oe.keep)(K)}),this.idTensor=(0,Oe.scalar)(0),this.maxNumElements=G,(0,Oe.keep)(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Gr([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(p){this.tensors.forEach(g=>{(null==p||!p.has(g.id))&&g.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(p,g,C=-1){if(g!==this.elementDtype)throw new Error(`Invalid data types; op elements ${g}, but list elements ${this.elementDtype}`);if(-1!==C&&this.tensors.length!==C)throw new Error(`Operation expected a list with ${C} elements but got a list with ${this.tensors.length} elements.`);Ir(p,this.elementShape,"TensorList shape mismatch: ");const G=ws(this.elementShape,this.tensors,p);return(0,Oe.tidy)(()=>{const K=this.tensors.map(ae=>(0,Oe.reshape)(ae,G));return(0,Oe.stack)(K,0)})}popBack(p,g){if(g!==this.elementDtype)throw new Error(`Invalid data types; op elements ${g}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const C=ws(this.elementShape,this.tensors,p),G=this.tensors.pop();return G.kept=!1,Ir(G.shape,p,"TensorList shape mismatch: "),(0,Oe.reshape)(G,C)}pushBack(p){if(p.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${p.dtype}, but list elements ${this.elementDtype}`);if(Ir(p.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,Oe.keep)(p),this.tensors.push(p)}resize(p){if(p<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${p}`);if(-1!==this.maxNumElements&&p>this.maxNumElements)throw new Error(`TensorListResize input size ${p} is greater maxNumElement ${this.maxNumElements}.`);const g=new Gr([],this.elementShape,this.elementDtype,this.maxNumElements);g.tensors.length=p;for(let C=0;C<Math.min(this.tensors.length,p);++C)g.tensors[C]=this.tensors[C];return g}getItem(p,g,C){if(C!==this.elementDtype)throw new Error(`Invalid data types; op elements ${C}, but list elements ${this.elementDtype}`);if(p<0||p>this.tensors.length)throw new Error(`Trying to access element ${p} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[p])throw new Error(`element at index ${p} is null.`);Ir(this.tensors[p].shape,g,"TensorList shape mismatch: ");const G=ws(this.elementShape,this.tensors,g);return(0,Oe.reshape)(this.tensors[p],G)}setItem(p,g){if(g.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${g.dtype}, but list elements ${this.elementDtype}`);if(p<0||-1!==this.maxNumElements&&p>=this.maxNumElements)throw new Error(`Trying to set element ${p} in a list with max ${this.maxNumElements} elements.`);Ir(this.elementShape,g.shape,"TensorList shape mismatch: "),(0,Oe.keep)(g),null!=this.tensors[p]&&(this.tensors[p].kept=!1),this.tensors[p]=g}gather(p,g,C){if(g!==this.elementDtype)throw new Error(`Invalid data types; op elements ${g}, but list elements ${this.elementDtype}`);Ir(this.elementShape,C,"TensorList shape mismatch: "),p=p.slice(0,this.size());const G=ws(this.elementShape,this.tensors,C);return 0===p.length?(0,Oe.tensor)([],[0].concat(G)):(0,Oe.tidy)(()=>{const K=p.map(ae=>(0,Oe.reshape)(this.tensors[ae],G));return(0,Oe.stack)(K,0)})}concat(p,g){if(p&&p!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${p}`);Ir(this.elementShape,g,"TensorList shape mismatch: ");const C=ws(this.elementShape,this.tensors,g);return 0===this.size()?(0,Oe.tensor)([],[0].concat(C)):(0,Oe.tidy)(()=>{const G=this.tensors.map(K=>(0,Oe.reshape)(K,C));return(0,Oe.concat)(G,0)})}}const pn=function(){var v=(0,$e.Z)(function*(p,g,C){switch(p.op){case"If":case"StatelessIf":{const G=x("thenBranch",p,g,C),K=x("elseBranch",p,g,C),ae=x("cond",p,g,C),oe=x("args",p,g,C);return(yield ae.data())[0]?C.functionMap[G].executeFunctionAsync(oe,C.tensorArrayMap,C.tensorListMap):C.functionMap[K].executeFunctionAsync(oe,C.tensorArrayMap,C.tensorListMap)}case"While":case"StatelessWhile":{const G=x("body",p,g,C),K=x("cond",p,g,C),ae=x("args",p,g,C),oe=yield C.functionMap[K].executeFunctionAsync(ae,C.tensorArrayMap,C.tensorListMap),Ue=ae.map(Je=>Je.id);let ut=yield oe[0].data();oe.forEach(Je=>{!Je.kept&&-1===Ue.indexOf(Je.id)&&Je.dispose()});let tt=ae;for(;ut[0];){const Je=tt;tt=yield C.functionMap[G].executeFunctionAsync(tt,C.tensorArrayMap,C.tensorListMap);const bt=tt.map(Gt=>Gt.id);Je.forEach(Gt=>{!Gt.kept&&-1===Ue.indexOf(Gt.id)&&-1===bt.indexOf(Gt.id)&&Gt.dispose()});const Wt=yield C.functionMap[K].executeFunctionAsync(tt,C.tensorArrayMap,C.tensorListMap);ut=yield Wt[0].data(),Wt.forEach(Gt=>{!Gt.kept&&-1===Ue.indexOf(Gt.id)&&-1===bt.indexOf(Gt.id)&&Gt.dispose()})}return tt}case"LoopCond":return[Yt(x("pred",p,g,C))];case"Switch":{const G=x("pred",p,g,C);let K=x("data",p,g,C);return K.kept||(K=Yt(K)),(yield G.data())[0]?[void 0,K]:[K,void 0]}case"Merge":{const G=p.inputNames.find(K=>void 0!==He(K,g,C));return G?[Yt(He(G,g,C))]:void 0}case"Enter":{const G=x("frameName",p,g,C),K=x("tensor",p,g,C);return C.enterFrame(G),[Yt(K)]}case"Exit":{const G=x("tensor",p,g,C);return C.exitFrame(),[Yt(G)]}case"NextIteration":{const G=x("tensor",p,g,C);return C.nextIteration(),[Yt(G)]}case"TensorArrayV3":{const G=x("size",p,g,C),K=x("dtype",p,g,C),ae=x("elementShape",p,g,C),oe=x("dynamicSize",p,g,C),Ue=x("clearAfterRead",p,g,C),ut=x("identicalElementShapes",p,g,C),tt=x("name",p,g,C),Je=new io(tt,K,G,ae,ut,oe,Ue);return C.addTensorArray(Je),[Je.idTensor,(0,Oe.scalar)(1)]}case"TensorArrayWriteV3":{const G=x("tensorArrayId",p,g,C),K=x("index",p,g,C),ae=x("tensor",p,g,C),oe=C.getTensorArray(G.id);return oe.write(K,ae),[oe.idTensor]}case"TensorArrayReadV3":{const G=x("tensorArrayId",p,g,C),K=x("index",p,g,C);return[C.getTensorArray(G.id).read(K)]}case"TensorArrayGatherV3":{const G=x("tensorArrayId",p,g,C),K=x("indices",p,g,C),ae=x("dtype",p,g,C);return[C.getTensorArray(G.id).gather(K,ae)]}case"TensorArrayScatterV3":{const G=x("tensorArrayId",p,g,C),K=x("indices",p,g,C),ae=x("tensor",p,g,C),oe=C.getTensorArray(G.id);return oe.scatter(K,ae),[oe.idTensor]}case"TensorArrayConcatV3":{const G=x("tensorArrayId",p,g,C),K=C.getTensorArray(G.id),ae=x("dtype",p,g,C);return[K.concat(ae)]}case"TensorArraySplitV3":{const G=x("tensorArrayId",p,g,C),K=x("tensor",p,g,C),ae=x("lengths",p,g,C),oe=C.getTensorArray(G.id);return oe.split(ae,K),[oe.idTensor]}case"TensorArraySizeV3":{const G=x("tensorArrayId",p,g,C),K=C.getTensorArray(G.id);return[(0,Oe.scalar)(K.size(),"int32")]}case"TensorArrayCloseV3":{const G=x("tensorArrayId",p,g,C),K=C.getTensorArray(G.id);return K.clearAndClose(),[K.idTensor]}case"TensorListSetItem":{const G=x("tensorListId",p,g,C),K=x("index",p,g,C),ae=x("tensor",p,g,C),oe=C.getTensorList(G.id);return oe.setItem(K,ae),[oe.idTensor]}case"TensorListGetItem":{const G=x("tensorListId",p,g,C),K=x("index",p,g,C),ae=x("elementShape",p,g,C),oe=x("elementDType",p,g,C);return[C.getTensorList(G.id).getItem(K,ae,oe)]}case"TensorListScatterV2":case"TensorListScatter":{const G=x("indices",p,g,C),Ue=function Pt(v,p,g,C){if(p.length!==v.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${p.length} vs. ${v.shape[0]}`);const G=Math.max(...p);if(null!=C&&-1!==C&&G>=C)throw new Error(`Max index must be < array size (${G}  vs. ${C})`);const K=new Gr([],g,v.dtype,C),ae=(0,Oe.unstack)(v,0);return p.forEach((oe,Ue)=>{K.setItem(oe,ae[Ue])}),K}(x("tensor",p,g,C),G,x("elementShape",p,g,C),x("numElements",p,g,C));return C.addTensorList(Ue),[Ue.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const G=x("elementShape",p,g,C),K=x("elementDType",p,g,C);let ae;ae="TensorListReserve"===p.op?"numElements":"maxNumElements";const oe=x(ae,p,g,C),ut=function Vi(v,p,g,C){return new Gr([],v,p,C)}(G,K,0,"TensorListReserve"===p.op?-1:oe);return C.addTensorList(ut),[ut.idTensor]}case"TensorListGather":{const G=x("tensorListId",p,g,C),K=x("indices",p,g,C),ae=x("elementShape",p,g,C),oe=x("elementDType",p,g,C);return[C.getTensorList(G.id).gather(K,oe,ae)]}case"TensorListStack":{const G=x("tensorListId",p,g,C),K=x("elementShape",p,g,C),ae=x("elementDType",p,g,C),oe=x("numElements",p,g,C);return[C.getTensorList(G.id).stack(K,ae,oe)]}case"TensorListFromTensor":{const oe=function Cs(v,p,g){const C=v.dtype;if(v.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${v.shape}`);if(v.dtype!==g)throw new Error(`Invalid data types; op elements ${v.dtype}, but list elements ${g}`);Ir(v.shape.slice(1),p,"TensorList shape mismatch: ");const K=(0,Oe.unstack)(v);return new Gr(K,p,C)}(x("tensor",p,g,C),x("elementShape",p,g,C),x("elementDType",p,g,C));return C.addTensorList(oe),[oe.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const G=x("tensorListId",p,g,C),K=C.getTensorList(G.id),ae=x("dtype",p,g,C),oe=x("elementShape",p,g,C);return[K.concat(ae,oe)]}case"TensorListPushBack":{const G=x("tensorListId",p,g,C),K=x("tensor",p,g,C),ae=C.getTensorList(G.id);return ae.pushBack(K),[ae.idTensor]}case"TensorListPopBack":{const G=x("tensorListId",p,g,C),K=x("elementShape",p,g,C),ae=x("elementDType",p,g,C);return[C.getTensorList(G.id).popBack(K,ae)]}case"TensorListSplit":{const G=x("tensor",p,g,C),K=x("elementShape",p,g,C),oe=function Lr(v,p,g){let C=0;const G=p.map(tt=>(C+=tt,C));if(C!==v.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${C}, and tensor's shape is: ${v.shape}`);const ae=sn(v.shape.slice(1),g),oe=0===C?0:v.size/C,Ue=(0,Oe.tidy)(()=>{const tt=[];v=(0,Oe.reshape)(v,[1,C,oe]);for(let Je=0;Je<p.length;++Je)tt[Je]=(0,Oe.reshape)((0,Oe.slice)(v,[0,0===Je?0:G[Je-1],0],[1,p[Je],oe]),ae);return v.dispose(),tt}),ut=new Gr([],g,v.dtype,p.length);for(let tt=0;tt<Ue.length;tt++)ut.setItem(tt,Ue[tt]);return ut}(G,x("lengths",p,g,C),K);return C.addTensorList(oe),[oe.idTensor]}case"TensorListLength":{const G=x("tensorListId",p,g,C),K=C.getTensorList(G.id);return[(0,Oe.scalar)(K.size(),"int32")]}case"TensorListResize":{const G=x("tensorListId",p,g,C),K=x("size",p,g,C),oe=C.getTensorList(G.id).resize(K);return C.addTensorList(oe),[oe.idTensor]}default:throw TypeError(`Node type ${p.op} is not implemented`)}});return function(g,C,G){return v.apply(this,arguments)}}();function yo(v,p,g){const[C,G]=x("fusedOps",v,p,g),K="biasadd"===C,ae=!K,oe="prelu"===G,Ue="fusedbatchnorm"===C,ut=x("numArgs",v,p,g);if(K){if(oe&&2!==ut)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!oe&&K&&1!==ut)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(Ue)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const tt=x("strides",v,p,g),Je=Ft(v,p,g),bt=x("dataFormat",v,p,g).toUpperCase(),Wt=x("dilations",v,p,g);let[Gt,Ht]=x("args",v,p,g);return ae&&(Ht=Gt,Gt=void 0),{stride:tt,pad:Je,dataFormat:bt,dilations:Wt,biasArg:Gt,preluArg:Ht,activationFunc:G,leakyreluAlpha:x("leakyreluAlpha",v,p,g)}}const $a=(v,p,g,C=ke)=>{switch(v.op){case"Conv1D":{const G=x("stride",v,p,g),K=x("pad",v,p,g),ae=x("dataFormat",v,p,g).toUpperCase(),oe=x("dilation",v,p,g);return[C.conv1d(x("x",v,p,g),x("filter",v,p,g),G,K,ae,oe)]}case"Conv2D":{const G=x("strides",v,p,g),K=Ft(v,p,g),ae=x("dataFormat",v,p,g).toUpperCase(),oe=x("dilations",v,p,g);return[C.conv2d(x("x",v,p,g),x("filter",v,p,g),[G[1],G[2]],K,ae,[oe[1],oe[2]])]}case"_FusedConv2D":{const{stride:G,pad:K,dataFormat:ae,dilations:oe,biasArg:Ue,preluArg:ut,activationFunc:tt,leakyreluAlpha:Je}=yo(v,p,g);return[C.fused.conv2d({x:x("x",v,p,g),filter:x("filter",v,p,g),strides:[G[1],G[2]],pad:K,dataFormat:ae,dilations:[oe[1],oe[2]],bias:Ue,activation:tt,preluActivationWeights:ut,leakyreluAlpha:Je})]}case"FusedDepthwiseConv2dNative":{const{stride:G,pad:K,dataFormat:ae,dilations:oe,biasArg:Ue,preluArg:ut,activationFunc:tt,leakyreluAlpha:Je}=yo(v,p,g);return[C.fused.depthwiseConv2d({x:x("x",v,p,g),filter:x("filter",v,p,g),strides:[G[1],G[2]],pad:K,dataFormat:ae,dilations:[oe[1],oe[2]],bias:Ue,activation:tt,preluActivationWeights:ut,leakyreluAlpha:Je})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const G=x("outputShape",v,p,g),K=x("strides",v,p,g),ae=Ft(v,p,g);return[C.conv2dTranspose(x("x",v,p,g),x("filter",v,p,g),G,[K[1],K[2]],ae)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const G=x("strides",v,p,g),K=Ft(v,p,g),ae=x("dilations",v,p,g),oe=x("dataFormat",v,p,g).toUpperCase();return[C.depthwiseConv2d(x("input",v,p,g),x("filter",v,p,g),[G[1],G[2]],K,oe,[ae[1],ae[2]])]}case"Conv3D":{const G=x("strides",v,p,g),K=x("pad",v,p,g),ae=x("dataFormat",v,p,g).toUpperCase(),oe=x("dilations",v,p,g);return[C.conv3d(x("x",v,p,g),x("filter",v,p,g),[G[1],G[2],G[3]],K,ae,[oe[1],oe[2],oe[3]])]}case"AvgPool":{const G=x("strides",v,p,g),K=x("pad",v,p,g),ae=x("kernelSize",v,p,g);return[C.avgPool(x("x",v,p,g),[ae[1],ae[2]],[G[1],G[2]],K)]}case"MaxPool":{const G=x("strides",v,p,g),K=x("pad",v,p,g),ae=x("kernelSize",v,p,g);return[C.maxPool(x("x",v,p,g),[ae[1],ae[2]],[G[1],G[2]],K)]}case"MaxPoolWithArgmax":{const G=x("strides",v,p,g),K=x("pad",v,p,g),ae=x("kernelSize",v,p,g),oe=x("includeBatchInIndex",v,p,g),{result:Ue,indexes:ut}=C.maxPoolWithArgmax(x("x",v,p,g),[ae[1],ae[2]],[G[1],G[2]],K,oe);return[Ue,ut]}case"AvgPool3D":{const G=x("strides",v,p,g),K=x("pad",v,p,g),ae=x("kernelSize",v,p,g);return[C.avgPool3d(x("x",v,p,g),[ae[1],ae[2],ae[3]],[G[1],G[2],G[3]],K)]}case"MaxPool3D":{const G=x("strides",v,p,g),K=x("pad",v,p,g),ae=x("kernelSize",v,p,g);return[C.maxPool3d(x("x",v,p,g),[ae[1],ae[2],ae[3]],[G[1],G[2],G[3]],K)]}case"Dilation2D":{const G=x("strides",v,p,g),K=x("pad",v,p,g),ae=x("dilations",v,p,g),oe=G[1],Ue=G[2],ut=ae[1],tt=ae[2];return[C.dilation2d(x("x",v,p,g),x("filter",v,p,g),[oe,Ue],K,[ut,tt],"NHWC")]}default:throw TypeError(`Node type ${v.op} is not implemented`)}},Us=(v,p,g,C=ke)=>{switch(v.op){case"Fill":{const G=x("shape",v,p,g),K=x("dtype",v,p,g),ae=x("value",v,p,g);return[C.fill(G,ae,K)]}case"LinSpace":{const G=x("start",v,p,g),K=x("stop",v,p,g),ae=x("num",v,p,g);return[C.linspace(G,K,ae)]}case"Multinomial":{const G=x("logits",v,p,g),K=x("numSamples",v,p,g),ae=x("seed",v,p,g);return[C.multinomial(G,K,ae)]}case"OneHot":{const G=x("indices",v,p,g),K=x("depth",v,p,g),ae=x("onValue",v,p,g),oe=x("offValue",v,p,g),Ue=x("dtype",v,p,g);return[C.oneHot(G,K,ae,oe,Ue)]}case"Ones":return[C.ones(x("shape",v,p,g),x("dtype",v,p,g))];case"OnesLike":return[C.onesLike(x("x",v,p,g))];case"RandomStandardNormal":return[C.randomStandardNormal(x("shape",v,p,g),x("dtype",v,p,g),x("seed",v,p,g))];case"RandomUniform":return[C.randomUniform(x("shape",v,p,g),x("minval",v,p,g),x("maxval",v,p,g),x("dtype",v,p,g))];case"Range":{const G=x("start",v,p,g),K=x("stop",v,p,g),ae=x("step",v,p,g);return[C.range(G,K,ae,x("dtype",v,p,g))]}case"TruncatedNormal":{const G=x("shape",v,p,g),K=x("mean",v,p,g),ae=x("stdDev",v,p,g),oe=x("seed",v,p,g);return[C.truncatedNormal(G,K,ae,x("dtype",v,p,g),oe)]}case"Zeros":return[C.zeros(x("shape",v,p,g),x("dtype",v,p,g))];case"ZerosLike":return[C.zerosLike(x("x",v,p,g))];default:throw TypeError(`Node type ${v.op} is not implemented`)}};function Ui(v,p,g){return{boxes:x("boxes",v,p,g),scores:x("scores",v,p,g),maxOutputSize:x("maxOutputSize",v,p,g),iouThreshold:x("iouThreshold",v,p,g),scoreThreshold:x("scoreThreshold",v,p,g),softNmsSigma:x("softNmsSigma",v,p,g)}}const Fa=function(){var v=(0,$e.Z)(function*(p,g,C,G,K=ke){switch(p.op){case"NonMaxSuppressionV5":{const{boxes:ae,scores:oe,maxOutputSize:Ue,iouThreshold:ut,scoreThreshold:tt,softNmsSigma:Je}=Ui(p,g,C),bt=yield K.image.nonMaxSuppressionWithScoreAsync(ae,oe,Ue,ut,tt,Je);return[bt.selectedIndices,bt.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:ae,scores:oe,maxOutputSize:Ue,iouThreshold:ut,scoreThreshold:tt}=Ui(p,g,C),Je=x("padToMaxOutputSize",p,g,C),bt=yield K.image.nonMaxSuppressionPaddedAsync(ae,oe,Ue,ut,tt,Je);return[bt.selectedIndices,bt.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:ae,scores:oe,maxOutputSize:Ue,iouThreshold:ut,scoreThreshold:tt}=Ui(p,g,C);return[yield K.image.nonMaxSuppressionAsync(ae,oe,Ue,ut,tt)]}case"Where":{const ae=K.cast(x("condition",p,g,C),"bool"),oe=[yield K.whereAsync(ae)];return ae.dispose(),oe}case"ListDiff":return K.setdiff1dAsync(x("x",p,g,C),x("y",p,g,C));default:throw TypeError(`Node type ${p.op} is not implemented`)}});return function(g,C,G,K){return v.apply(this,arguments)}}(),ts=(v,p,g,C=ke)=>{switch(v.op){case"LowerBound":{const G=x("sortedSequence",v,p,g),K=x("values",v,p,g);return[C.lowerBound(G,K)]}case"TopKV2":{const G=x("x",v,p,g),K=x("k",v,p,g),ae=x("sorted",v,p,g),oe=C.topk(G,K,ae);return[oe.values,oe.indices]}case"UpperBound":{const G=x("sortedSequence",v,p,g),K=x("values",v,p,g);return[C.upperBound(G,K)]}case"Unique":{const G=x("x",v,p,g),K=C.unique(G);return[K.values,K.indices]}case"UniqueV2":{const G=x("x",v,p,g),K=x("axis",v,p,g),ae=C.unique(G,K);return[ae.values,ae.indices]}default:throw TypeError(`Node type ${v.op} is not implemented`)}},Pa=(v,p,g,C=ke)=>{switch(v.op){case"Const":return p[v.name];case"PlaceholderWithDefault":const G=x("default",v,p,g);return[He(v.name,p,g)||G];case"Placeholder":return[He(v.name,p,g)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Yt(x("x",v,p,g))];case"IdentityN":return x("x",v,p,g).map(tt=>Yt(tt));case"Shape":return[C.tensor1d(x("x",v,p,g).shape,"int32")];case"ShapeN":return x("x",v,p,g).map(tt=>C.tensor1d(tt.shape));case"Size":return[C.scalar(x("x",v,p,g).size,"int32")];case"Rank":return[C.scalar(x("x",v,p,g).rank,"int32")];case"NoOp":return[C.scalar(1)];case"Print":const ae=x("x",v,p,g),oe=x("data",v,p,g),Ue=x("message",v,p,g),ut=x("summarize",v,p,g);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(Ue);for(let tt=0;tt<oe.length;tt++)console.log(Array.prototype.slice.call(oe[tt].dataSync()).slice(0,ut));return[ae];default:throw TypeError(`Node type ${v.op} is not implemented`)}};var Jo=M(316);class zi{constructor(p,g){this.keyDType=p,this.valueDType=g,this.handle=(0,Oe.scalar)(0),this.tensorMap=new Map,(0,Oe.keep)(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(p=>p.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Jo.i(this.size(),"int32")}import(p,g){var C=this;return(0,$e.Z)(function*(){C.checkKeyAndValueTensor(p,g);const G=yield p.data();return C.tensorMap.forEach(K=>K.dispose()),C.tensorMap.clear(),(0,Oe.tidy)(()=>{const K=(0,Oe.unstack)(g),ae=G.length,oe=K.length;Oe.util.assert(ae===oe,()=>`The number of elements doesn't match, keys has ${ae} elements, the values has ${oe} elements.`);for(let Ue=0;Ue<ae;Ue++){const ut=G[Ue],tt=K[Ue];(0,Oe.keep)(tt),C.tensorMap.set(ut,tt)}return C.handle})})()}find(p,g){var C=this;return(0,$e.Z)(function*(){C.checkKeyAndValueTensor(p,g);const G=yield p.data();return(0,Oe.tidy)(()=>{const K=[];for(let ae=0;ae<G.length;ae++){const Ue=C.findWithDefault(G[ae],g);K.push(Ue)}return(0,Oe.stack)(K)})})()}findWithDefault(p,g){return this.tensorMap.get(p)??g}checkKeyAndValueTensor(p,g){if(p.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${p.dtype}`);if(g.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${g.dtype}`)}}const La=function(){var v=(0,$e.Z)(function*(p,g,C,G){switch(p.op){case"HashTable":case"HashTableV2":{const K=x("keyDType",p,g,C),ae=x("valueDType",p,g,C),oe=new zi(K,ae);return G.addHashTable(p.name,oe),[oe.handle]}case"LookupTableImport":case"LookupTableImportV2":{const K=x("tableHandle",p,g,C,G),ae=x("keys",p,g,C),oe=x("values",p,g,C);return[yield G.getHashTableById(K.id).import(ae,oe)]}case"LookupTableFind":case"LookupTableFindV2":{const K=x("tableHandle",p,g,C,G),ae=x("keys",p,g,C),oe=x("defaultValue",p,g,C);return[yield G.getHashTableById(K.id).find(ae,oe)]}case"LookupTableSize":case"LookupTableSizeV2":{const K=x("tableHandle",p,g,C,G);return[G.getHashTableById(K.id).tensorSize()]}default:throw TypeError(`Node type ${p.op} is not implemented`)}});return function(g,C,G,K){return v.apply(this,arguments)}}(),Hi=(v,p,g,C=ke)=>{switch(v.op){case"ResizeBilinear":{const G=x("images",v,p,g),K=x("size",v,p,g),ae=x("alignCorners",v,p,g),oe=x("halfPixelCenters",v,p,g);return[C.image.resizeBilinear(G,[K[0],K[1]],ae,oe)]}case"ResizeNearestNeighbor":{const G=x("images",v,p,g),K=x("size",v,p,g),ae=x("alignCorners",v,p,g),oe=x("halfPixelCenters",v,p,g);return[C.image.resizeNearestNeighbor(G,[K[0],K[1]],ae,oe)]}case"CropAndResize":{const G=x("image",v,p,g),K=x("boxes",v,p,g),ae=x("boxInd",v,p,g),oe=x("cropSize",v,p,g),Ue=x("method",v,p,g),ut=x("extrapolationValue",v,p,g);return[C.image.cropAndResize(G,K,ae,oe,Ue,ut)]}case"ImageProjectiveTransformV3":{const G=x("images",v,p,g),K=x("transforms",v,p,g),ae=x("outputShape",v,p,g),oe=x("fillValue",v,p,g),Ue=x("interpolation",v,p,g),ut=x("fillMode",v,p,g);return[C.image.transform(G,K,Ue.toLowerCase(),ut.toLowerCase(),oe,ae)]}default:throw TypeError(`Node type ${v.op} is not implemented`)}},Qn=(v,p,g,C=ke)=>{switch(v.op){case"Equal":return[C.equal(x("a",v,p,g),x("b",v,p,g))];case"NotEqual":return[C.notEqual(x("a",v,p,g),x("b",v,p,g))];case"Greater":return[C.greater(x("a",v,p,g),x("b",v,p,g))];case"GreaterEqual":return[C.greaterEqual(x("a",v,p,g),x("b",v,p,g))];case"Less":return[C.less(x("a",v,p,g),x("b",v,p,g))];case"LessEqual":return[C.lessEqual(x("a",v,p,g),x("b",v,p,g))];case"LogicalAnd":return[C.logicalAnd(x("a",v,p,g),x("b",v,p,g))];case"LogicalNot":return[C.logicalNot(x("a",v,p,g))];case"LogicalOr":return[C.logicalOr(x("a",v,p,g),x("b",v,p,g))];case"Select":case"SelectV2":return[C.where(x("condition",v,p,g),x("a",v,p,g),x("b",v,p,g))];default:throw TypeError(`Node type ${v.op} is not implemented`)}},ji=(v,p,g,C=ke)=>{switch(v.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[C.matMul(x("a",v,p,g),x("b",v,p,g),x("transposeA",v,p,g),x("transposeB",v,p,g))];case"Einsum":return[C.einsum(x("equation",v,p,g),...x("tensors",v,p,g))];case"Transpose":return[C.transpose(x("x",v,p,g),x("perm",v,p,g))];case"_FusedMatMul":const[G,K]=x("fusedOps",v,p,g),ae="biasadd"===G,oe="prelu"===K,Ue=x("numArgs",v,p,g),ut=x("leakyreluAlpha",v,p,g);if(ae){if(oe&&2!==Ue)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!oe&&1!==Ue)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[tt,Je]=x("args",v,p,g);return[C.fused.matMul({a:x("a",v,p,g),b:x("b",v,p,g),transposeA:x("transposeA",v,p,g),transposeB:x("transposeB",v,p,g),bias:tt,activation:K,preluActivationWeights:Je,leakyreluAlpha:ut})];default:throw TypeError(`Node type ${v.op} is not implemented`)}},vn=(v,p,g,C=ke)=>{switch(v.op){case"EuclideanNorm":return[C.euclideanNorm(x("x",v,p,g),x("axis",v,p,g),x("keepDims",v,p,g))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[C.batchNorm(x("x",v,p,g),x("mean",v,p,g),x("variance",v,p,g),x("offset",v,p,g),x("scale",v,p,g),x("epsilon",v,p,g))];case"LRN":return[C.localResponseNormalization(x("x",v,p,g),x("radius",v,p,g),x("bias",v,p,g),x("alpha",v,p,g),x("beta",v,p,g))];case"Softmax":return[C.softmax(x("x",v,p,g))];case"LogSoftmax":return[C.logSoftmax(x("x",v,p,g))];case"SparseToDense":return[C.sparseToDense(x("sparseIndices",v,p,g),x("outputShape",v,p,g),x("sparseValues",v,p,g),x("defaultValue",v,p,g))];default:throw TypeError(`Node type ${v.op} is not implemented`)}},Ws=(v,p,g,C=ke)=>{switch(v.op){case"Max":{const oe=x("axis",v,p,g),Ue=x("keepDims",v,p,g);return[C.max(x("x",v,p,g),oe,Ue)]}case"Mean":{const oe=x("axis",v,p,g),Ue=x("keepDims",v,p,g);return[C.mean(x("x",v,p,g),oe,Ue)]}case"Min":{const oe=x("axis",v,p,g),Ue=x("keepDims",v,p,g);return[C.min(x("x",v,p,g),oe,Ue)]}case"Sum":{const oe=x("axis",v,p,g),Ue=x("keepDims",v,p,g);return[C.sum(x("x",v,p,g),oe,Ue)]}case"All":{const oe=x("axis",v,p,g),Ue=x("keepDims",v,p,g);return[C.all(x("x",v,p,g),oe,Ue)]}case"Any":{const oe=x("axis",v,p,g),Ue=x("keepDims",v,p,g);return[C.any(x("x",v,p,g),oe,Ue)]}case"ArgMax":{const oe=x("axis",v,p,g);return[C.argMax(x("x",v,p,g),oe)]}case"ArgMin":{const oe=x("axis",v,p,g);return[C.argMin(x("x",v,p,g),oe)]}case"Prod":{const oe=x("axis",v,p,g),Ue=x("keepDims",v,p,g);return[C.prod(x("x",v,p,g),oe,Ue)]}case"Cumprod":{const oe=x("axis",v,p,g),Ue=x("exclusive",v,p,g),ut=x("reverse",v,p,g);return[C.cumprod(x("x",v,p,g),oe,Ue,ut)]}case"Cumsum":{const oe=x("axis",v,p,g),Ue=x("exclusive",v,p,g),ut=x("reverse",v,p,g);return[C.cumsum(x("x",v,p,g),oe,Ue,ut)]}case"Bincount":const G=x("x",v,p,g),K=x("weights",v,p,g),ae=x("size",v,p,g);return[C.bincount(G,K,ae)];case"DenseBincount":{const oe=x("x",v,p,g),Ue=x("weights",v,p,g),ut=x("size",v,p,g),tt=x("binaryOutput",v,p,g);return[C.denseBincount(oe,Ue,ut,tt)]}default:throw TypeError(`Node type ${v.op} is not implemented`)}},Br=(v,p,g,C=ke)=>{switch(v.op){case"ConcatV2":case"Concat":{const G=x("n",v,p,g),K=x("axis",v,p,g);let ae=x("tensors",v,p,g);return ae=ae.slice(0,G),[C.concat(ae,K)]}case"Gather":{const G=x("x",v,p,g),K=x("indices",v,p,g);return[C.gather(G,C.cast(K,"int32"),0)]}case"GatherV2":{const G=x("axis",v,p,g),K=x("batchDims",v,p,g),ae=x("x",v,p,g),oe=x("indices",v,p,g);return[C.gather(ae,C.cast(oe,"int32"),G,K)]}case"Reverse":{const G=x("dims",v,p,g),K=[];for(let oe=0;oe<G.length;oe++)G[oe]&&K.push(oe);const ae=x("x",v,p,g);return[C.reverse(ae,K)]}case"ReverseV2":{const G=x("axis",v,p,g),K=x("x",v,p,g);return[C.reverse(K,G)]}case"Slice":{const G=x("begin",v,p,g),K=x("size",v,p,g);return[C.slice(x("x",v,p,g),G,K)]}case"StridedSlice":{const G=x("begin",v,p,g),K=x("end",v,p,g),ae=x("strides",v,p,g),oe=x("beginMask",v,p,g),Ue=x("endMask",v,p,g),ut=x("ellipsisMask",v,p,g),tt=x("newAxisMask",v,p,g),Je=x("shrinkAxisMask",v,p,g),bt=x("x",v,p,g);return[C.stridedSlice(bt,G,K,ae,oe,Ue,ut,tt,Je)]}case"Pack":return(0,Oe.tidy)(()=>{const G=x("axis",v,p,g),K=x("tensors",v,p,g),ae=K[0].shape,oe=C.squeeze(K[0]).shape,Ue=K.map(ut=>{const tt=Oe.util.arraysEqual(ut.shape,ae);if(!tt&&!Oe.util.arraysEqual(C.squeeze(ut).shape,oe))throw new Error("the input tensors shape does not match");return tt?ut:C.reshape(ut,ae)});return[C.stack(Ue,G)]});case"Unpack":{const G=x("axis",v,p,g),K=x("tensor",v,p,g);return C.unstack(K,G)}case"Tile":{const G=x("reps",v,p,g);return[C.tile(x("x",v,p,g),G)]}case"Split":case"SplitV":{const G=x("axis",v,p,g),K=x("numOrSizeSplits",v,p,g),ae=x("x",v,p,g);return C.split(ae,K,G)}case"ScatterNd":{const G=x("indices",v,p,g),K=x("values",v,p,g),ae=x("shape",v,p,g);return[C.scatterND(G,K,ae)]}case"GatherNd":{const G=x("x",v,p,g),K=x("indices",v,p,g);return[C.gatherND(G,K)]}case"SparseToDense":{const G=x("sparseIndices",v,p,g),K=x("outputShape",v,p,g),ae=x("sparseValues",v,p,g),oe=x("defaultValue",v,p,g);return[C.sparseToDense(G,ae,K,ae.dtype===oe.dtype?oe:C.cast(oe,ae.dtype))]}default:throw TypeError(`Node type ${v.op} is not implemented`)}},Si=(v,p,g,C=ke)=>{switch(v.op){case"SparseFillEmptyRows":{const{outputIndices:G,outputValues:K,emptyRowIndicator:ae,reverseIndexMap:oe}=C.sparse.sparseFillEmptyRows(x("indices",v,p,g),x("values",v,p,g),x("denseShape",v,p,g),x("defaultValue",v,p,g));return[G,K,ae,oe]}case"SparseReshape":{const{outputIndices:G,outputShape:K}=C.sparse.sparseReshape(x("inputIndices",v,p,g),x("inputShape",v,p,g),x("newShape",v,p,g));return[G,K]}case"SparseSegmentMean":return[C.sparse.sparseSegmentMean(x("data",v,p,g),x("indices",v,p,g),x("segmentIds",v,p,g))];case"SparseSegmentSum":return[C.sparse.sparseSegmentSum(x("data",v,p,g),x("indices",v,p,g),x("segmentIds",v,p,g))];default:throw TypeError(`Node type ${v.op} is not implemented`)}},Ss=(v,p,g,C=ke)=>{switch(v.op){case"FFT":return[C.fft(x("x",v,p,g))];case"IFFT":return[C.ifft(x("x",v,p,g))];case"RFFT":return[C.rfft(x("x",v,p,g))];case"IRFFT":return[C.irfft(x("x",v,p,g))];default:throw TypeError(`Node type ${v.op} is not implemented`)}},Gi=(v,p,g,C=ke)=>{switch(v.op){case"StringNGrams":{const{nGrams:G,nGramsSplits:K}=C.string.stringNGrams(x("data",v,p,g),x("dataSplits",v,p,g),x("separator",v,p,g),x("nGramWidths",v,p,g),x("leftPad",v,p,g),x("rightPad",v,p,g),x("padWidth",v,p,g),x("preserveShortSequences",v,p,g));return[G,K]}case"StringSplit":{const{indices:G,values:K,shape:ae}=C.string.stringSplit(x("input",v,p,g),x("delimiter",v,p,g),x("skipEmpty",v,p,g));return[G,K,ae]}case"StringToHashBucketFast":return[C.string.stringToHashBucketFast(x("input",v,p,g),x("numBuckets",v,p,g))];default:throw TypeError(`Node type ${v.op} is not implemented`)}},mn=(v,p,g,C=ke)=>{switch(v.op){case"Cast":return[C.cast(x("x",v,p,g),x("dtype",v,p,g))];case"ExpandDims":{const G=x("axis",v,p,g);return[C.expandDims(x("x",v,p,g),G)]}case"Squeeze":{const G=x("axis",v,p,g);return[C.squeeze(x("x",v,p,g),G)]}case"Reshape":return[C.reshape(x("x",v,p,g),x("shape",v,p,g))];case"MirrorPad":return[C.mirrorPad(x("x",v,p,g),x("padding",v,p,g),x("mode",v,p,g))];case"PadV2":case"Pad":return[C.pad(x("x",v,p,g),x("padding",v,p,g),x("constantValue",v,p,g))];case"SpaceToBatchND":{const G=x("blockShape",v,p,g),K=x("paddings",v,p,g);return[C.spaceToBatchND(x("x",v,p,g),G,K)]}case"BatchToSpaceND":{const G=x("blockShape",v,p,g),K=x("crops",v,p,g);return[C.batchToSpaceND(x("x",v,p,g),G,K)]}case"DepthToSpace":{const G=x("blockSize",v,p,g),K=x("dataFormat",v,p,g).toUpperCase();return[C.depthToSpace(x("x",v,p,g),G,K)]}case"BroadcastTo":return[C.broadcastTo(x("x",v,p,g),x("shape",v,p,g))];case"BroadcastArgs":return[C.broadcastArgs(x("s0",v,p,g),x("s1",v,p,g))];default:throw TypeError(`Node type ${v.op} is not implemented`)}};function Ei(v,p,g,C,G=Oe.tidy){const K=((ae,oe,Ue)=>{switch(ae.category){case"arithmetic":return G(()=>Ur(ae,oe,Ue));case"basic_math":return G(()=>Bn(ae,oe,Ue));case"control":return pn(ae,oe,Ue);case"convolution":return G(()=>$a(ae,oe,Ue));case"creation":return G(()=>Us(ae,oe,Ue));case"dynamic":return Fa(ae,oe,Ue);case"evaluation":return G(()=>ts(ae,oe,Ue));case"image":return G(()=>Hi(ae,oe,Ue));case"graph":return G(()=>Pa(ae,oe,Ue));case"logical":return G(()=>Qn(ae,oe,Ue));case"matrices":return G(()=>ji(ae,oe,Ue));case"normalization":return G(()=>vn(ae,oe,Ue));case"reduction":return G(()=>Ws(ae,oe,Ue));case"slice_join":return G(()=>Br(ae,oe,Ue));case"sparse":return G(()=>Si(ae,oe,Ue));case"spectral":return G(()=>Ss(ae,oe,Ue));case"string":return G(()=>Gi(ae,oe,Ue));case"transformation":return G(()=>mn(ae,oe,Ue));case"hash_table":return La(ae,oe,Ue,C);case"custom":const ut=be(ae.op);if(ut&&ut.customExecutor)return ut.customExecutor(new Ro(ae,oe,Ue));throw TypeError(`Custom op ${ae.op} is not registered.`);default:throw TypeError(`Unknown op '${ae.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(v,p,g);return Oe.util.isPromise(K)?K.then(ae=>[].concat(ae)):[].concat(K)}class Kr{constructor(p={},g={},C={},G={}){this.weightMap=p,this.tensorArrayMap=g,this.tensorListMap=C,this.functionMap=G,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(p,g){return{id:p,frameName:g,iterationId:0}}set currentContext(p){this.contexts!==p&&(this.contexts=p,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const p=[];for(let g=0;g<this.contexts.length-1;g++){const C=this.contexts.slice(0,this.contexts.length-g);p.push(this.contextIdforContexts(C))}p.push(""),this._currentContextIds=p}contextIdforContexts(p){return p?p.map(g=>0===g.id&&0===g.iterationId?"":`${g.frameName}-${g.iterationId}`).join("/"):""}enterFrame(p){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,p)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const p=Object.assign({},this.contexts[this.contexts.length-1]);p.iterationId+=1,p.id=this.lastId,this.contexts.splice(-1,1,p),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(p){return this.weightMap[p]}addTensorArray(p){this.tensorArrayMap[p.id]=p}getTensorArray(p){return this.tensorArrayMap[p]}addTensorList(p){this.tensorListMap[p.id]=p}getTensorList(p){return this.tensorListMap[p]}dispose(p){for(const g in this.tensorArrayMap)this.tensorArrayMap[g].clearAndClose(p);for(const g in this.tensorListMap)this.tensorListMap[g].clearAndClose(p)}}function $o(v,p,g,C){const G=new Set,K=[];let ae=null,oe=null;const Ue=new Set,ut=Object.keys(v).map(bt=>et(bt)[0]);let tt=[];null!=C&&(tt=C.map(bt=>et(bt.name)[0]));const Je=[...p];for(;Je.length>0;){const bt=Je.pop();if((ao(bt)||_(bt)||V(bt))&&null==ae&&(ae=bt,oe=ae.children.map(Wt=>Wt.name).filter(Wt=>G.has(Wt))),G.add(bt.name),null==g[bt.name]&&-1===ut.indexOf(bt.name)&&-1===tt.indexOf(bt.name)){if(0===bt.inputs.length){K.push(bt.name);continue}bt.inputs.forEach(Wt=>{Ue.has(Wt.name)||(Ue.add(Wt.name),Je.push(Wt))})}}return{inputs:v,outputs:p,usedNodes:G,missingInputs:K,dynamicNode:ae,syncInputs:oe}}const fr=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Fo=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Va=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function ao(v){return fr.indexOf(v.op)>=0}function _(v){return Fo.indexOf(v.op)>=0}function V(v){return Va.indexOf(v.op)>=0}class U{constructor(p,g){this.graph=p,this.parent=g,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=p.outputs,this._inputs=p.inputs,this._initNodes=p.initNodes,this._signature=p.signature,this._functions=p.functions,null!=p.functions&&Object.keys(p.functions).forEach(C=>{this._functionExecutorMap[C]=new U(p.functions[C],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(p){const g=Object.keys(p).map(C=>p[C].map(G=>G.id));this._weightIds=[].concat(...g),this._weightMap=p}set resourceManager(p){this._resourceManager=p}get inputs(){return this._inputs.map(p=>({name:p.name,shape:p.attrParams.shape?p.attrParams.shape.value:void 0,dtype:p.attrParams.dtype?p.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(p=>({name:p.name,shape:p.attrParams.shape?p.attrParams.shape.value:void 0,dtype:p.attrParams.dtype?p.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(p=>p.signatureKey||p.name)}get outputNodes(){return this._outputs.map(p=>{const g=p.signatureKey||p.name;return p.defaultOutput?`${g}:${p.defaultOutput}`:g})}get functions(){return Object.keys(this._functions).reduce((p,g)=>(p[g]=this._functions[g].signature,p),{})}getCompilationKey(p,g){const C=p.map(K=>K.name).sort(),G=g.map(K=>K.name).sort();return C.join(this.SEPERATOR)+"--"+G.join(this.SEPERATOR)}compile(p,g){const C=$o(p,g,this.weightMap,this._initNodes),{missingInputs:G,dynamicNode:K,syncInputs:ae}=C;if(null!=K)throw new Error(`This execution contains the node '${K.name}', which has the dynamic op '${K.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${ae}]`);if(G.length>0){const oe=g.map(ut=>ut.name),Ue=Object.keys(p);throw new Error(`Cannot compute the outputs [${oe}] from the provided inputs [${Ue}]. Missing the following inputs: [${G}]`)}return function ma(v,p,g){const{usedNodes:C,inputs:G}=g,K=[],ae=Object.keys(G).map(tt=>et(tt)[0]).map(tt=>v.nodes[tt]),oe=v.initNodes;ae.forEach(tt=>{C.has(tt.name)&&K.push(tt)}),v.weights.forEach(tt=>{C.has(tt.name)&&K.push(tt)}),oe?.forEach(tt=>{C.has(tt.name)&&K.push(tt)});const Ue=new Set,ut=[];for(;K.length>0;){const tt=K.pop();Ue.add(tt.name),p[tt.name]||ut.push(tt),tt.children.forEach(Je=>{!Ue.has(Je.name)&&C.has(Je.name)&&Je.inputs.every(bt=>Ue.has(bt.name))&&K.push(Je)})}return ut}(this.graph,this.weightMap,C)}execute(p,g){p=this.mapInputs(p);const C=Object.keys(p).sort();this.checkInputs(p),this.checkInputShapeAndType(p),g=this.mapOutputs(g),this.checkOutputs(g);const G=C.map(Je=>this.graph.nodes[et(Je)[0]]),K=g.map(Je=>et(Je)[0]);let ae=K.map(Je=>this.graph.nodes[Je]);this.resetIntermediateTensors(),0===ae.length&&(ae=this._outputs);const oe=this.getCompilationKey(G,ae);let Ue=this.compiledMap.get(oe);null==Ue&&(Ue=this.compile(p,ae),this.compiledMap.set(oe,Ue));const ut={},tt={};return(0,Oe.tidy)(()=>{const Je=new Kr(this.weightMap,ut,tt,this.functionExecutorMap),bt=Object.assign({},this.weightMap);Object.keys(p).forEach(Ht=>{const[ln,xr]=et(Ht),zs=[];zs[xr]=p[Ht],bt[ln]=zs});const Wt=this.getFrozenTensorIds(bt),Gt={};for(let Ht=0;Ht<Ue.length;Ht++){const ln=Ue[Ht];if(!bt[ln.name]){const xr=Ei(ln,bt,Je,this._resourceManager);if(Oe.util.isPromise(xr))throw new Error(`The execution of the op '${ln.op}' returned a promise. Please use model.executeAsync() instead.`);bt[ln.name]=xr,this.checkTensorForDisposal(ln.name,ln,bt,Je,Wt,K,Gt)}}return null==this.parent&&Je.dispose(Wt),g.map(Ht=>He(Ht,bt,Je))})}getFrozenTensorIds(p){const g=[].concat.apply([],Object.keys(p).map(C=>p[C]).map(C=>C.map(G=>G.id)));return new Set(g)}checkTensorForDisposal(p,g,C,G,K,ae,oe){"control"===g.category||-1!==ae.indexOf(p)||(C[p].forEach(Ue=>{null!=Ue&&(oe[Ue.id]=(oe[Ue.id]||0)+g.children.length)}),g.inputs.forEach(Ue=>{if("control"!==Ue.category){const ut=function Me(v,p,g){return p[nt(v,g.currentContextId)]}(Ue.name,C,G);ut?.forEach(tt=>{if(tt&&!tt.kept&&!K.has(tt.id)){const Je=oe[tt.id];if(1===Je){if(this.keepTensorForDebug){const[bt,Wt]=We(g.name,G);this.intermediateTensors[bt]||(this.intermediateTensors[bt]=[]),this.intermediateTensors[bt][Wt]=tt}else tt.dispose();delete oe[tt.id]}else null!=Je&&oe[tt.id]--}})}}))}executeAsync(p,g){var C=this;return(0,$e.Z)(function*(){return C._executeAsync(p,g)})()}disposeIntermediateTensors(){this.intermediateTensors&&(Object.keys(this.intermediateTensors).forEach(p=>this.intermediateTensors[p].forEach(g=>g.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){this.tensorsMap&&Object.keys(this.tensorsMap).forEach(p=>{this.tensorsMap[p].forEach(C=>{C&&!C.kept&&!C.isDisposed&&!this.keepIds.has(C.id)&&C.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const p in this.intermediateTensors)this.intermediateTensors[p].forEach(g=>g.dispose()),delete this.intermediateTensors[p]}_executeAsync(p,g,C=!1,G={},K={}){var ae=this;return(0,$e.Z)(function*(){C||(p=ae.mapInputs(p),ae.checkInputs(p),ae.checkInputShapeAndType(p),g=ae.mapOutputs(g),ae.checkOutputs(g));try{ae.keepTensorForDebug=(0,Oe.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(Je){console.warn(Je.message)}ae.resetIntermediateTensors();const oe=new Kr(ae.weightMap,G,K,ae.functionExecutorMap);ae.tensorsMap=yield ae.executeWithControlFlow(p,oe,g,C);const Ue=g.map(Je=>He(Je,ae.tensorsMap,oe)),ut=Ue.map(Je=>Je.id),tt=Object.keys(p).map(Je=>p[Je].id);return ae.keepIds=new Set([...ut,...tt,...ae.weightIds]),ae.keepTensorForDebug||ae.disposeTensorsMap(),null==ae.parent&&oe.dispose(ae.keepIds),Ue})()}executeFunctionAsync(p,g,C){var G=this;return(0,$e.Z)(function*(){const K=p.reduce((ae,oe,Ue)=>(ae[G.inputs[Ue].name]=oe,ae),{});return G._executeAsync(K,G.outputNodes,!0,g,C)})()}executeWithControlFlow(p,g,C,G){var K=this;return(0,$e.Z)(function*(){const ae=Object.keys(p),oe=ae.map(kr=>K.graph.nodes[et(kr)[0]]),Ue=C.map(kr=>et(kr)[0]);let ut=Ue.map(kr=>K.graph.nodes[kr]);0===ut.length&&(ut=K._outputs);const{usedNodes:tt,missingInputs:Je,dynamicNode:bt,syncInputs:Wt}=$o(p,ut,K.weightMap,K._initNodes),Gt=[...oe,...K.graph.weights,...K._initNodes||[]].map(kr=>({node:kr,contexts:g.currentContext})),Ht=Object.assign({},K.weightMap);Object.keys(p).forEach(kr=>{const[Po,_i]=et(kr),Hs=[];Hs[_i]=p[kr],Ht[Po]=Hs});const ln={},xr=K.getFrozenTensorIds(Ht),zs={};for(;Gt.length>0;){const kr=K.processStack(oe,Gt,g,Ht,zs,xr,Ue,ln,tt);yield Promise.all(kr)}null==bt&&!G&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const ns=ut.filter(kr=>!ao(kr)&&!He(kr.name,Ht,g)).map(kr=>kr.name);if(ns.length>0){let kr="";throw null!=bt&&(kr=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${Wt}]`),new Error(`Cannot compute the outputs [${ns}] from the provided inputs [${ae}]. Consider providing the following inputs: [${Je}]. ${kr}`)}return Ht})()}processStack(p,g,C,G,K,ae,oe,Ue,ut){const tt=[];for(;g.length>0;){const Je=g.pop();C.currentContext=Je.contexts;let bt="";if("Enter"===Je.node.op&&x("isConstant",Je.node,G,C)&&([bt]=We(Je.node.name,C)),null==G[Je.node.name]){const Wt=Ei(Je.node,G,C,this._resourceManager);bt||([bt]=We(Je.node.name,C));const Gt=C.currentContext;Oe.util.isPromise(Wt)?tt.push(Wt.then(Ht=>(G[bt]=Ht,C.currentContext=Gt,this.checkTensorForDisposal(bt,Je.node,G,C,ae,oe,Ue),this.processChildNodes(Je.node,g,C,G,K,ut),Ht))):(G[bt]=Wt,this.checkTensorForDisposal(bt,Je.node,G,C,ae,oe,Ue),this.processChildNodes(Je.node,g,C,G,K,ut))}else this.processChildNodes(Je.node,g,C,G,K,ut)}return tt}processChildNodes(p,g,C,G,K,ae){p.children.forEach(oe=>{const[Ue]=We(oe.name,C);K[Ue]||!ae.has(oe.name)||("Merge"===oe.op?oe.inputNames.some(ut=>!!He(ut,G,C))&&(K[Ue]=!0,g.push({contexts:C.currentContext,node:oe})):oe.inputNames.every(ut=>!!He(ut,G,C))&&(K[Ue]=!0,g.push({contexts:C.currentContext,node:oe})))})}dispose(){Object.keys(this.weightMap).forEach(p=>this.weightMap[p].forEach(g=>g.dispose()))}checkInputShapeAndType(p){Object.keys(p).forEach(g=>{const C=p[g],[G]=et(g),K=this.graph.nodes[G];if(K.attrParams.shape&&K.attrParams.shape.value){const ae=K.attrParams.shape.value,oe=ae.length===C.shape.length&&C.shape.every((Ue,ut)=>-1===ae[ut]||ae[ut]===Ue);Oe.util.assert(oe,()=>`The shape of dict['${K.name}'] provided in model.execute(dict) must be [${ae}], but was [${C.shape}]`)}K.attrParams.dtype&&K.attrParams.dtype.value&&Oe.util.assert(C.dtype===K.attrParams.dtype.value,()=>`The dtype of dict['${K.name}'] provided in model.execute(dict) must be ${K.attrParams.dtype.value}, but was ${C.dtype}`)})}mapInputs(p){const g={};for(const C in p)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[C]?g[this._signature.inputs[C].name]=p[C]:g[C]=p[C];return g}checkInputs(p){const g=Object.keys(p).filter(C=>{const[G]=et(C);return null==this.graph.nodes[G]});if(g.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${g}] that are not part of graph`)}mapOutputs(p){return p.map(g=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[g]?this._signature.outputs[g].name:g,{})}checkOutputs(p){p.forEach(g=>{const[C]=et(g);if(!this.graph.nodes[C])throw new Error(`The output '${g}' is not found in the graph`)})}}class he{constructor(p={},g={}){this.hashTableNameToHandle=p,this.hashTableMap=g}addHashTable(p,g){this.hashTableNameToHandle[p]=g.handle,this.hashTableMap[g.id]=g}getHashTableHandleByName(p){return this.hashTableNameToHandle[p]}getHashTableById(p){return this.hashTableMap[p]}dispose(){for(const p in this.hashTableMap)this.hashTableMap[p].clearAndClose(),delete this.hashTableMap[p];for(const p in this.hashTableNameToHandle)this.hashTableNameToHandle[p].dispose(),delete this.hashTableNameToHandle[p]}}const qe="?tfjs-format=file",ct="model.json";class je{constructor(p,g={},C=Oe.io){this.modelUrl=p,this.loadOptions=g,this.version="n/a",this.io=C,null==g&&(this.loadOptions={}),this.resourceManager=new he}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const p=this.modelUrl;if(null!=p.load)this.handler=p;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(p,this.loadOptions);else{const g=this.io.getLoadHandlers(p,this.loadOptions);if(0===g.length)g.push(this.io.browserHTTPRequest(p,this.loadOptions));else if(g.length>1)throw new Error(`Found more than one (${g.length}) load handlers for URL '${[p]}'`);this.handler=g[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const p=this.handler.load();return Oe.util.isPromise(p)?p.then(g=>this.loadSync(g)):this.loadSync(p)}loadSync(p){this.artifacts=p;const g=this.artifacts.modelTopology;let C=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const K=this.artifacts.userDefinedMetadata;null!=K.signature&&(C=K.signature),null!=K.structuredOutputKeys&&(this.structuredOutputKeys=K.structuredOutputKeys)}this.signature=C,this.version=`${g.versions.producer}.${g.versions.minConsumer}`;const G=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new U(_r.Instance.transformGraph(g,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(G),this.executor.resourceManager=this.resourceManager,null!=p.modelInitializer&&null!=p.modelInitializer.node){const K=_r.Instance.transformGraph(p.modelInitializer);this.initializer=new U(K),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}save(p,g){var C=this;return(0,$e.Z)(function*(){if("string"==typeof p){const G=C.io.getSaveHandlers(p);if(0===G.length)throw new Error(`Cannot find any save handlers for URL '${p}'`);if(G.length>1)throw new Error(`Found more than one (${G.length}) save handlers for URL '${p}'`);p=G[0]}if(null==p.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return p.save(C.artifacts)})()}predict(p,g){const C=this.execute(p,this.outputNodes);if(this.structuredOutputKeys){const K={};return(C instanceof Oe.Tensor?[C]:C).forEach((ae,oe)=>K[this.structuredOutputKeys[oe]]=ae),K}return C}normalizeInputs(p){if(!(p instanceof Oe.Tensor||Array.isArray(p)))return p;if((p=Array.isArray(p)?p:[p]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${p.length} input tensors.`);return this.inputNodes.reduce((g,C,G)=>(g[C]=p[G],g),{})}normalizeOutputs(p){return p=p||this.outputNodes,Array.isArray(p)?p:[p]}execute(p,g){p=this.normalizeInputs(p),g=this.normalizeOutputs(g);const C=this.executor.execute(p,g);return C.length>1?C:C[0]}executeAsync(p,g){var C=this;return(0,$e.Z)(function*(){p=C.normalizeInputs(p),g=C.normalizeOutputs(g);const G=yield C.executor.executeAsync(p,g);return G.length>1?G:G[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(p){return Object.keys(p).reduce((g,C)=>(g[C]=[p[C]],g),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}function at(v){return ge.apply(this,arguments)}function ge(){return(ge=(0,$e.Z)(function*(v,p={},g=Oe.io){if(null==v)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==p&&(p={}),p.fromTFHub&&"string"==typeof v&&(v=function kt(v){return v.endsWith("/")||(v+="/"),`${v}${ct}${qe}`}(v));const C=new je(v,p,g);return yield C.load(),C})).apply(this,arguments)}function Lt(v){if(null==v)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let p;if(v instanceof Array){const[C,G]=v;if(!C)throw new Error("modelJSON must be the first element of the array");if(!(G&&G instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in C))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in C))throw new Error("Model JSON is missing 'weightsManifest'");const K=Oe.io.getWeightSpecs(C.weightsManifest),ae=Oe.io.getModelArtifactsForJSONSync(C,K,G);p=Oe.io.fromMemorySync(ae)}else if("load"in v)p=v;else{if(!("modelTopology"in v&&"weightSpecs"in v&&"weightData"in v))throw new Error("Unknown model format");p=Oe.io.fromMemorySync(v)}const g=new je(p);return g.load(),g}const Un="3.21.0"},7872:(gt,Xe,M)=>{"use strict";M.d(Xe,{JL:()=>te,Zu:()=>Q});class te{constructor(Ie,me){this.backend=Ie,this.dataMover=me,this.data=new WeakMap,this.dataIdsCount=0}get(Ie){return this.data.has(Ie)||this.dataMover.moveData(this.backend,Ie),this.data.get(Ie)}set(Ie,me){this.dataIdsCount++,this.data.set(Ie,me)}has(Ie){return this.data.has(Ie)}delete(Ie){return this.dataIdsCount--,this.data.delete(Ie)}numDataIds(){return this.dataIdsCount}}class Q{refCount(Ie){return F("refCount")}incRef(Ie){return F("incRef")}timerAvailable(){return!0}time(Ie){return F("time")}read(Ie){return F("read")}readSync(Ie){return F("readSync")}readToGPU(Ie,me){return F("readToGPU")}numDataIds(){return F("numDataIds")}disposeData(Ie,me){return F("disposeData")}write(Ie,me,Y){return F("write")}move(Ie,me,Y,le,ee){return F("move")}memory(){return F("memory")}floatPrecision(){return F("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return F("dispose")}}function F(j){throw new Error(`'${j}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},152:(gt,Xe,M)=>{"use strict";function _e(A,de,Pe){const xe=function we(A,de,Pe){return function Q(A,de,Pe){let xe=0,Ze=A.length,ot=0,St=!1;for(;xe<Ze;){ot=xe+(Ze-xe>>>1);const Vt=Pe(de,A[ot]);Vt>0?xe=ot+1:(Ze=ot,St=!Vt)}return St?xe:-xe-1}(A,de,Pe||te)}(A,de,Pe);A.splice(xe<0?-(xe+1):xe,0,de)}function te(A,de){return A>de?1:A<de?-1:0}function F(A,de,Pe,xe,Ze){return me(A,de,Pe,xe,Ze,0)}function j(A,de,Pe,xe,Ze,ot){return me(A,de,Pe,xe,Ze,0,!1,ot,!0)}function Ie(A,de,Pe,xe,Ze,ot){return me(A,de,Pe,xe,Ze,ot,!0)}function me(A,de,Pe,xe,Ze,ot,St=!1,Vt=!1,ke=!1){const Oe=[];for(let be=0;be<de.length;be++)de[be]>Ze&&Oe.push({score:de[be],boxIndex:be,suppressBeginIndex:0});Oe.sort(ee);const It=ot>0?-.5/ot:0,$e=[],Ce=[];for(;$e.length<Pe&&Oe.length>0;){const be=Oe.pop(),{score:ce,boxIndex:x,suppressBeginIndex:He}=be;if(ce<Ze)break;let Me=!1;for(let We=$e.length-1;We>=He;--We){const nt=Y(A,x,$e[We]);if(nt>=xe){Me=!0;break}if(be.score=be.score*le(xe,It,nt),be.score<=Ze)break}be.suppressBeginIndex=$e.length,Me||(be.score===ce?($e.push(x),Ce.push(be.score)):be.score>Ze&&_e(Oe,be,ee))}const ye=$e.length,$=Pe-ye;Vt&&$>0&&($e.push(...new Array($).fill(0)),Ce.push(...new Array($).fill(0)));const se={selectedIndices:$e};return St&&(se.selectedScores=Ce),ke&&(se.validOutputs=ye),se}function Y(A,de,Pe){const xe=A.subarray(4*de,4*de+4),Ze=A.subarray(4*Pe,4*Pe+4),ot=Math.min(xe[0],xe[2]),St=Math.min(xe[1],xe[3]),Vt=Math.max(xe[0],xe[2]),ke=Math.max(xe[1],xe[3]),Oe=Math.min(Ze[0],Ze[2]),It=Math.min(Ze[1],Ze[3]),$e=Math.max(Ze[0],Ze[2]),Ce=Math.max(Ze[1],Ze[3]),ye=(Vt-ot)*(ke-St),$=($e-Oe)*(Ce-It);if(ye<=0||$<=0)return 0;const se=Math.max(ot,Oe),be=Math.max(St,It),ce=Math.min(Vt,$e),x=Math.min(ke,Ce),He=Math.max(ce-se,0)*Math.max(x-be,0);return He/(ye+$-He)}function le(A,de,Pe){const xe=Math.exp(de*Pe*Pe);return Pe<=A?xe:0}function ee(A,de){return A.score-de.score||A.score===de.score&&de.boxIndex-A.boxIndex}M.d(Xe,{GP:()=>F,qP:()=>j,pA:()=>Ie})},2842:(gt,Xe,M)=>{"use strict";M.d(Xe,{Z:()=>we});var _e=M(8621);function we(te,Q){const F=[];for(let me=0;me<Q.length;me++)Q[me]&&F.push(me);const j=(0,_e.f)(te,"int32"),Ie=(0,_e.f)([F.length,te.length],"int32");for(let me=0;me<F.length;me++){const Y=j.indexToLoc(F[me]);Ie.values.set(Y,me*te.length)}return Ie.toTensor()}},3738:(gt,Xe,M)=>{"use strict";M.d(Xe,{BV:()=>It,wv:()=>Oe});var _e=M(5861),we=M(7872),te=M(1777),Q=M(6422),F=M(1070),j=M(9464),Ie=M(5686),me=M(8813),Y=M(1396);class le{constructor(ye,$){this.backendTimer=ye,this.logger=$,null==$&&(this.logger=new A)}profileKernel(ye,$,se){let be;const ce=()=>{be=se()};let x;const He=me.now();if(this.backendTimer.timerAvailable())x=this.backendTimer.time(ce);else{ce();for(const We of be)We.dataSync();x=Promise.resolve({kernelMs:me.now()-He})}if((0,te.OB)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let We=0;We<be.length;We++){const nt=be[We];nt.data().then(et=>{ee(et,nt.dtype,ye)})}return{kernelName:ye,outputs:be,inputs:$,timeMs:x.then(We=>We.kernelMs),extraInfo:x.then(We=>null!=We.getExtraProfileInfo?We.getExtraProfileInfo():"")}}logKernelProfile(ye){const{kernelName:$,outputs:se,timeMs:be,inputs:ce,extraInfo:x}=ye;se.forEach(He=>{Promise.all([He.data(),be,x]).then(Me=>{this.logger.logKernelProfile($,He,Me[0],Me[1],ce,Me[2])})})}}function ee(Ce,ye,$){if("float32"!==ye)return!1;for(let se=0;se<Ce.length;se++){const be=Ce[se];if(isNaN(be)||!isFinite(be))return console.warn(`Found ${be} in the result of '${$}'`),!0}return!1}class A{logKernelProfile(ye,$,se,be,ce,x){const He="number"==typeof be?Y.oj(`${be}ms`,9):be.error,Me=Y.oj(ye,25),We=$.rank,nt=$.size,et=Y.oj($.shape.toString(),14);let Ve="";for(const Ft in ce){const Yt=ce[Ft];if(null!=Yt){const Zt=Yt.shape||$.shape,yn=Zt.length;Ve+=`${Ft}: ${yn}D ${yn>0?Zt:""} `}}console.log(`%c${Me}\t%c${He}\t%c${We}D ${et}\t%c${nt}\t%c${Ve}\t%c${x}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var xe=M(708),Ze=M(7904);function ot(Ce){return null!=Ce.kernelName}class St{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(ye=>ye.name)))}}}dispose(){for(const ye in this.registeredVariables)this.registeredVariables[ye].dispose()}}let Vt=(()=>{class Ce{constructor($){this.ENV=$,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new St}ready(){var $=this;return(0,_e.Z)(function*(){if(null!=$.pendingBackendInit)return $.pendingBackendInit.then(()=>{});if(null!=$.backendInstance)return;const se=$.getSortedBackends();for(let be=0;be<se.length;be++){const ce=se[be];if(yield $.initializeBackend(ce).success)return void(yield $.setBackend(ce))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:$,asyncInit:se}=this.initializeBackendsAndReturnBest();if(se)throw new Error(`The highest priority backend '${$}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend($)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend($){if(!($ in this.registry)){if(!($ in this.registryFactory))return null;{const{asyncInit:se}=this.initializeBackend($);if(se)return null}}return this.registry[$]}findBackendFactory($){return $ in this.registryFactory?this.registryFactory[$].factory:null}registerBackend($,se,be=1){return $ in this.registryFactory?(Ie.Z(`${$} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[$]={factory:se,priority:be},!0)}setBackend($){var se=this;return(0,_e.Z)(function*(){if(null==se.registryFactory[$])throw new Error(`Backend name '${$}' not found in registry`);if(se.backendName=$,null==se.registry[$]){se.backendInstance=null;const{success:be,asyncInit:ce}=se.initializeBackend($);if(!(ce?yield be:be))return!1}return se.backendInstance=se.registry[$],se.setupRegisteredKernels(),se.profiler=new le(se.backendInstance),!0})()}setupRegisteredKernels(){(0,j.tr)(this.backendName).forEach(se=>{null!=se.setupFunc&&se.setupFunc(this.backendInstance)})}disposeRegisteredKernels($){(0,j.tr)($).forEach(be=>{null!=be.disposeFunc&&be.disposeFunc(this.registry[$])})}initializeBackend($){const se=this.registryFactory[$];if(null==se)throw new Error(`Cannot initialize backend ${$}, no registration found.`);try{const be=se.factory();if(!be||be instanceof we.Zu||"function"!=typeof be.then)return this.registry[$]=be,{success:!0,asyncInit:!1};{const ce=++this.pendingBackendInitId,x=be.then(He=>!(ce<this.pendingBackendInitId||(this.registry[$]=He,this.pendingBackendInit=null,0))).catch(He=>(ce<this.pendingBackendInitId||(this.pendingBackendInit=null,Ie.Z(`Initialization of backend ${$} failed`),Ie.Z(He.stack||He.message)),!1));return this.pendingBackendInit=x,{success:x,asyncInit:!0}}}catch(be){return Ie.Z(`Initialization of backend ${$} failed`),Ie.Z(be.stack||be.message),{success:!1,asyncInit:!1}}}removeBackend($){if(!($ in this.registryFactory))throw new Error(`${$} backend not found in registry`);this.backendName===$&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,$ in this.registry&&(this.disposeRegisteredKernels($),this.registry[$].dispose(),delete this.registry[$]),delete this.registryFactory[$],this.backendName===$&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(($,se)=>this.registryFactory[se].priority-this.registryFactory[$].priority)}initializeBackendsAndReturnBest(){const $=this.getSortedBackends();for(let se=0;se<$.length;se++){const be=$[se],{success:ce,asyncInit:x}=this.initializeBackend(be);if(x||ce)return{name:be,asyncInit:x}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData($,se){const be=this.state.tensorInfo.get(se),ce=be.backend,x=this.readSync(se),He=ce.refCount(se);ce.disposeData(se,!0),be.backend=$,$.move(se,x,be.shape,be.dtype,He),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy($,se){let ce,be=null;if(null==se){if("function"!=typeof $)throw new Error("Please provide a function to tidy()");se=$}else{if("string"!=typeof $&&!($ instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof se)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");be=$}return this.scopedRun(()=>this.startScope(be),()=>this.endScope(ce),()=>(ce=se(),ce instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),ce))}scopedRun($,se,be){$();try{const ce=be();return se(),ce}catch(ce){throw se(),ce}}nextTensorId(){return Ce.nextTensorId++}nextVariableId(){return Ce.nextVariableId++}clone($){const se=It.runKernel(F.iJz,{x:$});return this.addTapeNode(this.state.activeScope.name,{x:$},[se],He=>({x:()=>It.runKernel(F.RFZ,{x:He},{dtype:"float32"})}),[],{}),se}runKernel($,se,be){if(null==(0,j.pI)($,this.backendName))throw new Error(`Kernel '${$}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:$,inputs:se,attrs:be})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak($,se,be){const ce=this.backend.numDataIds();let x=0;be.forEach(We=>{x+="complex64"===We.dtype?3:1});const Me=ce-se-x-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(Me>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${Me} data ids) after running '${$}'`)}runKernelFunc($){let se,be=[];const ce=this.isTapeOn(),x=this.state.numBytes,He=this.state.numTensors;let Me,We;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const nt=ot($)?$.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(ot($)){const{kernelName:Zt,inputs:yn,attrs:Mn}=$,cr=(0,j.pI)(Zt,this.backendName);Y.hu(null!=cr,()=>`Cannot find registered kernel '${Zt}' for backend '${this.backendName}'`),Me=()=>{const kn=this.backend.numDataIds();We=cr.kernelFunc({inputs:yn,attrs:Mn,backend:this.backend});const dn=Array.isArray(We)?We:[We];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(Zt,kn,dn);const un=dn.map(Fn=>null!=Fn.rank?Fn:this.makeTensorFromTensorInfo(Fn));if(ce){const Fn=this.getTensorsForGradient(Zt,yn,un);be=this.saveTensorsForBackwardMode(Fn)}return un}}else{const{forwardFunc:Zt}=$,yn=Mn=>{ce&&(be=Mn.map(cr=>this.keep(this.clone(cr))))};Me=()=>{const Mn=this.backend.numDataIds();We=this.tidy(()=>Zt(this.backend,yn));const cr=Array.isArray(We)?We:[We];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(nt,Mn,cr),cr}}const{inputs:et,attrs:Ve}=$,Ft=ot($)?null:$.backwardsFunc;let Yt;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(Yt=this.profiler.profileKernel(nt,et,()=>Me()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(Yt),se=Yt.outputs):se=Me()}),ce&&this.addTapeNode(nt,et,se,Ft,be,Ve),this.state.profiling&&this.state.activeProfile.kernels.push({name:nt,bytesAdded:this.state.numBytes-x,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-He,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(et).map(Zt=>null!=et[Zt]?et[Zt].shape:null),outputShapes:se.map(Zt=>Zt.shape),kernelTimeMs:Yt.timeMs,extraInfo:Yt.extraInfo}),Array.isArray(We)?se:se[0]}saveTensorsForBackwardMode($){return $.map(be=>this.keep(this.clone(be)))}getTensorsForGradient($,se,be){const ce=(0,j.uk)($);if(null!=ce){const x=ce.inputsToSave||[],He=ce.outputsToSave||[];let Me;ce.saveAllInputs?(Y.hu(Array.isArray(se),()=>"saveAllInputs is true, expected inputs to be an array."),Me=Object.keys(se).map(nt=>se[nt])):Me=x.map(nt=>se[nt]);const We=be.filter((nt,et)=>He[et]);return Me.concat(We)}return[]}makeTensor($,se,be,ce){if(null==$)throw new Error("Values passed to engine.makeTensor() are null");ce=ce||this.backend;let x=$;"string"===(be=be||"float32")&&Y.HD($[0])&&(x=$.map(We=>me.encodeString(We)));const He=ce.write(x,se,be),Me=new xe.es(se,be,He,this.nextTensorId());if(this.trackTensor(Me,ce),"string"===be){const We=this.state.tensorInfo.get(He),nt=(0,Y.Ub)(x);this.state.numBytes+=nt-We.bytes,We.bytes=nt}return Me}makeTensorFromDataId($,se,be,ce){return this.makeTensorFromTensorInfo({dataId:$,shape:se,dtype:be=be||"float32"},ce)}makeTensorFromTensorInfo($,se){const{dataId:be,shape:ce,dtype:x}=$,He=new xe.es(ce,x,be,this.nextTensorId());return this.trackTensor(He,se),He}makeVariable($,se=!0,be,ce){be=be||this.nextVariableId().toString(),null!=ce&&ce!==$.dtype&&($=$.cast(ce));const x=new xe._w($,se,be,this.nextTensorId());if(null!=this.state.registeredVariables[x.name])throw new Error(`Variable with name ${x.name} was already registered`);return this.state.registeredVariables[x.name]=x,this.incRef(x,this.backend),x}trackTensor($,se){this.state.numTensors++,"string"===$.dtype&&this.state.numStringTensors++;let be=0;"complex64"!==$.dtype&&"string"!==$.dtype&&(be=$.size*Y.bT($.dtype)),this.state.numBytes+=be,this.state.tensorInfo.has($.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set($.dataId,{backend:se||this.backend,dtype:$.dtype,shape:$.shape,bytes:be})),$ instanceof xe._w||this.track($)}incRef($,se){this.trackTensor($,se),this.backend.incRef($.dataId)}removeDataId($,se){this.state.tensorInfo.has($)&&this.state.tensorInfo.get($).backend===se&&(this.state.tensorInfo.delete($),this.state.numDataBuffers--)}disposeTensor($){if(!this.state.tensorInfo.has($.dataId))return;const se=this.state.tensorInfo.get($.dataId);if(this.state.numTensors--,"string"===$.dtype&&(this.state.numStringTensors--,this.state.numBytes-=se.bytes),"complex64"!==$.dtype&&"string"!==$.dtype){const be=$.size*Y.bT($.dtype);this.state.numBytes-=be}se.backend.disposeData($.dataId)&&this.removeDataId($.dataId,se.backend)}disposeVariables(){for(const $ in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[$])}disposeVariable($){this.disposeTensor($),null!=this.state.registeredVariables[$.name]&&delete this.state.registeredVariables[$.name]}memory(){const $=this.backend.memory();return $.numTensors=this.state.numTensors,$.numDataBuffers=this.state.numDataBuffers,$.numBytes=this.state.numBytes,this.state.numStringTensors>0&&($.unreliable=!0,null==$.reasons&&($.reasons=[]),$.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),$}profile($){var se=this;return(0,_e.Z)(function*(){se.state.profiling=!0;const be=se.state.numBytes,ce=se.state.numTensors;se.state.activeProfile.kernels=[],se.state.activeProfile.result=yield $(),se.state.profiling=!1,se.state.activeProfile.peakBytes=Math.max(...se.state.activeProfile.kernels.map(x=>x.totalBytesSnapshot)),se.state.activeProfile.newBytes=se.state.numBytes-be,se.state.activeProfile.newTensors=se.state.numTensors-ce;for(const x of se.state.activeProfile.kernels)x.kernelTimeMs=yield x.kernelTimeMs,x.extraInfo=yield x.extraInfo;return se.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode($,se,be,ce,x,He){const Me={id:this.state.nextTapeNodeId++,kernelName:$,inputs:se,outputs:be,saved:x},We=(0,j.uk)($);null!=We&&(ce=We.gradFunc),null!=ce&&(Me.gradient=nt=>(nt=nt.map((et,Ve)=>{if(null==et){const Ft=be[Ve],Yt=Y.wT(Ft.size,Ft.dtype);return this.makeTensor(Yt,Ft.shape,Ft.dtype)}return et}),ce(nt.length>1?nt:nt[0],x,He))),this.state.activeTape.push(Me)}keep($){return $.kept=!0,$}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope($){const se={track:[],name:"unnamed scope",id:this.state.nextScopeId++};$&&(se.name=$),this.state.scopeStack.push(se),this.state.activeScope=se}endScope($){const se=(0,Ze.getTensorsInContainer)($),be=new Set(se.map(x=>x.id));for(let x=0;x<this.state.activeScope.track.length;x++){const He=this.state.activeScope.track[x];!He.kept&&!be.has(He.id)&&He.dispose()}const ce=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],se.forEach(x=>{!x.kept&&x.scopeId===ce.id&&this.track(x)})}gradients($,se,be,ce=!1){if(Y.hu(se.length>0,()=>"gradients() received an empty list of xs."),null!=be&&"float32"!==be.dtype)throw new Error(`dy must have 'float32' dtype, but has '${be.dtype}'`);const x=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",$));Y.hu(x instanceof xe.es,()=>"The result y returned by f() must be a tensor.");const He=function de(Ce,ye,$){const se={},be={};for(let Me=0;Me<ye.length;Me++)se[ye[Me].id]=!0;for(let Me=0;Me<Ce.length;Me++){const We=Ce[Me],nt=We.inputs;for(const et in nt){const Ve=nt[et];let Ft=!1;for(let Yt=0;Yt<ye.length;Yt++)if(se[Ve.id]){We.outputs.forEach(Zt=>se[Zt.id]=!0),Ft=!0,be[We.id]=!0;break}if(Ft)break}}const ce={};ce[$.id]=!0;const x={};for(let Me=Ce.length-1;Me>=0;Me--){const We=Ce[Me],nt=We.inputs;for(let et=0;et<We.outputs.length;et++)if(ce[We.outputs[et].id]){for(const Ve in nt)ce[nt[Ve].id]=!0,x[We.id]=!0;break}}const He=[];for(let Me=0;Me<Ce.length;Me++){const We=Ce[Me];if(be[We.id]&&x[We.id]){const nt={};for(const Ve in We.inputs){const Ft=We.inputs[Ve];se[Ft.id]&&(nt[Ve]=Ft)}const et=Object.assign({},We);et.inputs=nt,et.outputs=We.outputs,He.push(et)}}return He}(this.state.activeTape,se,x);if(!ce&&0===He.length&&se.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const Me={};Me[x.id]=be??function ke(Ce){const ye=(0,Y.p8)((0,Y.NA)(Ce),"float32");return It.makeTensor(ye,Ce,"float32")}(x.shape),function Pe(Ce,ye,$,se){for(let be=ye.length-1;be>=0;be--){const ce=ye[be],x=[];if(ce.outputs.forEach(Me=>{const We=Ce[Me.id];x.push(null!=We?We:null)}),null==ce.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${ce.kernelName}.`);const He=ce.gradient(x);for(const Me in ce.inputs){if(!(Me in He))throw new Error(`Cannot backprop through input ${Me}. Available gradients found: ${Object.keys(He)}.`);const We=$(()=>He[Me]());if("float32"!==We.dtype)throw new Error(`Error in gradient for op ${ce.kernelName}. The gradient of input ${Me} must have 'float32' dtype, but has '${We.dtype}'`);const nt=ce.inputs[Me];if(!Y.cO(We.shape,nt.shape))throw new Error(`Error in gradient for op ${ce.kernelName}. The gradient of input '${Me}' has shape '${We.shape}', which does not match the shape of the input '${nt.shape}'`);if(null==Ce[nt.id])Ce[nt.id]=We;else{const et=Ce[nt.id];Ce[nt.id]=se(et,We),et.dispose()}}}}(Me,He,nt=>this.tidy(nt),$e);const We=se.map(nt=>Me[nt.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(nt=>{for(const et of nt.saved)et.dispose()}),this.state.activeTape=null),{value:x,grads:We}})}customGrad($){return Y.hu(Y.mf($),()=>"The f passed in customGrad(f) must be a function."),(...se)=>{let be;Y.hu(se.every(Me=>Me instanceof xe.es),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const ce={};return se.forEach((Me,We)=>{ce[We]=Me}),this.runKernelFunc({forwardFunc:(Me,We)=>(be=$(...se,We),Y.hu(be.value instanceof xe.es,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Y.hu(Y.mf(be.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),be.value),backwardsFunc:(Me,We)=>{const nt=be.gradFunc(Me,We),et=Array.isArray(nt)?nt:[nt];Y.hu(et.length===se.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Y.hu(et.every(Ft=>Ft instanceof xe.es),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const Ve={};return et.forEach((Ft,Yt)=>{Ve[Yt]=()=>Ft}),Ve},inputs:ce})}}readSync($){return this.state.tensorInfo.get($).backend.readSync($)}read($){return this.state.tensorInfo.get($).backend.read($)}readToGPU($,se){return this.state.tensorInfo.get($).backend.readToGPU($,se)}time($){var se=this;return(0,_e.Z)(function*(){const be=(0,me.now)(),ce=yield se.backend.time($);return ce.wallMs=(0,me.now)()-be,ce})()}track($){return null!=this.state.activeScope&&($.scopeId=this.state.activeScope.id,this.state.activeScope.track.push($)),$}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new St;for(const $ in this.registry)this.disposeRegisteredKernels($),this.registry[$].dispose(),delete this.registry[$];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return Ce.nextTensorId=0,Ce.nextVariableId=0,Ce})();function Oe(){const Ce=(0,Q.D)();if(null==Ce._tfengine){const ye=new te.qA(Ce);Ce._tfengine=new Vt(ye)}return(0,te.iG)(Ce._tfengine.ENV),(0,xe.Vi)(()=>Ce._tfengine),Ce._tfengine}const It=Oe();function $e(Ce,ye){return It.runKernel(F.mm_,{a:Ce,b:ye})}},1777:(gt,Xe,M)=>{"use strict";M.d(Xe,{OB:()=>me,Vi:()=>Y,iG:()=>le,qA:()=>Q});var _e=M(5861),we=M(1396);const te="tfjsflags";class Q{constructor(A){this.global=A,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=F,this.populateURLFlags()}setPlatform(A,de){null!=this.platform&&(me().getBool("IS_TEST")||me().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${A}.`)),this.platformName=A,this.platform=de}registerFlag(A,de,Pe){if(this.flagRegistry[A]={evaluationFn:de,setHook:Pe},null!=this.urlFlags[A]){const xe=this.urlFlags[A];me().getBool("IS_TEST")||me().getBool("PROD")||console.warn(`Setting feature override from URL ${A}: ${xe}.`),this.set(A,xe)}}getAsync(A){var de=this;return(0,_e.Z)(function*(){return A in de.flags||(de.flags[A]=yield de.evaluateFlag(A)),de.flags[A]})()}get(A){if(A in this.flags)return this.flags[A];const de=this.evaluateFlag(A);if((0,we.tI)(de))throw new Error(`Flag ${A} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[A]=de,this.flags[A]}getNumber(A){return this.get(A)}getBool(A){return this.get(A)}getFlags(){return this.flags}get features(){return this.flags}set(A,de){if(null==this.flagRegistry[A])throw new Error(`Cannot set flag ${A} as it has not been registered.`);this.flags[A]=de,null!=this.flagRegistry[A].setHook&&this.flagRegistry[A].setHook(de)}evaluateFlag(A){if(null==this.flagRegistry[A])throw new Error(`Cannot evaluate flag '${A}': no evaluation function found.`);return this.flagRegistry[A].evaluationFn()}setFlags(A){this.flags=Object.assign({},A)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const A=this.getQueryParams(this.global.location.search);te in A&&A[te].split(",").forEach(Pe=>{const[xe,Ze]=Pe.split(":");this.urlFlags[xe]=function Ie(ee,A){if("true"===(A=A.toLowerCase())||"false"===A)return"true"===A;if(""+ +A===A)return+A;throw new Error(`Could not parse value flag value ${A} for flag ${ee}.`)}(xe,Ze)})}}function F(ee){const A={};return ee.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(de,...Pe)=>(function j(ee,A,de){ee[decodeURIComponent(A)]=decodeURIComponent(de||"")}(A,Pe[0],Pe[1]),Pe.join("="))),A}function me(){return Y}let Y=null;function le(ee){Y=ee}},6422:(gt,Xe,M)=>{"use strict";let _e;function we(){if(null==_e){let F;if(typeof window<"u")F=window;else if(typeof global<"u")F=global;else if(typeof process<"u")F=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");F=self}_e=F}return _e}function Q(F,j){const Ie=function te(){const F=we();return null==F._tfGlobals&&(F._tfGlobals=new Map),F._tfGlobals}();if(Ie.has(F))return Ie.get(F);{const me=j();return Ie.set(F,me),Ie.get(F)}}M.d(Xe,{D:()=>we,R:()=>Q})},9370:(gt,Xe,M)=>{"use strict";M.d(Xe,{B9:()=>Pe,CQ:()=>ot,Cd:()=>St,Cn:()=>xe,G4:()=>F,MX:()=>me,N5:()=>A,N8:()=>Y,N_:()=>Vt,R:()=>j,SR:()=>le,VY:()=>ye,XV:()=>Ze,cF:()=>Ie,cj:()=>ke,jq:()=>$e,lu:()=>de,sq:()=>ee,x3:()=>Oe,y3:()=>Ce,ze:()=>It});var _e=M(3738),we=M(1777),te=M(708),Q=M(7904);function F(){(0,we.OB)().set("PROD",!0)}function j(){(0,we.OB)().set("DEBUG",!0)}function Ie(){(0,we.OB)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function me($){(0,we.OB)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn($+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Y(){_e.BV.disposeVariables()}function le(){return _e.BV}function ee(){return _e.BV.memory()}function A($){return _e.BV.profile($)}function de($,se){return _e.BV.tidy($,se)}function Pe($){(0,Q.getTensorsInContainer)($).forEach(be=>be.dispose())}function xe($){return _e.BV.keep($)}function Ze($){return _e.BV.time($)}function ot($){return _e.BV.setBackend($)}function St(){return _e.BV.ready()}function Vt(){return _e.BV.backendName}function ke($){_e.BV.removeBackend($)}function Oe($){return _e.BV.findBackend($)}function It($){return _e.BV.findBackendFactory($)}function $e($,se,be=1){return _e.BV.registerBackend($,se,be)}function Ce(){return _e.BV.backend}function ye($,se){(0,we.OB)().setPlatform($,se)}(0,te.FZ)(me)},1335:(gt,Xe,M)=>{"use strict";M.d(Xe,{UQ:()=>F,cb:()=>le,fN:()=>me,h7:()=>Ie,pn:()=>Y,ti:()=>j});var _e=M(3738),we=M(708),te=M(9608),Q=M(1396);function F(A){return Q.hu(Q.mf(A),()=>"The f passed in grad(f) must be a function"),(de,Pe)=>{const xe=(0,te._1)(de,"x","tf.grad","string_or_numeric"),Ze=null!=Pe?(0,te._1)(Pe,"dy","tf.grad"):null;return _e.BV.tidy(()=>{const{value:ot,grads:St}=_e.BV.gradients(()=>A(xe),[xe],Ze);return null!=Ze&&Q.k5(ot.shape,Ze.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),ee(St),St[0]})}}function j(A){return Q.hu(Q.mf(A),()=>"The f passed in grads(f) must be a function"),(de,Pe)=>{Q.hu(Array.isArray(de),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const xe=(0,te.sI)(de,"args","tf.grads","string_or_numeric"),Ze=null!=Pe?(0,te._1)(Pe,"dy","tf.grads"):null;return _e.BV.tidy(()=>{const{value:ot,grads:St}=_e.BV.gradients(()=>A(...xe),xe,Ze);return null!=Ze&&Q.k5(ot.shape,Ze.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ee(St),St})}}function Ie(A){return Q.hu(Q.mf(A),()=>"The f passed in valueAndGrad(f) must be a function"),(de,Pe)=>{Q.hu(de instanceof we.es,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),Q.hu(null==Pe||Pe instanceof we.es,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:xe,value:Ze}=_e.BV.gradients(()=>A(de),[de],Pe);return ee(xe),{grad:xe[0],value:Ze}}}function me(A){return Q.hu(Q.mf(A),()=>"The f passed in valueAndGrads(f) must be a function"),(de,Pe)=>{Q.hu(Array.isArray(de)&&de.every(Ze=>Ze instanceof we.es),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),Q.hu(null==Pe||Pe instanceof we.es,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const xe=_e.BV.gradients(()=>A(...de),de,Pe);return null!=Pe&&Q.k5(xe.value.shape,Pe.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ee(xe.grads),xe}}function Y(A,de){Q.hu(Q.mf(A),()=>"The f passed in variableGrads(f) must be a function"),Q.hu(null==de||Array.isArray(de)&&de.every(Oe=>Oe instanceof we._w),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const Pe=null!=de;if(!Pe){de=[];for(const Oe in _e.BV.registeredVariables)de.push(_e.BV.registeredVariables[Oe])}const xe=Pe?de.filter(Oe=>!Oe.trainable):null,Ze=de.length;de=de.filter(Oe=>Oe.trainable),Q.hu(de.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${Ze} variables is trainable.`);const{value:St,grads:Vt}=_e.BV.gradients(A,de,null,!0);Q.hu(Vt.some(Oe=>null!=Oe),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Q.hu(0===St.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${St.rank} tensor`);const ke={};return de.forEach((Oe,It)=>{null!=Vt[It]&&(ke[Oe.name]=Vt[It])}),xe?.forEach(Oe=>ke[Oe.name]=null),{value:St,grads:ke}}function le(A){return _e.BV.customGrad(A)}function ee(A){if(A.filter(Pe=>null==Pe).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}},1726:(gt,Xe,M)=>{"use strict";M.r(Xe),M.d(Xe,{Abs:()=>ge.SYM,Acos:()=>ge.VGw,Acosh:()=>ge.SpW,AdadeltaOptimizer:()=>ya,AdagradOptimizer:()=>fs,AdamOptimizer:()=>eo,AdamaxOptimizer:()=>co,Add:()=>ge.mm_,AddN:()=>ge.Xze,All:()=>ge.oT6,Any:()=>ge.IKK,ArgMax:()=>ge.sJF,ArgMin:()=>ge.aJk,Asin:()=>ge.M2y,Asinh:()=>ge.qw7,Atan:()=>ge.jMg,Atan2:()=>ge.QCc,Atanh:()=>ge.Oyi,AvgPool:()=>ge.JhU,AvgPool3D:()=>ge._k9,AvgPool3DGrad:()=>ge.IMb,AvgPoolGrad:()=>ge.ROF,BatchMatMul:()=>ge.XLW,BatchToSpaceND:()=>ge.zws,Bincount:()=>ge.zvY,BroadcastArgs:()=>ge.eEB,BroadcastTo:()=>ge.Ly9,Cast:()=>ge.RFZ,Ceil:()=>ge.gJX,ClipByValue:()=>ge.xnO,Complex:()=>ge.Zz9,ComplexAbs:()=>ge.yj2,Concat:()=>ge.Eh3,Conv2D:()=>ge.mhS,Conv2DBackpropFilter:()=>ge.wUP,Conv2DBackpropInput:()=>ge.wm,Conv3D:()=>ge.x12,Conv3DBackpropFilterV2:()=>ge.o2y,Conv3DBackpropInputV2:()=>ge.ik2,Cos:()=>ge.mc4,Cosh:()=>ge.TR1,CropAndResize:()=>ge.VcC,Cumprod:()=>ge.Byc,Cumsum:()=>ge.iHb,DataStorage:()=>ba.JL,DenseBincount:()=>ge.QRR,DepthToSpace:()=>ge.T0n,DepthwiseConv2dNative:()=>ge.cie,DepthwiseConv2dNativeBackpropFilter:()=>ge.sL$,DepthwiseConv2dNativeBackpropInput:()=>ge.y7R,Diag:()=>ge.$w,Dilation2D:()=>ge.p4S,Dilation2DBackpropFilter:()=>ge.Vn9,Dilation2DBackpropInput:()=>ge.ekb,ENV:()=>St.Vi,Einsum:()=>ge.$g6,Elu:()=>ge.SX0,EluGrad:()=>ge.HEU,Environment:()=>St.qA,Equal:()=>ge.hdR,Erf:()=>ge.Omj,Exp:()=>ge.NEP,ExpandDims:()=>ge.YFo,Expm1:()=>ge.Y0y,FFT:()=>ge.vwp,Fill:()=>ge.deh,FlipLeftRight:()=>ge.Uyb,Floor:()=>ge.OR,FloorDiv:()=>ge.jeX,FromPixels:()=>ge.eBW,FusedBatchNorm:()=>ge.sHE,FusedConv2D:()=>ge._V0,FusedDepthwiseConv2D:()=>ge.luS,GatherNd:()=>ge.q1x,GatherV2:()=>ge.qi_,Greater:()=>ge.iZT,GreaterEqual:()=>ge.Acj,IFFT:()=>ge.Qg5,Identity:()=>ge.iJz,Imag:()=>ge.J_u,IsFinite:()=>ge.avt,IsInf:()=>ge.iWB,IsNan:()=>ge.r7n,KernelBackend:()=>ba.Zu,LRN:()=>ge.eZ0,LRNGrad:()=>ge.Hhh,LeakyRelu:()=>ge.J$2,Less:()=>ge.vtC,LessEqual:()=>ge.CAk,LinSpace:()=>ge.e7N,Log:()=>ge.ZbH,Log1p:()=>ge.kU,LogSoftmax:()=>ge.qCd,LogicalAnd:()=>ge.PYm,LogicalNot:()=>ge.VfG,LogicalOr:()=>ge.MZg,LogicalXor:()=>ge.w6g,LowerBound:()=>ge.qIC,Max:()=>ge.YoZ,MaxPool:()=>ge.mTV,MaxPool3D:()=>ge.OAf,MaxPool3DGrad:()=>ge.OU7,MaxPoolGrad:()=>ge.OV7,MaxPoolWithArgmax:()=>ge.vFR,Maximum:()=>ge.BMI,Mean:()=>ge.q2K,Min:()=>ge.c17,Minimum:()=>ge.q8u,MirrorPad:()=>ge.jQs,Mod:()=>ge.Vbg,MomentumOptimizer:()=>Gu,Multinomial:()=>ge.NZg,Multiply:()=>ge.wYn,Neg:()=>ge.kuV,NonMaxSuppressionV3:()=>ge.uv1,NonMaxSuppressionV4:()=>ge.cye,NonMaxSuppressionV5:()=>ge.W0H,NotEqual:()=>ge.yQU,OP_SCOPE_SUFFIX:()=>Fe.zvA,OneHot:()=>ge.we_,OnesLike:()=>ge.qWM,Optimizer:()=>xo,OptimizerConstructors:()=>Ni,Pack:()=>ge.QiL,PadV2:()=>ge.lyA,Pool:()=>ge.Kgp,Pow:()=>ge.pe_,Prelu:()=>ge.o0g,Prod:()=>ge.DlI,RMSPropOptimizer:()=>wc,RaggedGather:()=>ge.dDz,RaggedTensorToTensor:()=>ge.BiW,Range:()=>ge.e6w,Rank:()=>Ku.yw,Real:()=>ge.xJR,RealDiv:()=>ge.oHH,Reciprocal:()=>ge.$HU,Reduction:()=>Pf.I,Relu:()=>ge.qkr,Relu6:()=>ge.SbG,Reshape:()=>ge.HZH,ResizeBilinear:()=>ge._Yw,ResizeBilinearGrad:()=>ge.zbQ,ResizeNearestNeighbor:()=>ge.dpD,ResizeNearestNeighborGrad:()=>ge.Hmb,Reverse:()=>ge.mKl,RotateWithOffset:()=>ge.b9H,Round:()=>ge.e07,Rsqrt:()=>ge.bV0,SGDOptimizer:()=>cs,ScatterNd:()=>ge.xQA,SearchSorted:()=>ge.nr8,Select:()=>ge.PhF,Selu:()=>ge.oFR,Sigmoid:()=>ge.a5O,Sign:()=>ge.i5y,Sin:()=>ge.RQH,Sinh:()=>ge.wYB,Slice:()=>ge.p2w,Softmax:()=>ge.Gcp,Softplus:()=>ge.MRv,SpaceToBatchND:()=>ge.TQc,SparseFillEmptyRows:()=>ge.O3z,SparseReshape:()=>ge.nhH,SparseSegmentMean:()=>ge.w3H,SparseSegmentSum:()=>ge.ZjV,SparseToDense:()=>ge.D2d,SplitV:()=>ge.L8s,Sqrt:()=>ge.FKq,Square:()=>ge.bK0,SquaredDifference:()=>ge._tC,Step:()=>ge.h8e,StridedSlice:()=>ge.jQk,StringNGrams:()=>ge._JP,StringSplit:()=>ge.s1s,StringToHashBucketFast:()=>ge.XkS,Sub:()=>ge.Tr8,Sum:()=>ge.GBy,Tan:()=>ge.sEM,Tanh:()=>ge.MIZ,Tensor:()=>Jo.es,TensorBuffer:()=>Jo.YD,Tile:()=>ge.n9L,TopK:()=>ge.cWu,Transform:()=>ge.wx7,Transpose:()=>ge.G3Y,Unique:()=>ge.kpP,Unpack:()=>ge.ToN,UnsortedSegmentSum:()=>ge.Qvg,UpperBound:()=>ge.XDQ,Variable:()=>Jo._w,ZerosLike:()=>ge.RuY,_FusedMatMul:()=>ge.usg,abs:()=>Fe.WnP,acos:()=>Fe.Khb,acosh:()=>Fe.__u,add:()=>Fe.IHx,addN:()=>Fe.QBD,all:()=>Fe.$6P,any:()=>Fe.YjB,argMax:()=>Fe.NqF,argMin:()=>Fe.vHJ,asin:()=>Fe.ZRM,asinh:()=>Fe.VfV,atan:()=>Fe.z4N,atan2:()=>Fe.fvJ,atanh:()=>Fe.C80,avgPool:()=>Fe.wS1,avgPool3d:()=>Fe.uR5,backend:()=>fn.y3,backend_util:()=>le,basicLSTMCell:()=>Fe.zEQ,batchNorm:()=>Fe.tgs,batchNorm2d:()=>Fe.Dxk,batchNorm3d:()=>Fe.JY5,batchNorm4d:()=>Fe.p3b,batchToSpaceND:()=>Fe.E4h,bincount:()=>Fe.yE8,booleanMaskAsync:()=>Fe.anm,broadcastArgs:()=>Fe.XsQ,broadcastTo:()=>Fe.UFq,broadcast_util:()=>at,browser:()=>Q,buffer:()=>Fe.f3b,cast:()=>Fe.pju,ceil:()=>Fe.mDi,clipByValue:()=>Fe.iUl,clone:()=>Fe.d9v,complex:()=>Fe.PYB,concat:()=>Fe.zoF,concat1d:()=>Fe.gME,concat2d:()=>Fe.Izb,concat3d:()=>Fe.MNy,concat4d:()=>Fe.ZaL,conv1d:()=>Fe.PAt,conv2d:()=>Fe.Tek,conv2dTranspose:()=>Fe.bc,conv3d:()=>Fe.pdZ,conv3dTranspose:()=>Fe.$QV,copyRegisteredKernels:()=>Lt.T3,cos:()=>Fe.mCk,cosh:()=>Fe.f9Y,cosineWindow:()=>Fe.mew,cumprod:()=>Fe.$Gn,cumsum:()=>Fe.zbp,customGrad:()=>Ti.cb,denseBincount:()=>Fe.ppE,deprecationWarn:()=>fn.MX,depthToSpace:()=>Fe.nTT,depthwiseConv2d:()=>Fe.B10,device_util:()=>_e,diag:()=>Fe.Ka3,dilation2d:()=>Fe.WmZ,disableDeprecationWarnings:()=>fn.cF,dispose:()=>fn.B9,disposeVariables:()=>fn.N8,div:()=>Fe.hiC,divNoNan:()=>Fe.NTj,dot:()=>Fe.AKD,dropout:()=>Fe.rvX,einsum:()=>Fe.WYO,elu:()=>Fe.pyx,enableDebugMode:()=>fn.R,enableProdMode:()=>fn.G4,enclosingPowerOfTwo:()=>Fe.GRh,engine:()=>fn.SR,env:()=>St.OB,equal:()=>Fe.DgJ,erf:()=>Fe.qNN,euclideanNorm:()=>Fe.d2q,exp:()=>Fe.Qqt,expandDims:()=>Fe.dt4,expm1:()=>Fe.t$B,eye:()=>Fe.iyy,fft:()=>Fe.kp_,fill:()=>Fe.hlL,findBackend:()=>fn.x3,findBackendFactory:()=>fn.ze,floor:()=>Fe.GWj,floorDiv:()=>Fe.qPi,fused:()=>Fe.imm,gather:()=>Fe.Iqj,gatherND:()=>Fe.dbB,gather_util:()=>F,getBackend:()=>fn.N_,getGradient:()=>Lt.uk,getKernel:()=>Lt.pI,getKernelsForBackend:()=>Lt.tr,grad:()=>Ti.UQ,grads:()=>Ti.ti,greater:()=>Fe.pjt,greaterEqual:()=>Fe.brS,ifft:()=>Fe.Sxn,imag:()=>Fe.asL,image:()=>Fe.BHj,inTopKAsync:()=>Fe.V3u,io:()=>we,irfft:()=>Fe.wx0,isFinite:()=>Fe.xVT,isInf:()=>Fe.UWc,isNaN:()=>Fe.i2d,keep:()=>fn.Cn,kernel_impls:()=>ee,leakyRelu:()=>Fe.hi7,less:()=>Fe.d9m,lessEqual:()=>Fe.zN1,linalg:()=>Fe.$r2,linspace:()=>Fe.SX3,localResponseNormalization:()=>Fe.G9k,log:()=>Fe.cM7,log1p:()=>Fe.Krr,logSigmoid:()=>Fe.e_t,logSoftmax:()=>Fe.CmS,logSumExp:()=>Fe.l_t,logicalAnd:()=>Fe.HvI,logicalNot:()=>Fe.hJK,logicalOr:()=>Fe.K5V,logicalXor:()=>Fe.egP,losses:()=>Fe.MB5,lowerBound:()=>Fe.eab,matMul:()=>Fe.OI3,math:()=>te,max:()=>Fe.Fp7,maxPool:()=>Fe._sB,maxPool3d:()=>Fe.YQQ,maxPoolWithArgmax:()=>Fe.Ip$,maximum:()=>Fe.gWQ,mean:()=>Fe.J69,memory:()=>fn.sq,meshgrid:()=>Fe.ry_,min:()=>Fe.VV$,minimum:()=>Fe.LTh,mirrorPad:()=>Fe.VdP,mod:()=>Fe.wQq,moments:()=>Fe.Gi7,movingAverage:()=>Fe.p_,mul:()=>Fe.dC7,multiRNNCell:()=>Fe.rq4,multinomial:()=>Fe.SJ_,neg:()=>Fe.W76,nextFrame:()=>Vf,norm:()=>Fe.KOy,notEqual:()=>Fe.Quu,oneHot:()=>Fe.lfX,ones:()=>Fe.iUs,onesLike:()=>Fe.JpU,op:()=>Fe.op,outerProduct:()=>Fe.N2O,pad:()=>Fe.vku,pad1d:()=>Fe.pNR,pad2d:()=>Fe.koy,pad3d:()=>Fe.t1L,pad4d:()=>Fe.lGY,pool:()=>Fe.d_R,pow:()=>Fe.sQ3,prelu:()=>Fe.AL3,print:()=>Fe.S0v,prod:()=>Fe.WVs,profile:()=>fn.N5,raggedGather:()=>Fe.$gW,raggedTensorToTensor:()=>Fe.N89,rand:()=>Fe.TN_,randomGamma:()=>Fe.wzB,randomNormal:()=>Fe.nGf,randomStandardNormal:()=>Fe.ruB,randomUniform:()=>Fe.LGj,range:()=>Fe.w6H,ready:()=>fn.Cd,real:()=>Fe.kwC,reciprocal:()=>Fe.M25,registerBackend:()=>fn.jq,registerGradient:()=>Lt.Li,registerKernel:()=>Lt.wC,relu:()=>Fe.UYe,relu6:()=>Fe.btT,removeBackend:()=>fn.cj,reshape:()=>Fe.XLQ,reverse:()=>Fe.GYS,reverse1d:()=>Fe.SDf,reverse2d:()=>Fe.diP,reverse3d:()=>Fe.sx7,reverse4d:()=>Fe.mG2,rfft:()=>Fe.QEs,round:()=>Fe.NMM,rsqrt:()=>Fe.bp0,scalar:()=>Fe.iD$,scatterND:()=>Fe.snQ,scatter_util:()=>Je,searchSorted:()=>Fe.zcT,selu:()=>Fe.U8D,separableConv2d:()=>Fe.U_I,serialization:()=>Ie,setBackend:()=>fn.CQ,setPlatform:()=>fn.VY,setdiff1dAsync:()=>Fe.ODp,sigmoid:()=>Fe.XD2,sign:()=>Fe.Xxe,signal:()=>Fe.tdS,sin:()=>Fe.O$l,sinh:()=>Fe.R_K,slice:()=>Fe.tPi,slice1d:()=>Fe.jZU,slice2d:()=>Fe.SmN,slice3d:()=>Fe.CnO,slice4d:()=>Fe.p0P,slice_util:()=>j,softmax:()=>Fe.XAC,softplus:()=>Fe.Wvh,spaceToBatchND:()=>Fe.fBT,sparse:()=>Fe.rVs,sparseToDense:()=>Fe.ers,spectral:()=>Fe.uN7,split:()=>Fe.Vl2,sqrt:()=>Fe._b3,square:()=>Fe.h62,squaredDifference:()=>Fe.$i,squeeze:()=>Fe.L9e,stack:()=>Fe.knu,step:()=>Fe.Nbs,stridedSlice:()=>Fe.NXj,string:()=>Fe.Z_8,sub:()=>Fe.luU,sum:()=>Fe.Smz,sumOutType:()=>Ku.z4,tan:()=>Fe.ORZ,tanh:()=>Fe.AEp,tensor:()=>Fe.XeE,tensor1d:()=>Fe.RRF,tensor2d:()=>Fe.odF,tensor3d:()=>Fe.wOQ,tensor4d:()=>Fe.yXz,tensor5d:()=>Fe.Bfx,tensor6d:()=>Fe.xZs,tensor_util:()=>Xi,test_util:()=>me,tidy:()=>fn.lu,tile:()=>Fe.Gg6,time:()=>fn.XV,topk:()=>Fe.hg7,train:()=>Lf,transpose:()=>Fe.p4s,truncatedNormal:()=>Fe.Xu6,unique:()=>Fe.Two,unregisterGradient:()=>Lt.bt,unregisterKernel:()=>Lt.nE,unsortedSegmentSum:()=>Fe.pUJ,unstack:()=>Fe.HHK,upcastType:()=>Ku.x8,upperBound:()=>Fe.GaM,util:()=>vo,valueAndGrad:()=>Ti.h7,valueAndGrads:()=>Ti.fN,variable:()=>Fe.VD$,variableGrads:()=>Ti.pn,version_core:()=>_s,where:()=>Fe.arb,whereAsync:()=>Fe.itS,zeros:()=>Fe.lls,zerosLike:()=>Fe.P84});var _e={};M.r(_e),M.d(_e,{isBrowser:()=>ot,isMobile:()=>Ze,mockIsMobile:()=>xe});var we={};M.r(we),M.d(we,{browserFiles:()=>vn,browserHTTPRequest:()=>Ei,concatenateArrayBuffers:()=>nt,copyModel:()=>Lr,decodeWeights:()=>be,encodeWeights:()=>$,fromMemory:()=>fr,fromMemorySync:()=>Fo,getLoadHandlers:()=>rt,getModelArtifactsForJSON:()=>Yt,getModelArtifactsForJSONSync:()=>Ft,getModelArtifactsInfoForJSON:()=>yn,getSaveHandlers:()=>Ne,getWeightSpecs:()=>Mn,http:()=>ei,isHTTPScheme:()=>Ki,listModels:()=>Gr,loadWeights:()=>Br,moveModel:()=>rr,registerLoadRouter:()=>Zn,registerSaveRouter:()=>ds,removeModel:()=>Vi,weightsLoaderFactory:()=>Si,withSaveHandler:()=>Va,withSaveHandlerSync:()=>ao});var te={};M.r(te),M.d(te,{confusionMatrix:()=>je});var Q={};M.r(Q),M.d(Q,{fromPixels:()=>ut,fromPixelsAsync:()=>K,toPixels:()=>oe});var F={};M.r(F),M.d(F,{prepareAndValidate:()=>tt});var j={};M.r(j),M.d(j,{assertParamsValid:()=>Gt,computeFlatOffset:()=>Qs,computeOutShape:()=>ln,getNormalizedAxes:()=>kr,isSliceContinous:()=>Es,maskToAxes:()=>Ht,parseSliceParams:()=>br,sliceInfo:()=>Os,startForAxis:()=>Hu,startIndicesWithElidedDims:()=>Po,stopForAxis:()=>pu,stopIndicesWithElidedDims:()=>_i,stridesForAxis:()=>Hs,stridesWithElidedDims:()=>xr});var Ie={};M.r(Ie),M.d(Ie,{Serializable:()=>Js,SerializationMap:()=>Ii,registerClass:()=>Di});var me={};M.r(me),M.d(me,{TEST_EPSILON_FLOAT16:()=>_n,createVideoElement:()=>gu,encodeStrings:()=>mu,expectArrayBuffersEqual:()=>Kn,expectArraysClose:()=>Cr,expectArraysEqual:()=>Ua,expectNumbersClose:()=>Cn,expectPromiseToFail:()=>$s,expectValuesInRange:()=>ju,play:()=>yu,testEpsilon:()=>uo});var Y={};M.r(Y),M.d(Y,{collectGatherOpShapeInfo:()=>Gf,computeOutShape:()=>Nc,segOpComputeOptimalWindowSize:()=>Tc});var le={};M.r(le),M.d(le,{ERF_A1:()=>Sc,ERF_A2:()=>yl,ERF_A3:()=>bo,ERF_A4:()=>vl,ERF_A5:()=>xl,ERF_P:()=>Jd,PARALLELIZE_THRESHOLD:()=>fl,RowPartitionType:()=>Bo,SELU_SCALE:()=>gl,SELU_SCALEALPHA:()=>ml,applyActivation:()=>Cc.QH,assertAndGetBroadcastShape:()=>at.assertAndGetBroadcastShape,assertAxesAreInnerMostDims:()=>va.lB,assertParamsConsistent:()=>Uf,assignToTypedArray:()=>ja,axesAreInnerMostDims:()=>va.YB,calculateShapes:()=>Je.calculateShapes,checkEinsumDimSizes:()=>sh,checkPadOnDimRoundingMode:()=>ki.m,combineLocations:()=>va.Vh,combineRaggedTensorToTensorShapes:()=>zf,complexWithEvenIndex:()=>lo,complexWithOddIndex:()=>th,computeConv2DInfo:()=>ki.Ix,computeConv3DInfo:()=>ki.jw,computeDefaultPad:()=>ki.aO,computeDilation2DInfo:()=>ki.Rf,computeOptimalWindowSize:()=>jf,computeOutAndReduceShapes:()=>va.kz,computeOutShape:()=>Wf,computePool2DInfo:()=>ki.Xw,computePool3DInfo:()=>ki.pl,convertConv2DDataFormat:()=>ki.sl,decodeEinsumEquation:()=>Ec,eitherStridesOrDilationsAreOne:()=>ki.jT,expandShapeToKeepDim:()=>va.rv,exponent:()=>nh,exponents:()=>to,fromStringArrayToUint8:()=>Jr,fromUint8ToStringArray:()=>Cl,getAxesPermutation:()=>va.Q3,getBroadcastDims:()=>at.getBroadcastDims,getComplexWithIndex:()=>bl,getEinsumComputePath:()=>Ag,getEinsumPermutation:()=>Vn,getFusedBiasGradient:()=>Cc.pf,getFusedDyActivation:()=>Cc.Fr,getImageCenter:()=>Vo,getInnerMostAxes:()=>va.sY,getPermuted:()=>xa,getRaggedRank:()=>hl,getReductionAxes:()=>at.getReductionAxes,getReshaped:()=>Yd,getReshapedPermuted:()=>pl,getRowPartitionTypesHelper:()=>dl,getSliceBeginCoords:()=>Zd,getSliceSize:()=>Qd,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>wl,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>ah,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>uh,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Zi,getSparseReshapeInputOutputMismatchErrorMessage:()=>Is,getSparseReshapeInputOutputMultipleErrorMessage:()=>Qi,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Dt,getSparseReshapeNegativeOutputDimErrorMessage:()=>or,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Dc,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Ic,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Ai,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>ho,getUndoAxesPermutation:()=>va.LJ,isIdentityPermutation:()=>_c,log:()=>ms.c,mergeRealAndImagArrays:()=>eh,prepareAndValidate:()=>tt,prepareSplitSize:()=>ih,segment_util:()=>Y,shouldFuse:()=>Cc.uy,slice_util:()=>j,splitRealAndImagArrays:()=>Xu,tupleValuesAreOne:()=>ki.I0,upcastType:()=>Ku.x8,validateDefaultValueShape:()=>Hf,validateInput:()=>Je.validateInput,validateUpdateShape:()=>Je.validateUpdateShape,warn:()=>ms.Z});var ee={};M.r(ee),M.d(ee,{nonMaxSuppressionV3Impl:()=>Wo.GP,nonMaxSuppressionV4Impl:()=>Wo.qP,nonMaxSuppressionV5Impl:()=>Wo.pA,whereImpl:()=>Sl.Z});var A=M(3738);let Pe;function xe(k){Pe=k}function Ze(k){if(void 0!==Pe)return Pe;if(k||function de(){return typeof navigator<"u"&&null!=navigator}()){if(k||(k=navigator),"ReactNative"===k.product)return!0;const P=k.userAgent||k.vendor||(typeof window<"u"?window.opera:"");return P?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(P)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(P.substr(0,4)):k.userAgentData&&k.userAgentData.mobile}return!1}function ot(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}var St=M(1777);const Vt=(0,St.OB)();Vt.registerFlag("DEBUG",()=>!1,k=>{k&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Vt.registerFlag("IS_BROWSER",()=>ot()),Vt.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),Vt.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Vt.registerFlag("PROD",()=>!1),Vt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Vt.getBool("DEBUG")),Vt.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Vt.registerFlag("IS_TEST",()=>!1),Vt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),Vt.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),Vt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1),Vt.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),Vt.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);var ke=M(5861),Oe=M(9907),It=M(1973),$e=M(1396);const Ce={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},ye=4;function $(k,P){return se.apply(this,arguments)}function se(){return se=(0,ke.Z)(function*(k,P){const T=[],B=[],X=Array.isArray(k)?k.map(fe=>fe.name):Object.keys(k);for(let fe=0;fe<X.length;++fe){const Le=X[fe],st=Array.isArray(k)?k[fe].tensor:k[Le];if("float32"!==st.dtype&&"int32"!==st.dtype&&"bool"!==st.dtype&&"string"!==st.dtype&&"complex64"!==st.dtype)throw new Error(`Unsupported dtype in weight '${Le}': ${st.dtype}`);const it={name:Le,shape:st.shape,dtype:st.dtype};if("string"===st.dtype){const Tt=new Promise(function(){var dt=(0,ke.Z)(function*(ht){const Mt=yield st.bytes(),on=Mt.reduce((lr,si)=>lr+si.length,0)+ye*Mt.length,Sn=new Uint8Array(on);let Pn=0;for(let lr=0;lr<Mt.length;lr++){const si=Mt[lr],Xt=new Uint8Array(new Uint32Array([si.length]).buffer);Sn.set(Xt,Pn),Pn+=ye,Sn.set(si,Pn),Pn+=si.length}ht(Sn)});return function(ht){return dt.apply(this,arguments)}}());B.push(Tt)}else B.push(st.data());null!=P&&(it.group=P),T.push(it)}return{data:ce(yield Promise.all(B)),specs:T}}),se.apply(this,arguments)}function be(k,P){const T={};let B,X=0;for(const ue of P){const fe=ue.name,Le=ue.dtype,st=ue.shape,it=(0,$e.NA)(st);let Tt;if("quantization"in ue){const dt=ue.quantization;if("uint8"===dt.dtype||"uint16"===dt.dtype){if(!("min"in dt)||!("scale"in dt))throw new Error(`Weight ${ue.name} with quantization ${dt.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==dt.dtype)throw new Error(`Weight ${ue.name} has unknown quantization dtype ${dt.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==Le)throw new Error(`Weight ${ue.name} is quantized with ${dt.dtype} which only supports weights of type float32 not ${Le}.`)}const ht=Ce[dt.dtype],Mt=k.slice(X,X+it*ht),on="uint8"===dt.dtype?new Uint8Array(Mt):new Uint16Array(Mt);if("float32"===Le)if("uint8"===dt.dtype||"uint16"===dt.dtype){Tt=new Float32Array(on.length);for(let Sn=0;Sn<on.length;Sn++)Tt[Sn]=on[Sn]*dt.scale+dt.min}else{if("float16"!==dt.dtype)throw new Error(`Unsupported quantization type ${dt.dtype} for weight type float32.`);void 0===B&&(B=un()),Tt=B(on)}else{if("int32"!==Le)throw new Error(`Unsupported dtype in weight '${fe}': ${Le}`);if("uint8"!==dt.dtype&&"uint16"!==dt.dtype)throw new Error(`Unsupported quantization type ${dt.dtype} for weight type int32.`);Tt=new Int32Array(on.length);for(let Sn=0;Sn<on.length;Sn++)Tt[Sn]=Math.round(on[Sn]*dt.scale+dt.min)}X+=it*ht}else if("string"===Le){const dt=(0,$e.NA)(ue.shape);Tt=[];for(let ht=0;ht<dt;ht++){const Mt=new Uint32Array(k.slice(X,X+ye))[0];X+=ye;const on=new Uint8Array(k.slice(X,X+Mt));Tt.push(on),X+=Mt}}else{const dt=Ce[Le],ht=k.slice(X,X+it*dt);if("float32"===Le)Tt=new Float32Array(ht);else if("int32"===Le)Tt=new Int32Array(ht);else if("bool"===Le)Tt=new Uint8Array(ht);else{if("complex64"!==Le)throw new Error(`Unsupported dtype in weight '${fe}': ${Le}`);{Tt=new Float32Array(ht);const Mt=new Float32Array(Tt.length/2),on=new Float32Array(Tt.length/2);for(let lr=0;lr<Mt.length;lr++)Mt[lr]=Tt[2*lr],on[lr]=Tt[2*lr+1];const Sn=(0,It.X)(Mt,st,"float32"),Pn=(0,It.X)(on,st,"float32");T[fe]=(0,Oe.P)(Sn,Pn),Sn.dispose(),Pn.dispose()}}X+=it*dt}"complex64"!==Le&&(T[fe]=(0,It.X)(Tt,st,Le))}return T}function ce(k){if(null===k)throw new Error(`Invalid input value: ${JSON.stringify(k)}`);let P=0;const T=[];k.forEach(ue=>{if(P+=ue.byteLength,T.push(ue.byteLength===ue.buffer.byteLength?ue:new ue.constructor(ue)),!(ue instanceof Float32Array||ue instanceof Int32Array||ue instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${ue.constructor.name}`)});const B=new Uint8Array(P);let X=0;return T.forEach(ue=>{B.set(new Uint8Array(ue.buffer),X),X+=ue.byteLength}),B.buffer}const x=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function He(k){return x?Buffer.byteLength(k):new Blob([k]).size}function nt(k){if(1===k.length)return k[0];let P=0;k.forEach(X=>{P+=X.byteLength});const T=new Uint8Array(P);let B=0;return k.forEach(X=>{T.set(new Uint8Array(X),B),B+=X.byteLength}),T.buffer}function et(k){for(k=k.trim();k.endsWith("/");)k=k.slice(0,k.length-1);const T=k.split("/");return T[T.length-1]}function Ve(k,P){const T={modelTopology:k.modelTopology,format:k.format,generatedBy:k.generatedBy,convertedBy:k.convertedBy,weightsManifest:P};return null!=k.signature&&(T.signature=k.signature),null!=k.userDefinedMetadata&&(T.userDefinedMetadata=k.userDefinedMetadata),null!=k.modelInitializer&&(T.modelInitializer=k.modelInitializer),null!=k.trainingConfig&&(T.trainingConfig=k.trainingConfig),T}function Ft(k,P,T){const B={modelTopology:k.modelTopology,format:k.format,generatedBy:k.generatedBy,convertedBy:k.convertedBy};if(null!=k.trainingConfig&&(B.trainingConfig=k.trainingConfig),null!=k.weightsManifest){if(!P)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!T)throw new Error("modelJSON has weightsManifest but weightData is null");B.weightSpecs=P,B.weightData=T}return null!=k.signature&&(B.signature=k.signature),null!=k.userDefinedMetadata&&(B.userDefinedMetadata=k.userDefinedMetadata),null!=k.modelInitializer&&(B.modelInitializer=k.modelInitializer),B}function Yt(k,P){return Zt.apply(this,arguments)}function Zt(){return(Zt=(0,ke.Z)(function*(k,P){let T,B;return null!=k.weightsManifest&&([T,B]=yield P(k.weightsManifest)),Ft(k,T,B)})).apply(this,arguments)}function yn(k){if(k.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==k.modelTopology?0:He(JSON.stringify(k.modelTopology)),weightSpecsBytes:null==k.weightSpecs?0:He(JSON.stringify(k.weightSpecs)),weightDataBytes:null==k.weightData?0:k.weightData.byteLength}}function Mn(k){const P=[];for(const T of k)P.push(...T.weights);return P}function un(){const k=function cr(){const k=T=>{let B=T<<13,X=0;for(;!(8388608&B);)X-=8388608,B<<=1;return B&=-8388609,X+=947912704,B|X},P=new Uint32Array(2048);P[0]=0;for(let T=1;T<1024;T++)P[T]=k(T);for(let T=1024;T<2048;T++)P[T]=939524096+(T-1024<<13);return P}(),P=function kn(){const k=new Uint32Array(64);k[0]=0,k[31]=1199570944,k[32]=2147483648,k[63]=3347054592;for(let P=1;P<31;P++)k[P]=P<<23;for(let P=33;P<63;P++)k[P]=2147483648+(P-32<<23);return k}(),T=function dn(){const k=new Uint32Array(64);for(let P=0;P<64;P++)k[P]=1024;return k[0]=k[32]=0,k}();return B=>{const X=new ArrayBuffer(4*B.length),ue=new Uint32Array(X);for(let fe=0;fe<B.length;fe++){const Le=B[fe];ue[fe]=k[T[Le>>10]+(1023&Le)]+P[Le>>10]}return new Float32Array(X)}}class Fn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Fn.instance&&(Fn.instance=new Fn),Fn.instance}static registerSaveRouter(P){Fn.getInstance().saveRouters.push(P)}static registerLoadRouter(P){Fn.getInstance().loadRouters.push(P)}static getSaveHandlers(P){return Fn.getHandlers(P,"save")}static getLoadHandlers(P,T){return Fn.getHandlers(P,"load",T)}static getHandlers(P,T,B){const X=[];return("load"===T?Fn.getInstance().loadRouters:Fn.getInstance().saveRouters).forEach(fe=>{const Le=fe(P,B);null!==Le&&X.push(Le)}),X}}const ds=k=>Fn.registerSaveRouter(k),Zn=k=>Fn.registerLoadRouter(k),Ne=k=>Fn.getSaveHandlers(k),rt=(k,P)=>Fn.getLoadHandlers(k,P),lt="tensorflowjs",wn="models_store",zn="model_info_store";function $r(){if(!(0,St.OB)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const k=typeof window>"u"?self:window,P=k.indexedDB||k.mozIndexedDB||k.webkitIndexedDB||k.msIndexedDB||k.shimIndexedDB;if(null==P)throw new Error("The current browser does not appear to support IndexedDB.");return P}function _r(k){const P=k.result;P.createObjectStore(wn,{keyPath:"modelPath"}),P.createObjectStore(zn,{keyPath:"modelPath"})}let qs=(()=>{class k{constructor(T){if(this.indexedDB=$r(),null==T||!T)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=T}save(T){var B=this;return(0,ke.Z)(function*(){if(T.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return B.databaseAction(B.modelPath,T)})()}load(){var T=this;return(0,ke.Z)(function*(){return T.databaseAction(T.modelPath)})()}databaseAction(T,B){return new Promise((X,ue)=>{const fe=this.indexedDB.open(lt,1);fe.onupgradeneeded=()=>_r(fe),fe.onsuccess=()=>{const Le=fe.result;if(null==B){const st=Le.transaction(wn,"readonly"),Tt=st.objectStore(wn).get(this.modelPath);Tt.onsuccess=()=>{if(null==Tt.result)return Le.close(),ue(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));X(Tt.result.modelArtifacts)},Tt.onerror=dt=>(Le.close(),ue(Tt.error)),st.oncomplete=()=>Le.close()}else{const st=yn(B),it=Le.transaction(zn,"readwrite");let Tt=it.objectStore(zn);const dt=Tt.put({modelPath:this.modelPath,modelArtifactsInfo:st});let ht;dt.onsuccess=()=>{ht=Le.transaction(wn,"readwrite");const on=ht.objectStore(wn).put({modelPath:this.modelPath,modelArtifacts:B,modelArtifactsInfo:st});on.onsuccess=()=>X({modelArtifactsInfo:st}),on.onerror=Sn=>{Tt=it.objectStore(zn);const Pn=Tt.delete(this.modelPath);Pn.onsuccess=()=>(Le.close(),ue(on.error)),Pn.onerror=lr=>(Le.close(),ue(on.error))}},dt.onerror=Mt=>(Le.close(),ue(dt.error)),it.oncomplete=()=>{null==ht?Le.close():ht.oncomplete=()=>Le.close()}}},fe.onerror=Le=>ue(fe.error)})}}return k.URL_SCHEME="indexeddb://",k})();const Ys=k=>(0,St.OB)().getBool("IS_BROWSER")&&!Array.isArray(k)&&k.startsWith(qs.URL_SCHEME)?function Yo(k){return new qs(k)}(k.slice(qs.URL_SCHEME.length)):null;Fn.registerSaveRouter(Ys),Fn.registerLoadRouter(Ys);class go{constructor(){this.indexedDB=$r()}listModels(){var P=this;return(0,ke.Z)(function*(){return new Promise((T,B)=>{const X=P.indexedDB.open(lt,1);X.onupgradeneeded=()=>_r(X),X.onsuccess=()=>{const ue=X.result,fe=ue.transaction(zn,"readonly"),st=fe.objectStore(zn).getAll();st.onsuccess=()=>{const it={};for(const Tt of st.result)it[Tt.modelPath]=Tt.modelArtifactsInfo;T(it)},st.onerror=it=>(ue.close(),B(st.error)),fe.oncomplete=()=>ue.close()},X.onerror=ue=>B(X.error)})})()}removeModel(P){var T=this;return(0,ke.Z)(function*(){return P=function Fr(k){return k.startsWith(qs.URL_SCHEME)?k.slice(qs.URL_SCHEME.length):k}(P),new Promise((B,X)=>{const ue=T.indexedDB.open(lt,1);ue.onupgradeneeded=()=>_r(ue),ue.onsuccess=()=>{const fe=ue.result,Le=fe.transaction(zn,"readwrite"),st=Le.objectStore(zn),it=st.get(P);let Tt;it.onsuccess=()=>{if(null==it.result)return fe.close(),X(new Error(`Cannot find model with path '${P}' in IndexedDB.`));{const dt=st.delete(P),ht=()=>{Tt=fe.transaction(wn,"readwrite");const on=Tt.objectStore(wn).delete(P);on.onsuccess=()=>B(it.result.modelArtifactsInfo),on.onerror=Sn=>X(it.error)};dt.onsuccess=ht,dt.onerror=Mt=>(ht(),fe.close(),X(it.error))}},it.onerror=dt=>(fe.close(),X(it.error)),Le.oncomplete=()=>{null==Tt?fe.close():Tt.oncomplete=()=>fe.close()}},ue.onerror=fe=>X(ue.error)})})()}}const os="/",is="tensorflowjs_models",Zo="info",bi="model_topology",Zs="weight_specs",oo="weight_data",mr="model_metadata";function Ao(k){return{info:[is,k,Zo].join(os),topology:[is,k,bi].join(os),weightSpecs:[is,k,Zs].join(os),weightData:[is,k,oo].join(os),modelMetadata:[is,k,mr].join(os)}}function nr(k){for(const P of Object.values(k))window.localStorage.removeItem(P)}function Ro(k){const P=k.split(os);if(P.length<3)throw new Error(`Invalid key format: ${k}`);return P.slice(1,P.length-1).join(os)}let Ur=(()=>{class k{constructor(T){if(!(0,St.OB)().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==T||!T)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=T,this.keys=Ao(this.modelPath)}save(T){var B=this;return(0,ke.Z)(function*(){if(T.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const X=JSON.stringify(T.modelTopology),ue=JSON.stringify(T.weightSpecs),fe=yn(T);try{return B.LS.setItem(B.keys.info,JSON.stringify(fe)),B.LS.setItem(B.keys.topology,X),B.LS.setItem(B.keys.weightSpecs,ue),B.LS.setItem(B.keys.weightData,function Me(k){if(x)return Buffer.from(k).toString("base64");const P=new Uint8Array(k);let T="";for(let B=0,X=P.length;B<X;B++)T+=String.fromCharCode(P[B]);return btoa(T)}(T.weightData)),B.LS.setItem(B.keys.modelMetadata,JSON.stringify({format:T.format,generatedBy:T.generatedBy,convertedBy:T.convertedBy,signature:null!=T.signature?T.signature:void 0,userDefinedMetadata:null!=T.userDefinedMetadata?T.userDefinedMetadata:void 0,modelInitializer:null!=T.modelInitializer?T.modelInitializer:void 0,trainingConfig:null!=T.trainingConfig?T.trainingConfig:void 0})),{modelArtifactsInfo:fe}}catch{throw nr(B.keys),new Error(`Failed to save model '${B.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${fe.modelTopologyBytes}, weightSpecsBytes=${fe.weightSpecsBytes}, weightDataBytes=${fe.weightDataBytes}.`)}}})()}load(){var T=this;return(0,ke.Z)(function*(){const B=JSON.parse(T.LS.getItem(T.keys.info));if(null==B)throw new Error(`In local storage, there is no model with name '${T.modelPath}'`);if("JSON"!==B.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const X={},ue=JSON.parse(T.LS.getItem(T.keys.topology));if(null==ue)throw new Error(`In local storage, the topology of model '${T.modelPath}' is missing.`);X.modelTopology=ue;const fe=JSON.parse(T.LS.getItem(T.keys.weightSpecs));if(null==fe)throw new Error(`In local storage, the weight specs of model '${T.modelPath}' are missing.`);X.weightSpecs=fe;const Le=T.LS.getItem(T.keys.modelMetadata);if(null!=Le){const it=JSON.parse(Le);X.format=it.format,X.generatedBy=it.generatedBy,X.convertedBy=it.convertedBy,null!=it.signature&&(X.signature=it.signature),null!=it.userDefinedMetadata&&(X.userDefinedMetadata=it.userDefinedMetadata),null!=it.modelInitializer&&(X.modelInitializer=it.modelInitializer),null!=it.trainingConfig&&(X.trainingConfig=it.trainingConfig)}const st=T.LS.getItem(T.keys.weightData);if(null==st)throw new Error(`In local storage, the binary weight values of model '${T.modelPath}' are missing.`);return X.weightData=function We(k){if(x){const B=Buffer.from(k,"base64");return B.buffer.slice(B.byteOffset,B.byteOffset+B.byteLength)}const P=atob(k),T=new Uint8Array(P.length);for(let B=0;B<P.length;++B)T.set([P.charCodeAt(B)],B);return T.buffer}(st),X})()}}return k.URL_SCHEME="localstorage://",k})();const Hn=k=>(0,St.OB)().getBool("IS_BROWSER")&&!Array.isArray(k)&&k.startsWith(Ur.URL_SCHEME)?function Bn(k){return new Ur(k)}(k.slice(Ur.URL_SCHEME.length)):null;Fn.registerSaveRouter(Hn),Fn.registerLoadRouter(Hn);class hr{constructor(){(0,$e.hu)((0,St.OB)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),(0,$e.hu)(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var P=this;return(0,ke.Z)(function*(){const T={},B=is+os,X=os+Zo;for(let ue=0;ue<P.LS.length;++ue){const fe=P.LS.key(ue);fe.startsWith(B)&&fe.endsWith(X)&&(T[Ro(fe)]=JSON.parse(P.LS.getItem(fe)))}return T})()}removeModel(P){var T=this;return(0,ke.Z)(function*(){const B=Ao(P=function Re(k){return k.startsWith(Ur.URL_SCHEME)?k.slice(Ur.URL_SCHEME.length):k}(P));if(null==T.LS.getItem(B.info))throw new Error(`Cannot find model at path '${P}'`);const X=JSON.parse(T.LS.getItem(B.info));return nr(B),X})()}}const Ir="://";class Pr{constructor(){this.managers={}}static getInstance(){return null==Pr.instance&&(Pr.instance=new Pr),Pr.instance}static registerManager(P,T){(0,$e.hu)(null!=P,()=>"scheme must not be undefined or null."),P.endsWith(Ir)&&(P=P.slice(0,P.indexOf(Ir))),(0,$e.hu)(P.length>0,()=>"scheme must not be an empty string.");const B=Pr.getInstance();(0,$e.hu)(null==B.managers[P],()=>`A model store manager is already registered for scheme '${P}'.`),B.managers[P]=T}static getManager(P){const T=Pr.getInstance().managers[P];if(null==T)throw new Error(`Cannot find model manager for scheme '${P}'`);return T}static getSchemes(){return Object.keys(Pr.getInstance().managers)}}function ws(k){if(-1===k.indexOf(Ir))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Pr.getSchemes().join(",")}`);return{scheme:k.split(Ir)[0],path:k.split(Ir)[1]}}function sn(k,P){return io.apply(this,arguments)}function io(){return(io=(0,ke.Z)(function*(k,P,T=!1){(0,$e.hu)(k!==P,()=>`Old path and new path are the same: '${k}'`);const B=Fn.getLoadHandlers(k);(0,$e.hu)(B.length>0,()=>`Copying failed because no load handler is found for source URL ${k}.`),(0,$e.hu)(B.length<2,()=>`Copying failed because more than one (${B.length}) load handlers for source URL ${k}.`);const X=B[0],ue=Fn.getSaveHandlers(P);(0,$e.hu)(ue.length>0,()=>`Copying failed because no save handler is found for destination URL ${P}.`),(0,$e.hu)(ue.length<2,()=>`Copying failed because more than one (${B.length}) save handlers for destination URL ${P}.`);const fe=ue[0],Le=ws(k).scheme,st=ws(k).path,it=Le===ws(k).scheme,Tt=yield X.load();T&&it&&(yield Pr.getManager(Le).removeModel(st));const dt=yield fe.save(Tt);return T&&!it&&(yield Pr.getManager(Le).removeModel(st)),dt.modelArtifactsInfo})).apply(this,arguments)}function Gr(){return Cs.apply(this,arguments)}function Cs(){return(Cs=(0,ke.Z)(function*(){const k=Pr.getSchemes(),P={};for(const T of k){const B=yield Pr.getManager(T).listModels();for(const X in B)P[T+Ir+X]=B[X]}return P})).apply(this,arguments)}function Vi(k){return Pt.apply(this,arguments)}function Pt(){return(Pt=(0,ke.Z)(function*(k){const P=ws(k);return Pr.getManager(P.scheme).removeModel(P.path)})).apply(this,arguments)}function Lr(k,P){return pn.apply(this,arguments)}function pn(){return(pn=(0,ke.Z)(function*(k,P){return sn(k,P,!1)})).apply(this,arguments)}function rr(k,P){return yo.apply(this,arguments)}function yo(){return(yo=(0,ke.Z)(function*(k,P){return sn(k,P,!0)})).apply(this,arguments)}class $a{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(P,T){return fetch(P,T)}now(){return performance.now()}encode(P,T){if("utf-8"!==T&&"utf8"!==T)throw new Error(`Browser's encoder only supports utf-8, but got ${T}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(P)}decode(P,T){return new TextDecoder(T).decode(P)}setTimeoutCustom(P,T){window&&(0,St.OB)().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(P),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},T),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",B=>{B.source===window&&B.data.name===this.messageName&&(B.stopPropagation(),(0,this.functionRefs[B.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0))):setTimeout(P,T)}}if((0,St.OB)().get("IS_BROWSER")){(0,St.OB)().setPlatform("browser",new $a);try{Pr.registerManager(Ur.URL_SCHEME,new hr)}catch{}try{Pr.registerManager(qs.URL_SCHEME,new go)}catch{}}let Us;(0,St.OB)().get("IS_NODE")&&!(0,St.OB)().get("IS_BROWSER")&&(0,St.OB)().setPlatform("node",new class ha{constructor(){this.util=M(8628),this.textEncoder=new this.util.TextEncoder}fetch(P,T){return null!=(0,St.OB)().global.fetch?(0,St.OB)().global.fetch(P,T):(null==Us&&(Us=M(5410)),Us(P,T))}now(){const P=process.hrtime();return 1e3*P[0]+P[1]/1e6}encode(P,T){if("utf-8"!==T&&"utf8"!==T)throw new Error(`Node built-in encoder only supports utf-8, but got ${T}`);return this.textEncoder.encode(P)}decode(P,T){return 0===P.length?"":new this.util.TextDecoder(T).decode(P)}});var ts=M(8621),wi=M(9734),Pa=M(4249),Wi=M(2174),Jo=M(708);function as(k){return new Promise(P=>setTimeout(P)).then(k)}(0,A.wv)(),(0,Jo.Vp)({buffer:ts.f,cast:wi.p,clone:Pa.d,print:Wi.S});let Qn=(()=>{class k{constructor(T){if(!(0,St.OB)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");T.startsWith(k.URL_SCHEME)&&(T=T.slice(k.URL_SCHEME.length)),(null==T||0===T.length)&&(T="model"),this.modelJsonFileName=T+".json",this.weightDataFileName=T+".weights.bin"}save(T){var B=this;return(0,ke.Z)(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const X=window.URL.createObjectURL(new Blob([T.weightData],{type:"application/octet-stream"}));if(T.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const fe=Ve(T,[{paths:["./"+B.weightDataFileName],weights:T.weightSpecs}]),Le=window.URL.createObjectURL(new Blob([JSON.stringify(fe)],{type:"application/json"})),st=null==B.modelJsonAnchor?document.createElement("a"):B.modelJsonAnchor;if(st.download=B.modelJsonFileName,st.href=Le,yield as(()=>st.dispatchEvent(new MouseEvent("click"))),null!=T.weightData){const it=null==B.weightDataAnchor?document.createElement("a"):B.weightDataAnchor;it.download=B.weightDataFileName,it.href=X,yield as(()=>it.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:yn(T)}}})()}}return k.URL_SCHEME="downloads://",k})();class hu{constructor(P){if(null==P||P.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${P}`);this.jsonFile=P[0],this.weightsFiles=P.slice(1)}load(){var P=this;return(0,ke.Z)(function*(){return new Promise((T,B)=>{const X=new FileReader;X.onload=ue=>{const fe=JSON.parse(ue.target.result),Le=fe.modelTopology;if(null==Le)return void B(new Error(`modelTopology field is missing from file ${P.jsonFile.name}`));if(null==fe.weightsManifest)return void B(new Error(`weightManifest field is missing from file ${P.jsonFile.name}`));if(0===P.weightsFiles.length)return void T({modelTopology:Le});const it=Yt(fe,Tt=>P.loadWeights(Tt));T(it)},X.onerror=ue=>B(`Failed to read model topology and weights manifest JSON from file '${P.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),X.readAsText(P.jsonFile)})})()}loadWeights(P){const T=[],B=[];for(const fe of P)T.push(...fe.weights),B.push(...fe.paths);const X=this.checkManifestAndWeightFiles(P),ue=B.map(fe=>this.loadWeightsFile(fe,X[fe]));return Promise.all(ue).then(fe=>[T,nt(fe)])}loadWeightsFile(P,T){return new Promise((B,X)=>{const ue=new FileReader;ue.onload=fe=>{B(fe.target.result)},ue.onerror=fe=>X(`Failed to weights data from file of path '${P}'.`),ue.readAsArrayBuffer(T)})}checkManifestAndWeightFiles(P){const T=[],B=this.weightsFiles.map(ue=>et(ue.name)),X={};for(const ue of P)ue.paths.forEach(fe=>{const Le=et(fe);if(-1!==T.indexOf(Le))throw new Error(`Duplicate file basename found in weights manifest: '${Le}'`);if(T.push(Le),-1===B.indexOf(Le))throw new Error(`Weight file with basename '${Le}' is not provided.`);X[fe]=this.weightsFiles[B.indexOf(Le)]});if(T.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${T.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return X}}function vn(k){return new hu(k)}function Ba(k,P,T,B){(function fe(st){(0,$e.hu)(null!=st&&Array.isArray(st)&&st.length>0,()=>"promises must be a none empty array")})(k),function Le(st,it){(0,$e.hu)(st>=0&&st<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${st}`),(0,$e.hu)(it>=0&&it<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${it}`),(0,$e.hu)(it>=st,()=>`startFraction must be no more than endFraction, but got startFraction ${st} and endFraction ${it}`)}(T=T??0,B=B??1);let X=0;return Promise.all(k.map(st=>(st.then(it=>{const Tt=T+ ++X/k.length*(B-T);return P(Tt),it}),st)))}function Ws(k,P){return Dr.apply(this,arguments)}function Dr(){return(Dr=(0,ke.Z)(function*(k,P){null==P&&(P={});const T=null==P.fetchFunc?(0,St.OB)().platform.fetch:P.fetchFunc,B=k.map(dt=>T(dt,P.requestInit,{isBinary:!0})),Le=(null==P.onProgress?yield Promise.all(B):yield Ba(B,P.onProgress,0,.5)).map(dt=>dt.arrayBuffer());return null==P.onProgress?yield Promise.all(Le):yield Ba(Le,P.onProgress,.5,1)})).apply(this,arguments)}function Br(k){return Ci.apply(this,arguments)}function Ci(){return(Ci=(0,ke.Z)(function*(k,P="",T,B){return Si(fe=>Ws(fe,{requestInit:B}))(k,P,T)})).apply(this,arguments)}function Si(k){return function(){var P=(0,ke.Z)(function*(T,B="",X){const ue=T.map(()=>!1),fe={},Le=null!=X?X.map(()=>!1):[],st=[];if(T.forEach((on,Sn)=>{let Pn=0;on.weights.forEach(lr=>{const Xt=Ce["quantization"in lr?lr.quantization.dtype:lr.dtype]*$e.NA(lr.shape),rs=()=>{ue[Sn]=!0,null==fe[Sn]&&(fe[Sn]=[]),fe[Sn].push({manifestEntry:lr,groupOffset:Pn,sizeBytes:Xt})};null!=X?X.forEach((Tn,Ri)=>{Tn===lr.name&&(rs(),Le[Ri]=!0)}):rs(),st.push(lr.name),Pn+=Xt})}),!Le.every(on=>on)){const on=X.filter((Sn,Pn)=>!Le[Pn]);throw new Error(`Could not find weights in manifest with names: ${on.join(", ")}. \nManifest JSON has weights with names: ${st.join(", ")}.`)}const it=ue.reduce((on,Sn,Pn)=>(Sn&&on.push(Pn),on),[]),Tt=[];it.forEach(on=>{T[on].paths.forEach(Sn=>{const Pn=B+(B.endsWith("/")?"":"/")+Sn;Tt.push(Pn)})});const dt=yield k(Tt),ht={};let Mt=0;return it.forEach(on=>{const Sn=T[on].paths.length;let Pn=0;for(let Tn=0;Tn<Sn;Tn++)Pn+=dt[Mt+Tn].byteLength;const lr=new ArrayBuffer(Pn),si=new Uint8Array(lr);let Xt=0;for(let Tn=0;Tn<Sn;Tn++){const Ri=new Uint8Array(dt[Mt+Tn]);si.set(Ri,Xt),Xt+=Ri.byteLength}fe[on].forEach(Tn=>{const xu=be(lr.slice(Tn.groupOffset,Tn.groupOffset+Tn.sizeBytes),[Tn.manifestEntry]);for(const Ka in xu)ht[Ka]=xu[Ka]}),Mt+=Sn}),ht});return function(T){return P.apply(this,arguments)}}()}Fn.registerSaveRouter(k=>(0,St.OB)().getBool("IS_BROWSER")&&!Array.isArray(k)&&k.startsWith(Qn.URL_SCHEME)?function fu(k="model"){return new Qn(k)}(k.slice(Qn.URL_SCHEME.length)):null);let Mo=(()=>{class k{constructor(T,B){if(this.DEFAULT_METHOD="POST",null==B&&(B={}),this.weightPathPrefix=B.weightPathPrefix,this.onProgress=B.onProgress,this.weightUrlConverter=B.weightUrlConverter,null!=B.fetchFunc?((0,$e.hu)("function"==typeof B.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=B.fetchFunc):this.fetch=(0,St.OB)().platform.fetch,(0,$e.hu)(null!=T&&T.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(T)&&(0,$e.hu)(2===T.length,()=>`URL paths for http must have a length of 2, (actual length is ${T.length}).`),this.path=T,null!=B.requestInit&&null!=B.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=B.requestInit||{}}save(T){var B=this;return(0,ke.Z)(function*(){if(T.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const X=Object.assign({method:B.DEFAULT_METHOD},B.requestInit);X.body=new FormData;const fe=Ve(T,[{paths:["./model.weights.bin"],weights:T.weightSpecs}]);X.body.append("model.json",new Blob([JSON.stringify(fe)],{type:"application/json"}),"model.json"),null!=T.weightData&&X.body.append("model.weights.bin",new Blob([T.weightData],{type:"application/octet-stream"}),"model.weights.bin");const Le=yield B.fetch(B.path,X);if(Le.ok)return{modelArtifactsInfo:yn(T),responses:[Le]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${Le.status}.`)})()}load(){var T=this;return(0,ke.Z)(function*(){const B=yield T.fetch(T.path,T.requestInit);if(!B.ok)throw new Error(`Request to ${T.path} failed with status code ${B.status}. Please verify this URL points to the model JSON of the model to load.`);let X;try{X=yield B.json()}catch{let st=`Failed to parse model JSON of response from ${T.path}.`;throw T.path.endsWith(".pb")?st+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":st+=" Please make sure the server is serving valid JSON for this request.",new Error(st)}if(null==X.modelTopology&&null==X.weightsManifest)throw new Error(`The JSON from HTTP path ${T.path} contains neither model topology or manifest for weights.`);return Yt(X,Le=>T.loadWeights(Le))})()}loadWeights(T){var B=this;return(0,ke.Z)(function*(){const X=Array.isArray(B.path)?B.path[1]:B.path,[ue,fe]=function Gi(k){const P=k.lastIndexOf("/"),T=k.lastIndexOf("?");return[k.substring(0,P)+"/",T>P?k.substring(T):""]}(X),Le=B.weightPathPrefix||ue,st=Mn(T),it=[],Tt=[];for(const ht of T)for(const Mt of ht.paths)null!=B.weightUrlConverter?Tt.push(B.weightUrlConverter(Mt)):it.push(Le+Mt+fe);return B.weightUrlConverter&&it.push(...yield Promise.all(Tt)),[st,nt(yield Ws(it,{requestInit:B.requestInit,fetchFunc:B.fetch,onProgress:B.onProgress}))]})()}}return k.URL_SCHEME_REGEX=/^https?:\/\//,k})();function Ki(k){return null!=k.match(Mo.URL_SCHEME_REGEX)}const mn=(k,P)=>{if(typeof fetch>"u"&&(null==P||null==P.fetchFunc))return null;{let T=!0;if(T=Array.isArray(k)?k.every(B=>Ki(B)):Ki(k),T)return ei(k,P)}return null};function ei(k,P){return new Mo(k,P)}function Ei(k,P){return ei(k,P)}Fn.registerSaveRouter(mn),Fn.registerLoadRouter(mn);class Kr{constructor(P){this.modelArtifacts=P}load(){return this.modelArtifacts}}class $o{constructor(P){this.saveHandler=P}save(P){return this.saveHandler(P)}}class ma{constructor(P){P.load&&(this.load=()=>Promise.resolve(P.load())),P.save&&(this.save=T=>Promise.resolve(P.save(T)))}}function fr(k,P,T,B){return new ma(Fo(...arguments))}function Fo(k,P,T,B){return 1===arguments.length?null!=k.modelTopology||null!=k.weightSpecs?new Kr(k):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Kr({modelTopology:k})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Kr({modelTopology:k,weightSpecs:P,weightData:T,trainingConfig:B}))}function Va(k){return new $o(k)}function ao(k){return new $o(k)}var _=M(9608),V=M(341),U=M(2738),he=M(6721),qe=M(9540);const je=(0,he.op)({confusionMatrix_:function ct(k,P,T){const B=(0,_._1)(k,"labels","confusionMatrix"),X=(0,_._1)(P,"predictions","confusionMatrix");$e.hu(null==T||T>0&&Number.isInteger(T),()=>`If provided, numClasses must be a positive integer, but got ${T}`),$e.hu(1===B.rank,()=>`Expected the rank of labels to be 1, but got ${B.rank}`),$e.hu(1===X.rank,()=>`Expected the rank of predictions to be 1, but got ${X.rank}`),$e.hu(B.shape[0]===X.shape[0],()=>`Mismatch in the number of examples: ${B.shape[0]} vs. ${X.shape[0]}. Labels and predictions should have the same number of elements.`),$e.hu(T>0&&Number.isInteger(T),()=>`numClasses is required to be a positive integer, but got ${T}`);const ue=(0,U.l)((0,wi.p)(B,"int32"),T),fe=(0,U.l)((0,wi.p)(X,"int32"),T),Le=(0,qe.p)(ue),st=(0,V.O)(Le,fe);return(0,wi.p)(st,"int32")}});var at=M(258),ge=M(1070),Lt=M(9464),kt=M(3157);let Un;function v(k,P=3){if(P>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==k)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let T=!1,B=!1,X=!1,ue=!1,fe=!1,Le=!1;if(k.data instanceof Uint8Array)T=!0;else if(typeof ImageData<"u"&&k instanceof ImageData)B=!0;else if(typeof HTMLVideoElement<"u"&&k instanceof HTMLVideoElement)X=!0;else if(typeof HTMLImageElement<"u"&&k instanceof HTMLImageElement)ue=!0;else if(null!=k.getContext)fe=!0;else{if(!(typeof ImageBitmap<"u"&&k instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${k.constructor.name}`);Le=!0}if(null!=(0,Lt.pI)(ge.eBW,A.BV.backendName))return A.BV.runKernel(ge.eBW,{pixels:k},{numChannels:P});const[it,Tt]=X?[k.videoWidth,k.videoHeight]:[k.width,k.height];let dt,ht;if(fe)dt=k.getContext("2d").getImageData(0,0,it,Tt).data;else if(B||T)dt=k.data;else if(ue||X||Le){if(null==Un)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Un=new OffscreenCanvas(1,1).getContext("2d")}else Un=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Un.canvas.width=it,Un.canvas.height=Tt,Un.drawImage(k,0,0,it,Tt),dt=Un.getImageData(0,0,it,Tt).data}if(4===P)ht=new Int32Array(dt);else{const on=it*Tt;ht=new Int32Array(on*P);for(let Sn=0;Sn<on;Sn++)for(let Pn=0;Pn<P;++Pn)ht[Sn*P+Pn]=dt[4*Sn+Pn]}return(0,kt.w)(ht,[Tt,it,P],"int32")}function K(k){return ae.apply(this,arguments)}function ae(){return(ae=(0,ke.Z)(function*(k,P=3){let T=null;if((0,St.OB)().getBool("WRAP_TO_IMAGEBITMAP")&&function G(k){return function g(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}()&&!(k instanceof ImageBitmap)&&function C(k){return null!=k&&0!==k.width&&0!==k.height}(k)&&!function p(k){return null!=k&&k.data instanceof Uint8Array}(k)}(k)){let B;try{B=yield createImageBitmap(k,{premultiplyAlpha:"none"})}catch{B=null}T=null!=B&&B.width===k.width&&B.height===k.height?B:k}else T=k;return v(T,P)})).apply(this,arguments)}function oe(k,P){return Ue.apply(this,arguments)}function Ue(){return(Ue=(0,ke.Z)(function*(k,P){let T=(0,_._1)(k,"img","toPixels");if(!(k instanceof Jo.es)){const it=T;T=(0,wi.p)(it,"int32"),it.dispose()}if(2!==T.rank&&3!==T.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${T.rank}.`);const[B,X]=T.shape.slice(0,2),ue=2===T.rank?1:T.shape[2];if(ue>4||2===ue)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${ue}`);if("float32"!==T.dtype&&"int32"!==T.dtype)throw new Error(`Unsupported type for toPixels: ${T.dtype}. Please use float32 or int32 tensors.`);const fe=yield T.data(),Le="float32"===T.dtype?255:1,st=new Uint8ClampedArray(X*B*4);for(let it=0;it<B*X;++it){const Tt=[0,0,0,255];for(let ht=0;ht<ue;ht++){const Mt=fe[it*ue+ht];if("float32"===T.dtype){if(Mt<0||Mt>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${Mt}.`)}else if("int32"===T.dtype&&(Mt<0||Mt>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${Mt}.`);1===ue?(Tt[0]=Mt*Le,Tt[1]=Mt*Le,Tt[2]=Mt*Le):Tt[ht]=Mt*Le}const dt=4*it;st[dt+0]=Math.round(Tt[0]),st[dt+1]=Math.round(Tt[1]),st[dt+2]=Math.round(Tt[2]),st[dt+3]=Math.round(Tt[3])}if(null!=P){P.width=X,P.height=B;const it=P.getContext("2d"),Tt=new ImageData(st,X,B);it.putImageData(Tt,0,0)}return T!==k&&T.dispose(),st})).apply(this,arguments)}const ut=(0,he.op)({fromPixels_:v});function tt(k,P){const T=k.shape.length,B=P.shape.length;if(T<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${T}.`);if(B<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${B}.`);if("int32"!==P.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${P.dtype}.`);if(P.shape[B-1]>T)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${P.shape[B-1]} vs. ${T}`);if(0===(0,$e.NA)(k.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${k.shape}.`);const X=P.shape,ue=X[X.length-1];let fe=1;for(let dt=0;dt<X.length-1;++dt)fe*=X[dt];const Le=k.shape,st=X.slice();st.pop();let it=1;for(let dt=ue;dt<T;++dt)it*=Le[dt],st.push(Le[dt]);const Tt=[...(0,$e.e3)(k.shape).map(dt=>dt/it),1].slice(0,ue);return[st,fe,it,Tt]}var Je=M(2808);const bt=-2,Wt=-1;function Gt(k,P,T){const B=k.shape.length;$e.hu(B===P.length,()=>`Error in slice${B}D: Length of begin ${P} must match the rank of the array (${B}).`),$e.hu(B===T.length,()=>`Error in slice${B}D: Length of size ${T} must match the rank of the array (${B}).`);for(let X=0;X<B;++X)$e.hu(P[X]+T[X]<=k.shape[X],()=>`Error in slice${B}D: begin[${X}] + size[${X}] (${P[X]+T[X]}) would overflow input.shape[${X}] (${k.shape[X]})`)}function Ht(k){const P=[];let T=0;for(;k>0;)1&k&&P.push(T),k/=2,T++;return P}function ln(k,P,T){const B=[];for(let X=0;X<k.length;X++)B[X]=Math.ceil((P[X]-k[X])/T[X]);return B}function xr(k,P,T,B){const X=[...k];for(let ue=X.length;ue<B.length;ue++)X.push(1);for(let ue=0;ue<T;ue++)0===ue?X[P]=1:(X.splice(P,0,1),X.pop());return X}function zs(k,P,T){return T<=k?T:T-(P-1)}function ns(k,P){const T=[];for(let B=0;B<k;B++)T.push(P+B);return T}function kr(k,P,T,B,X,ue,fe,Le,st){const it=k.length;let Tt=new Array(it),dt=new Array(it),ht=new Array(it);if(P.length&&T>0){const Mt=P[0],on=T+1;Tt=Po(fe,Mt,on,B,k),dt=_i(Le,Mt,on,X,k),ht=xr(ue,Mt,on,k)}else for(let Mt=0;Mt<it;Mt++)Tt[Mt]=Hu(fe,B,ue,k,Mt,st),dt[Mt]=pu(Le,X,ue,k,Mt,st),ht[Mt]=Hs(ue,Mt,st);return{begin:Tt,end:dt,strides:ht}}function Po(k,P,T,B,X){const ue=[...X],fe=ns(T,P);for(let Le=0;Le<ue.length;Le++)if(fe.indexOf(Le)>-1)ue[Le]=0;else{const st=zs(P,T,Le);let it=B[st];k&1<<st&&(it=0),ue[Le]=it}return ue}function _i(k,P,T,B,X){const ue=[...X],fe=ns(T,P);for(let Le=0;Le<ue.length;Le++)if(fe.indexOf(Le)>-1)ue[Le]=Number.MAX_SAFE_INTEGER;else{const st=zs(P,T,Le);let it=B[st];k&1<<st&&(it=Number.MAX_SAFE_INTEGER),ue[Le]=it}for(let Le=0;Le<ue.length;Le++)ue[Le]<0&&(ue[Le]+=X[Le]),ue[Le]=$e.uZ(0,ue[Le],X[Le]);return ue}function Hs(k,P,T){let B=k[P];return(T&1<<P||null==B)&&(B=1),B}function Hu(k,P,T,B,X,ue){let fe=P[X];(k&1<<X||ue&1<<X||null==fe)&&(fe=(T[X]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const st=B[X];return fe<0&&(fe+=st),fe=$e.uZ(0,fe,st-1),fe}function pu(k,P,T,B,X,ue){let fe=P[X];const Le=T[X]||1;(k&1<<X||ue&1<<X||null==fe)&&(fe=Le>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const st=B[X];return fe<0&&(fe+=st),fe=Le>0?$e.uZ(0,fe,st):$e.uZ(-1,fe,st-1),fe}function Es(k,P,T){let B=T.length;for(let X=0;X<T.length;X++)if(T[X]>1){B=X;break}for(let X=B+1;X<T.length;X++)if(P[X]>0||T[X]!==k[X])return!1;return!0}function Qs(k,P){let T=k.length>0?k[k.length-1]:1;for(let B=0;B<k.length-1;B++)T+=k[B]*P[B];return T}function br(k,P,T){let B;const X=k.shape.length;let ue;return B="number"==typeof P?[P,...new Array(X-1).fill(0)]:P.length<X?P.concat(new Array(X-P.length).fill(0)):P.slice(),B.forEach(fe=>{$e.hu(-1!==fe,()=>"slice() does not support negative begin indexing.")}),ue=null==T?new Array(X).fill(-1):"number"==typeof T?[T,...new Array(X-1).fill(-1)]:T.length<X?T.concat(new Array(X-T.length).fill(-1)):T,ue=ue.map((fe,Le)=>fe>=0?fe:($e.hu(-1===fe,()=>`Negative size values should be exactly -1 but got ${fe} for the slice() size at index ${Le}.`),k.shape[Le]-B[Le])),[B,ue]}function Os(k,P,T,B,X,ue,fe,Le,st){let it;if(null==B?(it=new Array(P.length),it.fill(1)):it=B,null!=fe&&fe&fe-1)throw new Error("Multiple ellipses in slice is not allowed.");let Tt=!1;const dt={dims:it.length,numAddAxisAfterEllipsis:0,begin:P.slice(),end:T.slice(),strides:it.slice(),beginMask:X,endMask:ue,ellipsisMask:fe,newAxisMask:Le,shrinkAxisMask:st};for(let Xt=0;Xt<dt.dims;Xt++)Tt&&1<<Xt&Le&&dt.numAddAxisAfterEllipsis++,1<<Xt&fe&&(Tt=!0);Tt||(dt.ellipsisMask|=1<<dt.dims,dt.dims++);const ht={dims:k.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function Ms(k,P){P.beginMask=0,P.endMask=0,P.shrinkAxisMask=0;let T=0;P.beginValid=null!=k.begin,P.endValid=null!=k.end,P.begin=new Array(P.dims),P.end=new Array(P.dims),P.strides=new Array(P.dims),P.finalShapeGatherIndices=[],P.finalShapeGatherIndicesSparse=[],P.inputShapeGatherIndicesSparse=new Array(P.dims);for(let B=0;B<k.dims;B++)if(1<<B&k.ellipsisMask){const X=Math.min(P.dims-(k.dims-B)+1+k.numAddAxisAfterEllipsis,P.dims);for(;T<X;T++)P.begin[T]=0,P.end[T]=0,P.strides[T]=1,P.beginMask|=1<<T,P.endMask|=1<<T,P.finalShapeGatherIndices.push(T),P.finalShapeGatherIndicesSparse.push(-1),P.inputShapeGatherIndicesSparse[T]=B}else if(1<<B&k.newAxisMask)P.finalShapeGatherIndices.push(bt),P.finalShapeGatherIndicesSparse.push(-1);else{if(T===P.begin.length)throw Error(`Index out of range using input dim ${T}; input has only ${P.dims} dims, ${P.begin.length}.`);null!=k.begin&&(P.begin[T]=k.begin[B]),null!=k.end&&(P.end[T]=k.end[B]),P.strides[T]=k.strides[B],k.beginMask&1<<B&&(P.beginMask|=1<<T),k.endMask&1<<B&&(P.endMask|=1<<T),k.shrinkAxisMask&1<<B?(P.finalShapeGatherIndices.push(Wt),P.finalShapeGatherIndicesSparse.push(-1),P.shrinkAxisMask|=1<<T):(P.finalShapeGatherIndices.push(T),P.finalShapeGatherIndicesSparse.push(B)),P.inputShapeGatherIndicesSparse[T]=B,T++}}(dt,ht);let Mt=!0,on=!0,Sn=!0;const Pn=[],lr=[];for(let Xt=0;Xt<k.length;++Xt){if(0===ht.strides[Xt])throw Error(`strides[${Xt}] must be non-zero`);const rs=!!(ht.shrinkAxisMask&1<<Xt),Tn=k[Xt];if(-1===Tn){Pn.push(rs?1:-1);continue}const Ri=[ht.beginMask&1<<Xt,ht.endMask&1<<Xt],xu=[ht.strides[Xt]>0?0:-1,ht.strides[Xt]>0?Tn:Tn-1];if(rs&&ht.strides[Xt]<=0)throw Error("only stride 1 allowed on non-range indexing.");Sn=Sn&&1===ht.strides[Xt];const Ka=!!(ht.beginMask&1<<Xt&&ht.endMask&1<<Xt);if(ht.beginValid&&ht.endValid){if(rs){const qa=ht.begin[Xt]<0?Tn+ht.begin[Xt]:ht.begin[Xt];if(ht.begin[Xt]=qa,ht.end[Xt]=ht.begin[Xt]+1,qa<0||qa>=Tn)throw Error(`slice index ${ht.begin[Xt]} of dimension ${Xt} out of bounds.`)}else ht.begin[Xt]=ga(ht.begin[Xt],0,ht.strides[Xt],Tn,Ri,xu),ht.end[Xt]=ga(ht.end[Xt],1,ht.strides[Xt],Tn,Ri,xu);const Xa=1===ht.strides[Xt]&&0===ht.begin[Xt]&&ht.end[Xt]===Tn;Mt=Mt&&Xa,on=on&&(0===Xt&&1===ht.strides[Xt]||Xa)}else Mt=Mt&&1===ht.strides[Xt]&&Ka,on=on&&(0===Xt&&1===ht.strides[Xt]||Ka);let Ji,qu=!1;if(ht.beginValid&&ht.endValid?(Ji=ht.end[Xt]-ht.begin[Xt],qu=!0):rs?(Ji=1,qu=!0):Ka&&Tn>=0&&(Ji=ht.strides[Xt]<0?-Tn:Tn,qu=!0),qu){let Xa;Xa=0===Ji||Ji<0!=ht.strides[Xt]<0?0:Math.trunc(Ji/ht.strides[Xt])+(Ji%ht.strides[Xt]!=0?1:0),Pn.push(Xa)}else Pn.push(-1)}for(let Xt=0;Xt<ht.finalShapeGatherIndices.length;++Xt){const rs=ht.finalShapeGatherIndices[Xt];rs>=0?lr.push(Pn[rs]):rs===bt&&lr.push(1)}return{finalShapeSparse:lr.filter((Xt,rs)=>ht.finalShapeGatherIndices[rs]!==bt),finalShape:lr,isIdentity:Mt,sliceDim0:on,isSimpleSlice:Sn,begin:ht.begin,end:ht.end,strides:ht.strides}}function ga(k,P,T,B,X,ue){if(X[P])return T>0?ue[P]:ue[P+1&1];{const fe=k<0?B+k:k;return fe<ue[0]?ue[0]:fe>ue[1]?ue[1]:fe}}class Js{getClassName(){return this.constructor.className}static fromConfig(P,T){return new P(T)}}class Ii{constructor(){this.classNameMap={}}static getMap(){return null==Ii.instance&&(Ii.instance=new Ii),Ii.instance}static register(P){Ii.getMap().classNameMap[P.className]=[P,P.fromConfig]}}function Di(k){(0,$e.hu)(null!=k.className,()=>"Class being registered does not have the static className property defined."),(0,$e.hu)("string"==typeof k.className,()=>"className is required to be a string, but got type "+typeof k.className),(0,$e.hu)(k.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Ii.register(k)}var Xi=M(7904),vo=M(8813);const Jt=.001,_n=.1;function Cr(k,P,T){return null==T&&(T=uo()),ti(k,P,(B,X)=>Wa(B,X,T))}function uo(){return 32===A.BV.backend.floatPrecision()?Jt:_n}function ti(k,P,T){let B=!0;if(((0,$e.fU)(k)||(0,$e.fU)(P))&&(B=!1),(0,$e.fU)(k)&&(0,$e.fU)(P)&&(B=!0),B){const fe=k.constructor.name,Le=P.constructor.name;if(fe!==Le)throw new Error(`Arrays are of different type. Actual: ${fe}. Expected: ${Le}`)}if(Array.isArray(k)&&Array.isArray(P)){const fe=(0,_.C)(k),Le=(0,_.C)(P);if(!(0,$e.cO)(fe,Le))throw new Error(`Arrays have different shapes. Actual: [${fe}]. Expected: [${Le}]`)}const X=(0,$e.fU)(k)?k:(0,$e.xH)(k),ue=(0,$e.fU)(P)?P:(0,$e.xH)(P);if(X.length!==ue.length)throw new Error(`Arrays have different lengths actual: ${X.length} vs expected: ${ue.length}.\nActual:   ${X}.\nExpected: ${ue}.`);for(let fe=0;fe<ue.length;++fe){const Le=X[fe],st=ue[fe];if(!T(Le,st))throw new Error(`Arrays differ: actual[${fe}] = ${Le}, expected[${fe}] = ${st}.\nActual:   ${X}.\nExpected: ${ue}.`)}typeof expect<"u"&&expect().nothing()}function $s(k,P){k().then(()=>P.fail(),()=>P()),typeof expect<"u"&&expect().nothing()}function Ua(k,P){const T="string"==typeof P||"number"==typeof P||"boolean"==typeof P?[P]:P;return(0,$e.HD)(k)||(0,$e.HD)(k[0])||(0,$e.HD)(P)||(0,$e.HD)(P[0])?ti(k,T,(B,X)=>B==X):ti(k,P,(B,X)=>Wa(B,X,0))}function Cn(k,P,T){if(null==T&&(T=uo()),!Wa(k,P,T))throw new Error(`Numbers differ: actual === ${k}, expected === ${P}`);typeof expect<"u"&&expect().nothing()}function Wa(k,P,T){return!isFinite(k)&&!isFinite(P)||!(isNaN(k)||isNaN(P)||Math.abs(k-P)>T)}function ju(k,P,T){for(let B=0;B<k.length;B++)if(k[B]<P||k[B]>T)throw new Error(`Value out of range:${k[B]} low: ${P}, high: ${T}`)}function Kn(k,P){const T=new Float32Array(k),B=new Float32Array(P);if(T.length!==B.length)throw new Error(`Expected ArrayBuffer to be of length ${B.length}, but it was ${T.length}`);for(let X=0;X<B.length;X++)if(T[X]!==B[X])throw new Error(`Expected ArrayBuffer value at ${X} to be ${B[X]} but got ${T[X]} instead`)}function mu(k){for(let P=0;P<k.length;P++){const T=k[P];Array.isArray(T)?mu(T):k[P]=(0,vo.encodeString)(T)}return k}function gu(k){const P=document.createElement("video");return"playsInline"in P&&(P.playsInline=!0),P.muted=!0,P.loop=!0,P.style.position="fixed",P.style.left="0px",P.style.top="0px",P.preload="auto",P.appendChild(k),new Promise(T=>{P.addEventListener("loadeddata",B=>T(P)),P.load()})}function yu(k){return qi.apply(this,arguments)}function qi(){return(qi=(0,ke.Z)(function*(k){yield k.play(),"requestVideoFrameCallback"in k&&(yield new Promise(P=>{k.requestVideoFrameCallback(P)}))})).apply(this,arguments)}const _s="3.21.0";var fn=M(9370),sr=M(6849),us=M(6635),qn=M(8788),ni=M(5562),gr=M(4164),Lo=M(37),Ti=M(1335),Yi=M(316);class xo extends Js{minimize(P,T=!1,B){const{value:X,grads:ue}=this.computeGradients(P,B);if(null!=B){const fe=B.map(Le=>({name:Le.name,tensor:ue[Le.name]}));this.applyGradients(fe)}else this.applyGradients(ue);return(0,fn.B9)(ue),T?X:(X.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(P,T){return(0,Ti.pn)(P,T)}dispose(){null!=this.iterations_&&(0,fn.B9)(this.iterations_)}saveIterations(){var P=this;return(0,ke.Z)(function*(){return null==P.iterations_&&(P.iterations_=0),{name:"iter",tensor:(0,Yi.i)(P.iterations_,"int32")}})()}getWeights(){return(0,ke.Z)(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(P){var T=this;return(0,ke.Z)(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${T.getClassName()}`)})()}extractIterations(P){var T=this;return(0,ke.Z)(function*(){return T.iterations_=(yield P[0].tensor.data())[0],P.slice(1)})()}}Object.defineProperty(xo,Symbol.hasInstance,{value:k=>null!=k.minimize&&null!=k.computeGradients&&null!=k.applyGradients});let ya=(()=>{class k extends xo{constructor(T,B,X=null){super(),this.learningRate=T,this.rho=B,this.epsilon=X,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==X&&(this.epsilon=A.BV.backend.epsilon())}applyGradients(T){(Array.isArray(T)?T.map(X=>X.name):Object.keys(T)).forEach((X,ue)=>{const fe=A.BV.registeredVariables[X];null==this.accumulatedGrads[ue]&&(this.accumulatedGrads[ue]={originalName:`${X}/accum_grad`,variable:(0,fn.lu)(()=>(0,Lo.P)(fe).variable(!1))}),null==this.accumulatedUpdates[ue]&&(this.accumulatedUpdates[ue]={originalName:`${X}/accum_var`,variable:(0,fn.lu)(()=>(0,Lo.P)(fe).variable(!1))});const st=Array.isArray(T)?T[ue].tensor:T[X];if(null==st)return;const it=this.accumulatedGrads[ue].variable,Tt=this.accumulatedUpdates[ue].variable;(0,fn.lu)(()=>{const dt=(0,sr.I)((0,qn.d)(it,this.rho),(0,qn.d)((0,gr.h)(st),1-this.rho)),ht=(0,qn.d)((0,us.h)((0,ni._)((0,sr.I)(Tt,this.epsilon)),(0,ni._)((0,sr.I)(it,this.epsilon))),st),Mt=(0,sr.I)((0,qn.d)(Tt,this.rho),(0,qn.d)((0,gr.h)(ht),1-this.rho));it.assign(dt),Tt.assign(Mt);const on=(0,sr.I)((0,qn.d)(ht,-this.learningRate),fe);fe.assign(on)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,fn.B9)(this.accumulatedGrads.map(T=>T.variable)),(0,fn.B9)(this.accumulatedUpdates.map(T=>T.variable)))}getWeights(){var T=this;return(0,ke.Z)(function*(){const B=[...T.accumulatedGrads,...T.accumulatedUpdates];return[yield T.saveIterations()].concat(B.map(X=>({name:X.originalName,tensor:X.variable})))})()}setWeights(T){var B=this;return(0,ke.Z)(function*(){const X=(T=yield B.extractIterations(T)).length/2;B.accumulatedGrads=T.slice(0,X).map(fe=>({originalName:fe.name,variable:fe.tensor.variable(!1)})),B.accumulatedUpdates=T.slice(X,2*X).map(fe=>({originalName:fe.name,variable:fe.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(T,B){return new T(B.learningRate,B.rho,B.epsilon)}}return k.className="Adadelta",k})();Di(ya);var za=M(8509);let fs=(()=>{class k extends xo{constructor(T,B=.1){super(),this.learningRate=T,this.initialAccumulatorValue=B,this.accumulatedGrads=[]}applyGradients(T){(Array.isArray(T)?T.map(X=>X.name):Object.keys(T)).forEach((X,ue)=>{const fe=A.BV.registeredVariables[X];null==this.accumulatedGrads[ue]&&(this.accumulatedGrads[ue]={originalName:`${X}/accumulator`,variable:(0,fn.lu)(()=>(0,za.h)(fe.shape,this.initialAccumulatorValue).variable(!1))});const Le=Array.isArray(T)?T[ue].tensor:T[X];if(null==Le)return;const st=this.accumulatedGrads[ue].variable;(0,fn.lu)(()=>{const it=(0,sr.I)(st,(0,gr.h)(Le));st.assign(it);const Tt=(0,sr.I)((0,qn.d)((0,us.h)(Le,(0,ni._)((0,sr.I)(it,A.BV.backend.epsilon()))),-this.learningRate),fe);fe.assign(Tt)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,fn.B9)(this.accumulatedGrads.map(T=>T.variable))}getWeights(){var T=this;return(0,ke.Z)(function*(){return[yield T.saveIterations()].concat(T.accumulatedGrads.map(B=>({name:B.originalName,tensor:B.variable})))})()}setWeights(T){var B=this;return(0,ke.Z)(function*(){T=yield B.extractIterations(T),B.accumulatedGrads=T.map(ue=>({originalName:ue.name,variable:ue.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(T,B){return new T(B.learningRate,B.initialAccumulatorValue)}}return k.className="Adagrad",k})();Di(fs);var qd=M(9043),ps=M(8578);let eo=(()=>{class k extends xo{constructor(T,B,X,ue=null){super(),this.learningRate=T,this.beta1=B,this.beta2=X,this.epsilon=ue,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,fn.lu)(()=>{this.accBeta1=(0,Yi.i)(B).variable(),this.accBeta2=(0,Yi.i)(X).variable()}),null==ue&&(this.epsilon=A.BV.backend.epsilon())}applyGradients(T){const B=Array.isArray(T)?T.map(X=>X.name):Object.keys(T);(0,fn.lu)(()=>{const X=(0,ps.l)(1,this.accBeta1),ue=(0,ps.l)(1,this.accBeta2);B.forEach((fe,Le)=>{const st=A.BV.registeredVariables[fe];null==this.accumulatedFirstMoment[Le]&&(this.accumulatedFirstMoment[Le]={originalName:`${fe}/m`,variable:(0,fn.lu)(()=>(0,Lo.P)(st).variable(!1))}),null==this.accumulatedSecondMoment[Le]&&(this.accumulatedSecondMoment[Le]={originalName:`${fe}/v`,variable:(0,fn.lu)(()=>(0,Lo.P)(st).variable(!1))});const Tt=Array.isArray(T)?T[Le].tensor:T[fe];if(null==Tt)return;const dt=this.accumulatedFirstMoment[Le].variable,ht=this.accumulatedSecondMoment[Le].variable,Mt=(0,sr.I)((0,qn.d)(dt,this.beta1),(0,qn.d)(Tt,1-this.beta1)),on=(0,sr.I)((0,qn.d)(ht,this.beta2),(0,qn.d)((0,gr.h)(Tt),1-this.beta2)),Sn=(0,us.h)(Mt,X),Pn=(0,us.h)(on,ue);dt.assign(Mt),ht.assign(on);const lr=(0,sr.I)((0,qn.d)((0,us.h)(Sn,(0,sr.I)((0,ni._)(Pn),this.epsilon)),-this.learningRate),st);st.assign(lr)}),this.accBeta1.assign((0,qn.d)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,qn.d)(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,fn.B9)(this.accumulatedFirstMoment.map(T=>T.variable)),null!=this.accumulatedSecondMoment&&(0,fn.B9)(this.accumulatedSecondMoment.map(T=>T.variable))}getWeights(){var T=this;return(0,ke.Z)(function*(){const B=[...T.accumulatedFirstMoment,...T.accumulatedSecondMoment];return[yield T.saveIterations()].concat(B.map(X=>({name:X.originalName,tensor:X.variable})))})()}setWeights(T){var B=this;return(0,ke.Z)(function*(){T=yield B.extractIterations(T),(0,fn.lu)(()=>{B.accBeta1.assign((0,qd.s)(B.beta1,B.iterations_+1)),B.accBeta2.assign((0,qd.s)(B.beta2,B.iterations_+1))});const X=T.length/2;B.accumulatedFirstMoment=T.slice(0,X).map(fe=>({originalName:fe.name,variable:fe.tensor.variable(!1)})),B.accumulatedSecondMoment=T.slice(X,2*X).map(fe=>({originalName:fe.name,variable:fe.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(T,B){return new T(B.learningRate,B.beta1,B.beta2,B.epsilon)}}return k.className="Adam",k})();Di(eo);var Ha=M(2519),ri=M(6825);let co=(()=>{class k extends xo{constructor(T,B,X,ue=null,fe=0){super(),this.learningRate=T,this.beta1=B,this.beta2=X,this.epsilon=ue,this.decay=fe,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,fn.lu)(()=>{this.iteration=(0,Yi.i)(0).variable(),this.accBeta1=(0,Yi.i)(B).variable()}),null==ue&&(this.epsilon=A.BV.backend.epsilon())}applyGradients(T){const B=Array.isArray(T)?T.map(X=>X.name):Object.keys(T);(0,fn.lu)(()=>{const X=(0,ps.l)(1,this.accBeta1),ue=(0,us.h)(-this.learningRate,(0,sr.I)((0,qn.d)(this.iteration,this.decay),1));B.forEach((fe,Le)=>{const st=A.BV.registeredVariables[fe];null==this.accumulatedFirstMoment[Le]&&(this.accumulatedFirstMoment[Le]={originalName:`${fe}/m`,variable:(0,Lo.P)(st).variable(!1)}),null==this.accumulatedWeightedInfNorm[Le]&&(this.accumulatedWeightedInfNorm[Le]={originalName:`${fe}/v`,variable:(0,Lo.P)(st).variable(!1)});const Tt=Array.isArray(T)?T[Le].tensor:T[fe];if(null==Tt)return;const dt=this.accumulatedFirstMoment[Le].variable,ht=this.accumulatedWeightedInfNorm[Le].variable,Mt=(0,sr.I)((0,qn.d)(dt,this.beta1),(0,qn.d)(Tt,1-this.beta1)),on=(0,qn.d)(ht,this.beta2),Sn=(0,Ha.W)(Tt),Pn=(0,ri.g)(on,Sn);dt.assign(Mt),ht.assign(Pn);const lr=(0,sr.I)((0,qn.d)((0,us.h)(ue,X),(0,us.h)(Mt,(0,sr.I)(Pn,this.epsilon))),st);st.assign(lr)}),this.iteration.assign((0,sr.I)(this.iteration,1)),this.accBeta1.assign((0,qn.d)(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,fn.B9)(this.accumulatedFirstMoment.map(T=>T.variable)),null!=this.accumulatedWeightedInfNorm&&(0,fn.B9)(this.accumulatedWeightedInfNorm.map(T=>T.variable))}getWeights(){return(0,ke.Z)(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(T){return(0,ke.Z)(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(T,B){return new T(B.learningRate,B.beta1,B.beta2,B.epsilon,B.decay)}}return k.className="Adamax",k})();Di(co);let cs=(()=>{class k extends xo{constructor(T){super(),this.learningRate=T,this.setLearningRate(T)}applyGradients(T){(Array.isArray(T)?T.map(X=>X.name):Object.keys(T)).forEach((X,ue)=>{const fe=Array.isArray(T)?T[ue].tensor:T[X];if(null==fe)return;const Le=A.BV.registeredVariables[X];(0,fn.lu)(()=>{const st=(0,sr.I)((0,qn.d)(this.c,fe),Le);Le.assign(st)})}),this.incrementIterations()}setLearningRate(T){this.learningRate=T,null!=this.c&&this.c.dispose(),this.c=(0,fn.Cn)((0,Yi.i)(-T))}dispose(){this.c.dispose()}getWeights(){var T=this;return(0,ke.Z)(function*(){return[yield T.saveIterations()]})()}setWeights(T){var B=this;return(0,ke.Z)(function*(){if(0!==(T=yield B.extractIterations(T)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(T,B){return new T(B.learningRate)}}return k.className="SGD",k})();Di(cs);let Gu=(()=>{class k extends cs{constructor(T,B,X=!1){super(T),this.learningRate=T,this.momentum=B,this.useNesterov=X,this.accumulations=[],this.m=(0,Yi.i)(this.momentum)}applyGradients(T){(Array.isArray(T)?T.map(X=>X.name):Object.keys(T)).forEach((X,ue)=>{const fe=A.BV.registeredVariables[X];null==this.accumulations[ue]&&(this.accumulations[ue]={originalName:`${X}/momentum`,variable:(0,fn.lu)(()=>(0,Lo.P)(fe).variable(!1))});const Le=this.accumulations[ue].variable,st=Array.isArray(T)?T[ue].tensor:T[X];null!=st&&(0,fn.lu)(()=>{let it;const Tt=(0,sr.I)((0,qn.d)(this.m,Le),st);it=(0,sr.I)((0,qn.d)(this.c,this.useNesterov?(0,sr.I)(st,(0,qn.d)(Tt,this.m)):Tt),fe),Le.assign(Tt),fe.assign(it)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,fn.B9)(this.accumulations.map(T=>T.variable))}setMomentum(T){this.momentum=T}getWeights(){var T=this;return(0,ke.Z)(function*(){return[yield T.saveIterations()].concat(T.accumulations.map(B=>({name:B.originalName,tensor:B.variable})))})()}setWeights(T){var B=this;return(0,ke.Z)(function*(){T=yield B.extractIterations(T),B.accumulations=T.map(ue=>({originalName:ue.name,variable:ue.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(T,B){return new T(B.learningRate,B.momentum,B.useNesterov)}}return k.className="Momentum",k})();Di(Gu);let wc=(()=>{class k extends xo{constructor(T,B=.9,X=0,ue=null,fe=!1){if(super(),this.learningRate=T,this.decay=B,this.momentum=X,this.epsilon=ue,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=fe,null==ue&&(this.epsilon=A.BV.backend.epsilon()),null==T)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(T){(Array.isArray(T)?T.map(X=>X.name):Object.keys(T)).forEach((X,ue)=>{const fe=A.BV.registeredVariables[X];null==this.accumulatedMeanSquares[ue]&&(this.accumulatedMeanSquares[ue]={originalName:`${X}/rms`,variable:(0,fn.lu)(()=>(0,Lo.P)(fe).variable(!1))}),null==this.accumulatedMoments[ue]&&(this.accumulatedMoments[ue]={originalName:`${X}/momentum`,variable:(0,fn.lu)(()=>(0,Lo.P)(fe).variable(!1))}),null==this.accumulatedMeanGrads[ue]&&this.centered&&(this.accumulatedMeanGrads[ue]={originalName:`${X}/mg`,variable:(0,fn.lu)(()=>(0,Lo.P)(fe).variable(!1))});const st=Array.isArray(T)?T[ue].tensor:T[X];if(null==st)return;const it=this.accumulatedMeanSquares[ue].variable,Tt=this.accumulatedMoments[ue].variable;(0,fn.lu)(()=>{const dt=(0,sr.I)((0,qn.d)(it,this.decay),(0,qn.d)((0,gr.h)(st),1-this.decay));if(this.centered){const ht=this.accumulatedMeanGrads[ue].variable,Mt=(0,sr.I)((0,qn.d)(ht,this.decay),(0,qn.d)(st,1-this.decay)),on=(0,us.h)((0,qn.d)(st,this.learningRate),(0,ni._)((0,ps.l)(dt,(0,sr.I)((0,gr.h)(Mt),this.epsilon)))),Sn=(0,sr.I)((0,qn.d)(Tt,this.momentum),on);it.assign(dt),ht.assign(Mt),Tt.assign(Sn);const Pn=(0,ps.l)(fe,Sn);fe.assign(Pn)}else{const ht=(0,sr.I)((0,qn.d)(it,this.decay),(0,qn.d)((0,gr.h)(st),1-this.decay)),Mt=(0,sr.I)((0,qn.d)(Tt,this.momentum),(0,us.h)((0,qn.d)(st,this.learningRate),(0,ni._)((0,sr.I)(ht,this.epsilon))));it.assign(ht),Tt.assign(Mt);const on=(0,ps.l)(fe,Mt);fe.assign(on)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,fn.B9)(this.accumulatedMeanSquares.map(T=>T.variable)),null!=this.accumulatedMeanGrads&&this.centered&&(0,fn.B9)(this.accumulatedMeanGrads.map(T=>T.variable)),null!=this.accumulatedMoments&&(0,fn.B9)(this.accumulatedMoments.map(T=>T.variable))}getWeights(){var T=this;return(0,ke.Z)(function*(){const B=[...T.accumulatedMeanSquares,...T.accumulatedMoments];return T.centered&&B.push(...T.accumulatedMeanGrads),[yield T.saveIterations()].concat(B.map(X=>({name:X.originalName,tensor:X.variable})))})()}setWeights(T){var B=this;return(0,ke.Z)(function*(){T=yield B.extractIterations(T);const X=B.centered?T.length/3:T.length/2;B.accumulatedMeanSquares=T.slice(0,X).map(fe=>({originalName:fe.name,variable:fe.tensor.variable(!1)})),B.accumulatedMoments=T.slice(X,2*X).map(fe=>({originalName:fe.name,variable:fe.tensor.variable(!1)})),B.centered&&(B.accumulatedMeanGrads=T.slice(2*X,3*X).map(fe=>({originalName:fe.name,variable:fe.tensor.variable(!1)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(T,B){return new T(B.learningRate,B.decay,B.momentum,B.epsilon,B.centered)}}return k.className="RMSProp",k})();Di(wc);class Ni{static sgd(P){return new cs(P)}static momentum(P,T,B=!1){return new Gu(P,T,B)}static rmsprop(P,T=.9,B=0,X=null,ue=!1){return new wc(P,T,B,X,ue)}static adam(P=.001,T=.9,B=.999,X=null){return new eo(P,T,B,X)}static adadelta(P=.001,T=.95,B=null){return new ya(P,T,B)}static adamax(P=.002,T=.9,B=.999,X=null,ue=0){return new co(P,T,B,X,ue)}static adagrad(P,T=.1){return new fs(P,T)}}var Ku=M(7770),Fe=M(3084),Pf=M(4761);const Lf={sgd:Ni.sgd,momentum:Ni.momentum,adadelta:Ni.adadelta,adagrad:Ni.adagrad,rmsprop:Ni.rmsprop,adamax:Ni.adamax,adam:Ni.adam},Bf=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:k=>k();function Vf(){return new Promise(k=>Bf(()=>k()))}var va=M(7745);function Uf(k,P){const T=k[0].length;k.forEach((X,ue)=>{$e.hu(X.length===T,()=>`Error in concat${T}D: rank of tensors[${ue}] must be the same as the rank of the rest (${T})`)}),$e.hu(P>=0&&P<T,()=>`Error in concat${T}D: axis must be between 0 and ${T-1}.`);const B=k[0];k.forEach((X,ue)=>{for(let fe=0;fe<T;fe++)$e.hu(fe===P||X[fe]===B[fe],()=>`Error in concat${T}D: Shape of tensors[${ue}] (${X}) does not match the shape of the rest (${B}) along the non-concatenated axis ${ue}.`)})}function Wf(k,P){const T=k[0].slice();for(let B=1;B<k.length;B++)T[P]+=k[B][P];return T}var ki=M(744),Cc=M(8868),Bo=(()=>{return(k=Bo||(Bo={}))[k.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",k[k.VALUE_ROWIDS=1]="VALUE_ROWIDS",k[k.ROW_LENGTHS=2]="ROW_LENGTHS",k[k.ROW_SPLITS=3]="ROW_SPLITS",k[k.ROW_LIMITS=4]="ROW_LIMITS",k[k.ROW_STARTS=5]="ROW_STARTS",Bo;var k})();function zf(k,P,T){let B=new Array;if(null==T&&null==P)return B;if(null==P)for(;B.length<k+T.length;)B.push(-1);else B=P.slice();if(null==T)return B;if(k+T.length!==B.length)throw new Error(`rt input.shape and shape=${P} are incompatible: rt input.rank = ${k+T.length}, but shape.rank = ${B.length}`);for(let X=1;X<T.length;++X){const ue=T[X],fe=B[B.length-T.length+X],Le=B[fe];if(ue>=0)if(Le>=0){if(Le!==ue)throw new Error(`rt input.shape and shape=${P} are incompatible: rt input.shape[${X+k}] = ${ue} but shape[${X+k}] = ${Le}`)}else B[fe]=ue}return B}function dl(k){const P={FIRST_DIM_SIZE:Bo.FIRST_DIM_SIZE,VALUE_ROWIDS:Bo.VALUE_ROWIDS,ROW_LENGTHS:Bo.ROW_LENGTHS,ROW_SPLITS:Bo.ROW_SPLITS,ROW_LIMITS:Bo.ROW_LIMITS,ROW_STARTS:Bo.ROW_STARTS},T=[];for(const B of k){if(!(B in P))break;T.push(P[B])}return T}function hl(k){return 0===k.length?0:k[0]===Bo.FIRST_DIM_SIZE?k.length-1:k.length}function Hf(k,P){if(null==k||null==P)return;const T=k.length,B=P.length;if(T>=B)throw new Error(`defaultValue.shape=${k} and ragged tensor flatValues.shape=${P}, are incompatible: defaultValue.rank = ${T} must be less than ragged tensor input flatValues.rank = ${B})`);for(let X=0;X<Math.min(T,B-1);++X){const ue=k[X],fe=P[X+1];if(ue>=0&&fe>=0&&1!==ue&&ue!==fe)throw new Error(`defaultValue.shape=${k}, and ragged tensor input flatValues.shape=${P} are incompatible: defaultValue.shape[${X-k.length}] = ${ue} but ragged tensor input.flatValues.shape[${X-k.length}] = ${fe}`)}}const fl=30;function jf(k){return k<=fl?k:(0,$e.jP)(k,Math.floor(Math.sqrt(k)))}function Vo(k,P,T){return[T*("number"==typeof k?k:k[0]),P*("number"==typeof k?k:k[1])]}function Yd(k,P,T,B=!0){let X=[];if(B)X=X.concat(P.slice(0)),X.push(k[0]/T),X=X.concat(k.slice(1));else{X=X.concat(k[0]);const ue=P.length;for(let fe=0;fe<ue;++fe)X=X.concat([k[fe+1]/P[fe],P[fe]]);X=X.concat(k.slice(ue+1))}return X}function xa(k,P,T=!0){const B=[];if(T){B.push(P);for(let X=P+1;X<k;++X)X<=2*P?(B.push(X),B.push(X-(P+1))):B.push(X)}else{const X=[],ue=[];for(let fe=1;fe<k;++fe)fe>=2*P+1||fe%2==1?ue.push(fe):X.push(fe);B.push(...X),B.push(0),B.push(...ue)}return B}function pl(k,P,T,B=!0){const X=[];X.push(B?k[0]/T:k[0]*T);for(let ue=1;ue<k.length;++ue)X.push(ue<=P.length?B?P[ue-1]*k[ue]:k[ue]/P[ue-1]:k[ue]);return X}function Zd(k,P){const T=[0];for(let B=0;B<P;++B)T.push(k[B][0]);return T}function Qd(k,P,T){const B=k.slice(0,1);for(let X=0;X<T;++X)B.push(k[X+1]-P[X][0]-P[X][1]);return B}const ml=1.7580993408473768,gl=1.0507009873554805,Jd=.3275911,Sc=.254829592,yl=-.284496736,bo=1.421413741,vl=-1.453152027,xl=1.061405429;var ms=M(5686);function eh(k,P){if(k.length!==P.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${k.length}, imag: ${P.length}.`);const T=new Float32Array(2*k.length);for(let B=0;B<T.length;B+=2)T[B]=k[B/2],T[B+1]=P[B/2];return T}function Xu(k){const P=new Float32Array(k.length/2),T=new Float32Array(k.length/2);for(let B=0;B<k.length;B+=2)P[B/2]=k[B],T[B/2]=k[B+1];return{real:P,imag:T}}function lo(k){const P=Math.ceil(k.length/4),T=new Float32Array(P),B=new Float32Array(P);for(let X=0;X<k.length;X+=4)T[Math.floor(X/4)]=k[X],B[Math.floor(X/4)]=k[X+1];return{real:T,imag:B}}function th(k){const P=Math.floor(k.length/4),T=new Float32Array(P),B=new Float32Array(P);for(let X=2;X<k.length;X+=4)T[Math.floor(X/4)]=k[X],B[Math.floor(X/4)]=k[X+1];return{real:T,imag:B}}function bl(k,P){return{real:k[2*P],imag:k[2*P+1]}}function ja(k,P,T,B){k[2*B]=P,k[2*B+1]=T}function to(k,P){const T=new Float32Array(k/2),B=new Float32Array(k/2);for(let X=0;X<Math.ceil(k/2);X++){const ue=(P?2:-2)*Math.PI*(X/k);T[X]=Math.cos(ue),B[X]=Math.sin(ue)}return{real:T,imag:B}}function nh(k,P,T){const B=(T?2:-2)*Math.PI*(k/P);return{real:Math.cos(B),imag:Math.sin(B)}}const Ga="->",rh=/->/g,Uo=",",vu="...";function Ec(k,P){const T=((k=k.replace(/\s/g,"")).length-k.replace(rh,"").length)/Ga.length;if(T<1)throw new Error("Equations without an arrow are not supported.");if(T>1)throw new Error(`Equation must contain exactly one arrow ("${Ga}").`);const[B,X]=k.split(Ga);(0,$e.hu)(-1===B.indexOf(vu),()=>`The ellipsis notation ("${vu}") is not supported yet.`);const ue=B.split(Uo),fe=ue.length;if(P!==fe)throw new Error(`Expected ${fe} input tensors, received ${P}`);if(fe>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const Le=[];for(let ht=0;ht<X.length;++ht){const Mt=X[ht];if(!ue.some(on=>-1!==on.indexOf(Mt)))throw new Error(`Output subscripts contain the label ${Mt} not present in the input subscripts.`);-1===Le.indexOf(Mt)&&Le.push(Mt)}for(let ht=0;ht<B.length;++ht){const Mt=B[ht];-1===Le.indexOf(Mt)&&Mt!==Uo&&Le.push(Mt)}const st=new Array(ue.length);for(let ht=0;ht<fe;++ht){if(new Set(ue[ht].split("")).size!==ue[ht].length)throw new Error(`Found duplicate axes in input component ${ue[ht]}. Support for duplicate axes in input is not implemented yet.`);st[ht]=[];for(let Mt=0;Mt<ue[ht].length;++Mt)st[ht].push(Le.indexOf(ue[ht][Mt]))}const it=Le.length,dt=[];for(let ht=X.length;ht<it;++ht)dt.push(ht);return{allDims:Le,summedDims:dt,idDims:st}}function Vn(k,P){let T=new Array(k);T.fill(-1);for(let X=0;X<P.length;++X)T[P[X]]=X;const B=[];for(let X=0;X<k;++X)-1===T[X]&&B.push(X);return T=T.filter(X=>-1!==X),{permutationIndices:T,expandDims:B}}function sh(k,P,T){const B=new Array(k);for(let X=0;X<T.length;++X){const ue=T[X].shape;for(let fe=0;fe<P[X].length;++fe)void 0===B[P[X][fe]]?B[P[X][fe]]=ue[fe]:(0,$e.hu)(B[P[X][fe]]===ue[fe],()=>`Expected dimension ${B[P[X][fe]]} at axis ${fe} of input shaped ${JSON.stringify(ue)}, but got dimension ${ue[fe]}`)}}function Ag(k,P){const T=k,B=[];let X=0;0===k.length&&T.push(-1),X=k.length+1;for(let fe=0;fe<X;++fe)B.push([]);const ue=[];for(let fe=0;fe<T.length;++fe){const st=oh(P,T[fe]);for(const it of st)-1===ue.indexOf(it)&&(B[fe].push(it),ue.push(it))}return{path:T,steps:B}}function _c(k){return k.every((P,T)=>P===T)}function oh(k,P){const T=[];for(let B=0;B<k.length;++B)(0===k[B].length||-1!==k[B].indexOf(P)||-1===P)&&T.push(B);return T}function ih(k,P,T=0){let B=[];if("number"==typeof P)(0,$e.hu)(k.shape[T]%P==0,()=>"Number of splits must evenly divide the axis."),B=new Array(P).fill(k.shape[T]/P);else{const X=P.reduce((fe,Le)=>(-1===Le&&(fe+=1),fe),0);(0,$e.hu)(X<=1,()=>"There should be only one negative value in split array.");const ue=P.indexOf(-1);if(-1!==ue){const fe=P.reduce((Le,st)=>st>0?Le+st:Le);P[ue]=k.shape[T]-fe}(0,$e.hu)(k.shape[T]===P.reduce((fe,Le)=>fe+Le),()=>"The sum of sizes must match the size of the axis dimension."),B=P}return B}function wl(k){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${k}`}function ah(k,P){return`indices(${k}, 0) is invalid: ${P} < 0`}function uh(k,P,T){return`indices(${k}, 0) is invalid: ${P} >= ${T}`}function Dt(k,P){return`only one output dimension may be -1, not both ${k} and ${P}`}function or(k,P){return`size ${k} must be non-negative, not ${P}`}function Zi(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Qi(k,P){return`Input to reshape is a SparseTensor with ${(0,$e.NA)(k)}\n  dense values, but the requested shape requires a multiple of ${(0,$e.NA)(P)}. inputShape=${k} outputShape= ${P}`}function Is(k,P){return`Input to reshape is a tensor with ${(0,$e.NA)(k)} dense values, but the requested shape has ${(0,$e.NA)(P)}. inputShape=${k} outputShape=${P}`}function Ic(){return"segment ids must be >= 0"}function Ai(){return"segment ids are not increasing"}function ho(k,P){return`Segment id ${k} out of range [0, ${P}), possibly because segmentIds input is not sorted.`}function Dc(k,P,T){return`Bad: indices[${k}] == ${P} out of range [0, ${T})`}function Tc(k,P){let B,T=!1;for(k<=fl?(B=k,T=!0):B=(0,$e.jP)(k,Math.floor(Math.sqrt(k)));!T;)B>P||B===k?T=!0:B=(0,$e.jP)(k,B+1);return B}function Nc(k,P,T){const B=[],X=k.length;for(let ue=0;ue<X;ue++)B.push(ue!==P?k[ue]:T);return B}function Gf(k,P,T,B){const X=P.shape.length,ue=k.shape.length;if(0!==B&&(B<-X||B>X))throw new Error(`Expect batchDims in the range of [-${X}, ${X}], but got ${B}`);if(B<0&&(B+=X),B>ue)throw new Error(`batchDims (${B}) must be less than rank(x) (\n    ${ue}).`);if(T<B)throw new Error(`batchDims (${B}) must be less than or equal to axis (${T}).`);for(let dt=0;dt<B;++dt)if(k.shape[dt]!==P.shape[dt])throw new Error(`x.shape[${dt}]: ${k.shape[dt]} should be equal to indices.shape[${dt}]: ${P.shape[dt]}.`);const fe=k.shape[T],Le=[];let st=1,it=1,Tt=1;for(let dt=0;dt<B;++dt)Le.push(k.shape[dt]),st*=k.shape[dt];for(let dt=B;dt<T;dt++)Le.push(k.shape[dt]),it*=k.shape[dt];for(let dt=B;dt<X;dt++)Le.push(P.shape[dt]);for(let dt=T+1;dt<ue;dt++)Le.push(k.shape[dt]),Tt*=k.shape[dt];return{batchSize:st,sliceSize:Tt,outerSize:it,dimSize:fe,outputShape:Le}}function Cl(k){try{return k.map(P=>(0,vo.decodeString)(P))}catch(P){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${P}`)}}function Jr(k){return k.map(P=>(0,vo.encodeString)(P))}var Wo=M(152),Sl=M(2842),ba=M(7872)},1070:(gt,Xe,M)=>{"use strict";M.d(Xe,{$HU:()=>Si,$g6:()=>lt,$w:()=>Fn,Acj:()=>Zs,BMI:()=>pn,BiW:()=>Dr,Byc:()=>Yt,CAk:()=>Hn,D2d:()=>g,DlI:()=>Ba,Eh3:()=>ce,FKq:()=>ct,G3Y:()=>Ht,GBy:()=>je,Gcp:()=>Lt,HEU:()=>wn,HZH:()=>Ss,Hhh:()=>Pt,Hmb:()=>Gi,IKK:()=>Ie,IMb:()=>St,J$2:()=>Re,J_u:()=>Qo,JhU:()=>xe,Kgp:()=>ji,L8s:()=>ge,Ly9:()=>It,M2y:()=>le,MIZ:()=>Je,MRv:()=>qe,MZg:()=>sn,NEP:()=>wr,NZg:()=>wi,O3z:()=>kt,OAf:()=>$a,OR:()=>Fr,OU7:()=>Oo,OV7:()=>yo,Omj:()=>zn,Oyi:()=>de,PYm:()=>Pr,PhF:()=>Fo,QCc:()=>Pe,QRR:()=>Mn,Qg5:()=>mr,QiL:()=>Qn,Qvg:()=>zs,RFZ:()=>Ce,ROF:()=>Ze,RQH:()=>_,RuY:()=>kr,SX0:()=>Nt,SYM:()=>_e,SbG:()=>ei,SpW:()=>te,T0n:()=>cr,TQc:()=>at,TR1:()=>Ft,ToN:()=>xr,Tr8:()=>ut,Uyb:()=>Yo,VGw:()=>we,Vbg:()=>ts,VcC:()=>yn,VfG:()=>ws,Vn9:()=>Ne,W0H:()=>fa,XDQ:()=>ns,XLW:()=>Vt,XkS:()=>Ue,Xze:()=>F,Y0y:()=>_r,YFo:()=>$r,YoZ:()=>Lr,ZbH:()=>hr,ZjV:()=>p,Zz9:()=>se,_JP:()=>ae,_V0:()=>pu,_Yw:()=>Ki,_k9:()=>ot,_tC:()=>C,a5O:()=>he,aJk:()=>Y,avt:()=>Ao,b9H:()=>Hs,bK0:()=>G,bV0:()=>$o,c17:()=>Ui,cWu:()=>Wt,cie:()=>kn,cye:()=>La,dDz:()=>Ws,deh:()=>Ys,dpD:()=>Mo,e07:()=>Kr,e6w:()=>Br,e7N:()=>Bn,eBW:()=>_i,eEB:()=>$e,eZ0:()=>Vi,ekb:()=>Zn,gJX:()=>ye,h8e:()=>Po,hdR:()=>Jn,i5y:()=>U,iHb:()=>Zt,iJz:()=>oo,iWB:()=>nr,iZT:()=>bi,ik2:()=>et,jMg:()=>A,jQk:()=>K,jQs:()=>ha,jeX:()=>go,kU:()=>Ir,kpP:()=>ln,kuV:()=>Wi,luS:()=>Es,lyA:()=>hu,mKl:()=>Ei,mTV:()=>rr,mc4:()=>Ve,mhS:()=>x,mm_:()=>Q,n9L:()=>bt,nhH:()=>Un,nr8:()=>fr,o0g:()=>vn,o2y:()=>nt,oFR:()=>Va,oHH:()=>rt,oT6:()=>j,p2w:()=>ao,p4S:()=>ds,pe_:()=>fu,q1x:()=>Zo,q2K:()=>hs,q8u:()=>Fa,qCd:()=>Gr,qIC:()=>Cs,qWM:()=>Hi,qi_:()=>is,qkr:()=>pa,qw7:()=>ee,r7n:()=>Ro,s1s:()=>oe,sEM:()=>tt,sHE:()=>os,sJF:()=>me,sL$:()=>dn,usg:()=>Hu,uv1:()=>zi,vFR:()=>Us,vtC:()=>Ur,vwp:()=>qs,w3H:()=>v,w6g:()=>io,wUP:()=>He,wYB:()=>V,wYn:()=>Pa,we_:()=>as,wm:()=>Me,wx7:()=>Gt,x12:()=>We,xJR:()=>Ci,xQA:()=>ma,xnO:()=>$,y7R:()=>un,yQU:()=>Jo,yj2:()=>be,zbQ:()=>mn,zvY:()=>Oe,zws:()=>ke});const _e="Abs",we="Acos",te="Acosh",Q="Add",F="AddN",j="All",Ie="Any",me="ArgMax",Y="ArgMin",le="Asin",ee="Asinh",A="Atan",de="Atanh",Pe="Atan2",xe="AvgPool",Ze="AvgPoolGrad",ot="AvgPool3D",St="AvgPool3DGrad",Vt="BatchMatMul",ke="BatchToSpaceND",Oe="Bincount",It="BroadcastTo",$e="BroadcastArgs",Ce="Cast",ye="Ceil",$="ClipByValue",se="Complex",be="ComplexAbs",ce="Concat",x="Conv2D",He="Conv2DBackpropFilter",Me="Conv2DBackpropInput",We="Conv3D",nt="Conv3DBackpropFilterV2",et="Conv3DBackpropInputV2",Ve="Cos",Ft="Cosh",Yt="Cumprod",Zt="Cumsum",yn="CropAndResize",Mn="DenseBincount",cr="DepthToSpace",kn="DepthwiseConv2dNative",dn="DepthwiseConv2dNativeBackpropFilter",un="DepthwiseConv2dNativeBackpropInput",Fn="Diag",ds="Dilation2D",Zn="Dilation2DBackpropInput",Ne="Dilation2DBackpropFilter",rt="RealDiv",lt="Einsum",Nt="Elu",wn="EluGrad",zn="Erf",Jn="Equal",wr="Exp",$r="ExpandDims",_r="Expm1",qs="FFT",Ys="Fill",Yo="FlipLeftRight",Fr="Floor",go="FloorDiv",os="FusedBatchNorm",is="GatherV2",Zo="GatherNd",bi="Greater",Zs="GreaterEqual",oo="Identity",mr="IFFT",Qo="Imag",Ao="IsFinite",nr="IsInf",Ro="IsNan",Re="LeakyRelu",Ur="Less",Hn="LessEqual",Bn="LinSpace",hr="Log",Ir="Log1p",Pr="LogicalAnd",ws="LogicalNot",sn="LogicalOr",io="LogicalXor",Gr="LogSoftmax",Cs="LowerBound",Vi="LRN",Pt="LRNGrad",Lr="Max",pn="Maximum",rr="MaxPool",yo="MaxPoolGrad",$a="MaxPool3D",Oo="MaxPool3DGrad",Us="MaxPoolWithArgmax",hs="Mean",Ui="Min",Fa="Minimum",ha="MirrorPad",ts="Mod",wi="Multinomial",Pa="Multiply",Wi="Neg",Jo="NotEqual",zi="NonMaxSuppressionV3",La="NonMaxSuppressionV4",fa="NonMaxSuppressionV5",Hi="OnesLike",as="OneHot",Qn="Pack",hu="PadV2",ji="Pool",fu="Pow",vn="Prelu",Ba="Prod",Ws="RaggedGather",Dr="RaggedTensorToTensor",Br="Range",Ci="Real",Si="Reciprocal",pa="Relu",Ss="Reshape",Mo="ResizeNearestNeighbor",Gi="ResizeNearestNeighborGrad",Ki="ResizeBilinear",mn="ResizeBilinearGrad",ei="Relu6",Ei="Reverse",Kr="Round",$o="Rsqrt",ma="ScatterNd",fr="SearchSorted",Fo="Select",Va="Selu",ao="Slice",_="Sin",V="Sinh",U="Sign",he="Sigmoid",qe="Softplus",ct="Sqrt",je="Sum",at="SpaceToBatchND",ge="SplitV",Lt="Softmax",kt="SparseFillEmptyRows",Un="SparseReshape",v="SparseSegmentMean",p="SparseSegmentSum",g="SparseToDense",C="SquaredDifference",G="Square",K="StridedSlice",ae="StringNGrams",oe="StringSplit",Ue="StringToHashBucketFast",ut="Sub",tt="Tan",Je="Tanh",bt="Tile",Wt="TopK",Gt="Transform",Ht="Transpose",ln="Unique",xr="Unpack",zs="UnsortedSegmentSum",ns="UpperBound",kr="ZerosLike",Po="Step",_i="FromPixels",Hs="RotateWithOffset",Hu="_FusedMatMul",pu="FusedConv2D",Es="FusedDepthwiseConv2D"},9464:(gt,Xe,M)=>{"use strict";M.d(Xe,{Li:()=>le,T3:()=>de,bt:()=>A,nE:()=>ee,pI:()=>j,tr:()=>me,uk:()=>Ie,wC:()=>Y});var _e=M(1777),we=M(6422),te=M(5686);const Q=(0,we.R)("kernelRegistry",()=>new Map),F=(0,we.R)("gradRegistry",()=>new Map);function j(xe,Ze){const ot=Pe(xe,Ze);return Q.get(ot)}function Ie(xe){return F.get(xe)}function me(xe){const Ze=Q.entries(),ot=[];for(;;){const{done:St,value:Vt}=Ze.next();if(St)break;const[ke,Oe]=Vt,[It]=ke.split("_");It===xe&&ot.push(Oe)}return ot}function Y(xe){const{kernelName:Ze,backendName:ot}=xe,St=Pe(Ze,ot);Q.has(St)&&te.Z(`The kernel '${Ze}' for backend '${ot}' is already registered`),Q.set(St,xe)}function le(xe){const{kernelName:Ze}=xe;F.has(Ze)&&(0,_e.OB)().getBool("DEBUG")&&te.Z(`Overriding the gradient for '${Ze}'`),F.set(Ze,xe)}function ee(xe,Ze){const ot=Pe(xe,Ze);if(!Q.has(ot))throw new Error(`The kernel '${xe}' for backend '${Ze}' is not registered`);Q.delete(ot)}function A(xe){if(!F.has(xe))throw new Error(`The gradient '${xe}' for backend is not registered`);F.delete(xe)}function de(xe,Ze){me(xe).forEach(St=>{Y(Object.assign({},St,{backendName:Ze}))})}function Pe(xe,Ze){return`${Ze}_${xe}`}},5686:(gt,Xe,M)=>{"use strict";M.d(Xe,{Z:()=>we,c:()=>te});var _e=M(1777);function we(...Q){(0,_e.OB)().getBool("IS_TEST")||(0,_e.OB)().getBool("PROD")||console.warn(...Q)}function te(...Q){(0,_e.OB)().getBool("IS_TEST")||(0,_e.OB)().getBool("PROD")||console.log(...Q)}},2519:(gt,Xe,M)=>{"use strict";M.d(Xe,{W:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({abs_:function F(Ie){const me=(0,te._1)(Ie,"x","abs");return _e.BV.runKernel("complex64"===me.dtype?we.yj2:we.SYM,{x:me})}})},6849:(gt,Xe,M)=>{"use strict";M.d(Xe,{I:()=>Ie});var _e=M(3738),we=M(1070),te=M(7904),Q=M(9608);const Ie=(0,M(6721).op)({add_:function j(me,Y){let le=(0,Q._1)(me,"a","add"),ee=(0,Q._1)(Y,"b","add");return[le,ee]=(0,te.makeTypesMatch)(le,ee),_e.BV.runKernel(we.mm_,{a:le,b:ee})}})},7745:(gt,Xe,M)=>{"use strict";M.d(Xe,{LJ:()=>me,Q3:()=>Ie,Vh:()=>te,YB:()=>we,kz:()=>Q,lB:()=>j,rv:()=>F,sY:()=>Y});var _e=M(1396);function we(le,ee){for(let A=0;A<le.length;++A)if(le[le.length-A-1]!==ee-1-A)return!1;return!0}function te(le,ee,A){const de=le.length+ee.length,Pe=[];let xe=0,Ze=0;for(let ot=0;ot<de;ot++)-1===A.indexOf(ot)?Pe.push(le[xe++]):Pe.push(ee[Ze++]);return Pe}function Q(le,ee){const A=[],de=le.length;for(let xe=0;xe<de;xe++)-1===ee.indexOf(xe)&&A.push(le[xe]);return[A,ee.map(xe=>le[xe])]}function F(le,ee){return te(le,ee.map(de=>1),ee)}function j(le,ee,A){_e.hu(we(ee,A),()=>`${le} supports only inner-most axes for now. Got axes ${ee} and rank-${A} input.`)}function Ie(le,ee){if(we(le,ee))return null;const A=[];for(let de=0;de<ee;++de)-1===le.indexOf(de)&&A.push(de);return le.forEach(de=>A.push(de)),A}function me(le){return le.map((ee,A)=>[A,ee]).sort((ee,A)=>ee[1]-A[1]).map(ee=>ee[0])}function Y(le,ee){const A=[];for(let de=ee-le;de<ee;++de)A.push(de);return A}},258:(gt,Xe,M)=>{"use strict";function _e(Q,F){const j=Q.length,Ie=[];for(let me=0;me<j;me++){const Y=j-1-me;(F[F.length-1-me]||1)>1&&1===(Q[Y]||1)&&Ie.unshift(Y)}return Ie}function we(Q,F){const j=[];for(let Ie=0;Ie<F.length;Ie++){const me=Q[Q.length-Ie-1],Y=F.length-Ie-1;(null==me||1===me&&F[Y]>1)&&j.unshift(Y)}return j}function te(Q,F){const j=[],Ie=Math.max(Q.length,F.length);for(let me=0;me<Ie;me++){let Y=Q[Q.length-me-1];null==Y&&(Y=1);let le=F[F.length-me-1];if(null==le&&(le=1),1===Y)j.unshift(le);else if(1===le)j.unshift(Y);else{if(Y!==le)throw Error(`Operands could not be broadcast together with shapes ${Q} and ${F}.`);j.unshift(Y)}}return j}M.r(Xe),M.d(Xe,{assertAndGetBroadcastShape:()=>te,getBroadcastDims:()=>_e,getReductionAxes:()=>we})},8621:(gt,Xe,M)=>{"use strict";M.d(Xe,{f:()=>te});var _e=M(708),we=M(1396);function te(Q,F="float32",j){return F=F||"float32",we.Mu(Q),new _e.YD(Q,F,j)}},9734:(gt,Xe,M)=>{"use strict";M.d(Xe,{p:()=>Ie});var _e=M(3738),we=M(1070),te=M(9608),Q=M(1396);const Ie=(0,M(6721).op)({cast_:function j(me,Y){const le=(0,te._1)(me,"x","cast");if(!Q.LP(Y))throw new Error(`Failed to cast to unknown dtype ${Y}`);if("string"===Y&&"string"!==le.dtype||"string"!==Y&&"string"===le.dtype)throw new Error("Only strings can be casted to strings");return _e.BV.runKernel(we.RFZ,{x:le},{dtype:Y})}})},4249:(gt,Xe,M)=>{"use strict";M.d(Xe,{d:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({clone_:function F(Ie){const Y={x:(0,te._1)(Ie,"x","clone","string_or_numeric")};return _e.BV.runKernel(we.iJz,Y)}})},9907:(gt,Xe,M)=>{"use strict";M.d(Xe,{P:()=>Ie});var _e=M(3738),we=M(1070),te=M(9608),Q=M(1396);const Ie=(0,M(6721).op)({complex_:function j(me,Y){const le=(0,te._1)(me,"real","complex"),ee=(0,te._1)(Y,"imag","complex");return Q.k5(le.shape,ee.shape,`real and imag shapes, ${le.shape} and ${ee.shape}, must match in call to tf.complex().`),_e.BV.runKernel(we.Zz9,{real:le,imag:ee})}})},744:(gt,Xe,M)=>{"use strict";M.d(Xe,{I0:()=>Ze,Ix:()=>F,Rf:()=>we,Xw:()=>te,aO:()=>Y,jT:()=>ot,jw:()=>j,m:()=>Vt,pl:()=>Q,sl:()=>St});var _e=M(1396);function we(ke,Oe,It,$e,Ce="NHWC",ye){return F(ke,[...Oe,ke[3]],It,ye,$e,null,null,St(Ce))}function te(ke,Oe,It,$e,Ce,ye,$="channelsLast"){const[se,be]=le(Oe);let ce;if("channelsLast"===$)ce=[se,be,ke[3],ke[3]];else{if("channelsFirst"!==$)throw new Error(`Unknown dataFormat ${$}`);ce=[se,be,ke[1],ke[1]]}return F(ke,ce,It,$e,Ce,ye,!1,$)}function Q(ke,Oe,It,$e,Ce,ye,$="NDHWC"){const[se,be,ce]=ee(Oe);let x,He;if("NDHWC"===$)He="channelsLast",x=[se,be,ce,ke[4],ke[4]];else{if("NCDHW"!==$)throw new Error(`Unknown dataFormat ${$}`);He="channelsFirst",x=[se,be,ce,ke[1],ke[1]]}return j(ke,x,It,$e,Ce,!1,He,ye)}function F(ke,Oe,It,$e,Ce,ye,$=!1,se="channelsLast"){let[be,ce,x,He]=[-1,-1,-1,-1];if("channelsLast"===se)[be,ce,x,He]=ke;else{if("channelsFirst"!==se)throw new Error(`Unknown dataFormat ${se}`);[be,He,ce,x]=ke}const[Me,We,,nt]=Oe,[et,Ve]=le(It),[Ft,Yt]=le($e),Zt=A(Me,Ft),yn=A(We,Yt),{padInfo:Mn,outHeight:cr,outWidth:kn}=function de(ke,Oe,It,$e,Ce,ye,$,se,be){let ce,x,He;if("number"==typeof ke){ce={top:ke,bottom:ke,left:ke,right:ke,type:0===ke?"VALID":"NUMBER"};const We=function Ie(ke,Oe,It,$e,Ce){null==$e&&($e=Y(ke,Oe,It));const $=ke[1];return[xe((ke[0]-Oe+2*$e)/It+1,Ce),xe(($-Oe+2*$e)/It+1,Ce)]}([Oe,It],ye,$e,ke,se);x=We[0],He=We[1]}else if("same"===ke){x=Math.ceil(Oe/$e),He=Math.ceil(It/Ce);const Me=Math.max(0,(x-1)*$e+ye-Oe),We=Math.max(0,(He-1)*Ce+$-It),nt=Math.floor(Me/2),et=Me-nt,Ve=Math.floor(We/2);ce={top:nt,bottom:et,left:Ve,right:We-Ve,type:"SAME"}}else if("valid"===ke)ce={top:0,bottom:0,left:0,right:0,type:"VALID"},x=Math.ceil((Oe-ye+1)/$e),He=Math.ceil((It-$+1)/Ce);else{if("object"!=typeof ke)throw Error(`Unknown padding parameter: ${ke}`);{const Me="channelsLast"===be?ke[1][0]:ke[2][0],We="channelsLast"===be?ke[1][1]:ke[2][1],nt="channelsLast"===be?ke[2][0]:ke[3][0],et="channelsLast"===be?ke[2][1]:ke[3][1];ce={top:Me,bottom:We,left:nt,right:et,type:0===Me&&0===We&&0===nt&&0===et?"VALID":"EXPLICIT"},x=xe((Oe-ye+Me+We)/$e+1,se),He=xe((It-$+nt+et)/Ce+1,se)}}return{padInfo:ce,outHeight:x,outWidth:He}}(Ce,ce,x,et,Ve,Zt,yn,ye,se),dn=$?nt*He:nt;let un;return"channelsFirst"===se?un=[be,dn,cr,kn]:"channelsLast"===se&&(un=[be,cr,kn,dn]),{batchSize:be,dataFormat:se,inHeight:ce,inWidth:x,inChannels:He,outHeight:cr,outWidth:kn,outChannels:dn,padInfo:Mn,strideHeight:et,strideWidth:Ve,filterHeight:Me,filterWidth:We,effectiveFilterHeight:Zt,effectiveFilterWidth:yn,dilationHeight:Ft,dilationWidth:Yt,inShape:ke,outShape:un,filterShape:Oe}}function j(ke,Oe,It,$e,Ce,ye=!1,$="channelsLast",se){let[be,ce,x,He,Me]=[-1,-1,-1,-1,-1];if("channelsLast"===$)[be,ce,x,He,Me]=ke;else{if("channelsFirst"!==$)throw new Error(`Unknown dataFormat ${$}`);[be,Me,ce,x,He]=ke}const[We,nt,et,,Ve]=Oe,[Ft,Yt,Zt]=ee(It),[yn,Mn,cr]=ee($e),kn=A(We,yn),dn=A(nt,Mn),un=A(et,cr),{padInfo:Fn,outDepth:ds,outHeight:Zn,outWidth:Ne}=function Pe(ke,Oe,It,$e,Ce,ye,$,se,be,ce,x){let He,Me,We,nt;if("number"==typeof ke){He={top:ke,bottom:ke,left:ke,right:ke,front:ke,back:ke,type:0===ke?"VALID":"NUMBER"};const Ve=function me(ke,Oe,It,$e,Ce,ye){null==Ce&&(Ce=Y(ke,Oe,$e));const se=ke[1],be=ke[2];return[xe((ke[0]-Oe+2*Ce)/$e+1,ye),xe((se-Oe+2*Ce)/$e+1,ye),xe((be-Oe+2*Ce)/$e+1,ye),It]}([Oe,It,$e,1],se,1,Ce,ke,x);Me=Ve[0],We=Ve[1],nt=Ve[2]}else if("same"===ke){Me=Math.ceil(Oe/Ce),We=Math.ceil(It/ye),nt=Math.ceil($e/$);const et=(Me-1)*Ce+se-Oe,Ve=(We-1)*ye+be-It,Ft=(nt-1)*$+ce-$e,Yt=Math.floor(et/2),Zt=et-Yt,yn=Math.floor(Ve/2),Mn=Ve-yn,cr=Math.floor(Ft/2);He={top:yn,bottom:Mn,left:cr,right:Ft-cr,front:Yt,back:Zt,type:"SAME"}}else{if("valid"!==ke)throw Error(`Unknown padding parameter: ${ke}`);He={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},Me=Math.ceil((Oe-se+1)/Ce),We=Math.ceil((It-be+1)/ye),nt=Math.ceil(($e-ce+1)/$)}return{padInfo:He,outDepth:Me,outHeight:We,outWidth:nt}}(Ce,ce,x,He,Ft,Yt,Zt,kn,dn,un,se),rt=ye?Ve*Me:Ve;let lt;return"channelsFirst"===$?lt=[be,rt,ds,Zn,Ne]:"channelsLast"===$&&(lt=[be,ds,Zn,Ne,rt]),{batchSize:be,dataFormat:$,inDepth:ce,inHeight:x,inWidth:He,inChannels:Me,outDepth:ds,outHeight:Zn,outWidth:Ne,outChannels:rt,padInfo:Fn,strideDepth:Ft,strideHeight:Yt,strideWidth:Zt,filterDepth:We,filterHeight:nt,filterWidth:et,effectiveFilterDepth:kn,effectiveFilterHeight:dn,effectiveFilterWidth:un,dilationDepth:yn,dilationHeight:Mn,dilationWidth:cr,inShape:ke,outShape:lt,filterShape:Oe}}function Y(ke,Oe,It,$e=1){const Ce=A(Oe,$e);return Math.floor((ke[0]*(It-1)-It+Ce)/2)}function le(ke){return"number"==typeof ke?[ke,ke,ke]:2===ke.length?[ke[0],ke[1],1]:ke}function ee(ke){return"number"==typeof ke?[ke,ke,ke]:ke}function A(ke,Oe){return Oe<=1?ke:ke+(ke-1)*(Oe-1)}function xe(ke,Oe){if(!Oe)return Math.trunc(ke);switch(Oe){case"round":return Math.round(ke);case"ceil":return Math.ceil(ke);case"floor":return Math.floor(ke);default:throw new Error(`Unknown roundingMode ${Oe}`)}}function Ze(ke){const[Oe,It,$e]=le(ke);return 1===Oe&&1===It&&1===$e}function ot(ke,Oe){return Ze(ke)||Ze(Oe)}function St(ke){if("NHWC"===ke)return"channelsLast";if("NCHW"===ke)return"channelsFirst";throw new Error(`Unknown dataFormat ${ke}`)}function Vt(ke,Oe,It){if(null!=It){if("string"==typeof Oe)throw Error(`Error in ${ke}: pad must be an integer when using dimRoundingMode ${It} but got pad ${Oe}.`);if("number"==typeof Oe)_e.hu(_e.GN(Oe),()=>`Error in ${ke}: pad must be an integer when using dimRoundingMode ${It} but got pad ${Oe}.`);else{if("object"!=typeof Oe)throw Error(`Error in ${ke}: Unknown padding parameter: ${Oe}`);Oe.forEach($e=>{$e.forEach(Ce=>{_e.hu(_e.GN(Ce),()=>`Error in ${ke}: pad must be an integer when using dimRoundingMode ${It} but got pad ${Ce}.`)})})}}}},6635:(gt,Xe,M)=>{"use strict";M.d(Xe,{h:()=>me});var _e=M(3738),we=M(1070),te=M(7904),Q=M(9608),F=M(3273);const me=(0,M(6721).op)({div_:function Ie(Y,le){let ee=(0,Q._1)(Y,"a","div"),A=(0,Q._1)(le,"b","div");return[ee,A]=(0,te.makeTypesMatch)(ee,A),"int32"===ee.dtype&&"int32"===A.dtype?(0,F.q)(ee,A):_e.BV.runKernel(we.oHH,{a:ee,b:A},{})}})},4609:(gt,Xe,M)=>{"use strict";M.d(Xe,{p:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({elu_:function F(Ie){const Y={x:(0,te._1)(Ie,"x","elu","float32")};return _e.BV.runKernel(we.SX0,Y)}})},8509:(gt,Xe,M)=>{"use strict";M.d(Xe,{h:()=>te});var _e=M(3738),we=M(1070);function te(Q,F,j){return _e.BV.runKernel(we.deh,{},{shape:Q,value:F,dtype:j})}},3273:(gt,Xe,M)=>{"use strict";M.d(Xe,{q:()=>Ie});var _e=M(3738),we=M(1070),te=M(7904),Q=M(9608);const Ie=(0,M(6721).op)({floorDiv_:function j(me,Y){let le=(0,Q._1)(me,"a","floorDiv"),ee=(0,Q._1)(Y,"b","floorDiv");return[le,ee]=(0,te.makeTypesMatch)(le,ee),_e.BV.runKernel(we.jeX,{a:le,b:ee})}})},8868:(gt,Xe,M)=>{"use strict";M.d(Xe,{Fr:()=>A,QH:()=>Pe,pf:()=>de,uy:()=>xe});var _e=M(258),we=M(4609),te=M(6151),Q=M(8788),F=M(1426),j=M(4563),Ie=M(5049),me=M(9416),Y=M(6713),le=M(6166),ee=M(5214);function A(Ze,ot,St){if(null==St||"linear"===St)return Ze;if("relu"===St)return(0,Q.d)(Ze,(0,le.N)(ot));throw new Error(`Cannot compute gradient for fused activation ${St}.`)}function de(Ze,ot){let St=ot;const Vt=_e.getReductionAxes(Ze.shape,ot.shape);return Vt.length>0&&(St=(0,ee.S)(St,Vt)),(0,me.X)(St,Ze.shape)}function Pe(Ze,ot,St,Vt){if("linear"===ot)return Ze;if("relu"===ot)return(0,j.U)(Ze);if("elu"===ot)return(0,we.p)(Ze);if("relu6"===ot)return(0,Ie.b)(Ze);if("prelu"===ot)return(0,F.A)(Ze,St);if("leakyrelu"===ot)return(0,te.h)(Ze,Vt);if("sigmoid"===ot)return(0,Y.X)(Ze);throw new Error(`Unknown fused activation ${ot}.`)}const xe=(Ze,ot)=>!(Ze>0)||"linear"===ot},5294:(gt,Xe,M)=>{"use strict";M.d(Xe,{a:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({imag_:function F(Ie){const Y={input:(0,te._1)(Ie,"input","imag")};return _e.BV.runKernel(we.J_u,Y)}})},6151:(gt,Xe,M)=>{"use strict";M.d(Xe,{h:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({leakyRelu_:function F(Ie,me=.2){const le={x:(0,te._1)(Ie,"x","leakyRelu")};return _e.BV.runKernel(we.J$2,le,{alpha:me})}})},4761:(gt,Xe,M)=>{"use strict";M.d(Xe,{I:()=>_e});var _e=(()=>{return(we=_e||(_e={}))[we.NONE=0]="NONE",we[we.MEAN=1]="MEAN",we[we.SUM=2]="SUM",we[we.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",_e;var we})()},341:(gt,Xe,M)=>{"use strict";M.d(Xe,{O:()=>Ie});var _e=M(3738),we=M(1070),te=M(7904),Q=M(9608);const Ie=(0,M(6721).op)({matMul_:function j(me,Y,le=!1,ee=!1){let A=(0,Q._1)(me,"a","matMul"),de=(0,Q._1)(Y,"b","matMul");return[A,de]=(0,te.makeTypesMatch)(A,de),_e.BV.runKernel(we.XLW,{a:A,b:de},{transposeA:le,transposeB:ee})}})},6825:(gt,Xe,M)=>{"use strict";M.d(Xe,{g:()=>Y});var _e=M(3738),we=M(1070),te=M(7904),Q=M(9608),F=M(258),j=M(9734);const Y=(0,M(6721).op)({maximum_:function me(le,ee){let A=(0,Q._1)(le,"a","maximum"),de=(0,Q._1)(ee,"b","maximum");return[A,de]=(0,te.makeTypesMatch)(A,de),"bool"===A.dtype&&(A=(0,j.p)(A,"int32"),de=(0,j.p)(de,"int32")),(0,F.assertAndGetBroadcastShape)(A.shape,de.shape),_e.BV.runKernel(we.BMI,{a:A,b:de})}})},8788:(gt,Xe,M)=>{"use strict";M.d(Xe,{d:()=>Ie});var _e=M(3738),we=M(1070),te=M(7904),Q=M(9608);const Ie=(0,M(6721).op)({mul_:function j(me,Y){let le=(0,Q._1)(me,"a","mul"),ee=(0,Q._1)(Y,"b","mul");return[le,ee]=(0,te.makeTypesMatch)(le,ee),_e.BV.runKernel(we.wYn,{a:le,b:ee})}})},3304:(gt,Xe,M)=>{"use strict";M.d(Xe,{W:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({neg_:function F(Ie){const Y={x:(0,te._1)(Ie,"x","neg")};return _e.BV.runKernel(we.kuV,Y)}})},2738:(gt,Xe,M)=>{"use strict";M.d(Xe,{l:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({oneHot_:function F(Ie,me,Y=1,le=0,ee="int32"){if(me<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${me}`);const de={indices:(0,te._1)(Ie,"indices","oneHot","int32")};return _e.BV.runKernel(we.we_,de,{dtype:ee,depth:me,onValue:Y,offValue:le})}})},6721:(gt,Xe,M)=>{"use strict";M.d(Xe,{op:()=>Q,z:()=>te});var _e=M(3738),we=M(1396);const te="__op";function Q(F){const j=Object.keys(F);if(1!==j.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${j.length} keys.`);let Ie=j[0];const me=F[Ie];Ie.endsWith("_")&&(Ie=Ie.substring(0,Ie.length-1)),Ie+=te;const Y=(...le)=>{_e.BV.startScope(Ie);try{const ee=me(...le);return(0,we.tI)(ee)&&console.error("Cannot return a Promise inside of tidy."),_e.BV.endScope(ee),ee}catch(ee){throw _e.BV.endScope(null),ee}};return Object.defineProperty(Y,"name",{value:Ie,configurable:!0}),Y}},3084:(gt,Xe,M)=>{"use strict";M.d(Xe,{zvA:()=>j.z,WnP:()=>we.W,Khb:()=>me,__u:()=>le,IHx:()=>ee.I,QBD:()=>Pe,$6P:()=>Ze,YjB:()=>St,NqF:()=>ke,vHJ:()=>It,ZRM:()=>Ce,VfV:()=>$,z4N:()=>be,fvJ:()=>He,C80:()=>We,wS1:()=>Yt,uR5:()=>yn,zEQ:()=>Nt,tgs:()=>$r,Dxk:()=>qs,JY5:()=>Yo,p3b:()=>go,E4h:()=>zn,yE8:()=>is,anm:()=>mh,XsQ:()=>bi,UFq:()=>oo,f3b:()=>mr.f,pju:()=>nt.p,mDi:()=>Ao,iUl:()=>Re,d9v:()=>Mn.d,PYB:()=>Ur.P,zoF:()=>kn,gME:()=>Bn,Izb:()=>Ir,MNy:()=>ws,ZaL:()=>io,PAt:()=>Pt,Tek:()=>Cs,bc:()=>yo,pdZ:()=>Oo,$QV:()=>Fa,mCk:()=>ts,f9Y:()=>Pa,mew:()=>op,$Gn:()=>Jo,zbp:()=>La,ppE:()=>Hi,nTT:()=>Qn,B10:()=>ji,Ka3:()=>vn,WmZ:()=>Ws,hiC:()=>Dr.h,NTj:()=>Ki,AKD:()=>ei,rvX:()=>oy,WYO:()=>Kr,pyx:()=>$o.p,GRh:()=>Ug,DgJ:()=>Si,qNN:()=>fr,d2q:()=>Un,Qqt:()=>p,dt4:()=>C,t$B:()=>K,iyy:()=>ut,kp_:()=>Ya,hlL:()=>nr.h,GWj:()=>Je,qPi:()=>bt.q,imm:()=>_e,Iqj:()=>Gt,dbB:()=>Vg,pjt:()=>ln,brS:()=>zs,Sxn:()=>Il,asL:()=>ns.a,BHj:()=>b1,V3u:()=>ay,wx0:()=>Dl,xVT:()=>Po,UWc:()=>Hs,i2d:()=>pu,hi7:()=>Es.h,d9m:()=>br,zN1:()=>Ms,$r2:()=>w1,SX3:()=>ga,G9k:()=>Ii,cM7:()=>Xi,Krr:()=>Jt,e_t:()=>Ua,CmS:()=>ju,l_t:()=>mu,HvI:()=>yu,hJK:()=>_s,K5V:()=>sr,egP:()=>qn,MB5:()=>Th,eab:()=>Ti,OI3:()=>dn.O,Fp7:()=>ao,_sB:()=>xo,YQQ:()=>za,Ip$:()=>qd,gWQ:()=>ps.g,J69:()=>Ha,ry_:()=>Gu,VV$:()=>V,LTh:()=>Ni,VdP:()=>Fe,wQq:()=>Lf,Gi7:()=>Vf,p_:()=>Pl,dC7:()=>un.d,rq4:()=>Uf,SJ_:()=>ki,W76:()=>Cr.W,KOy:()=>Lt,Quu:()=>Bo,lfX:()=>zf.l,iUs:()=>co,JpU:()=>hl,op:()=>j.op,N2O:()=>fl,vku:()=>Vo,pNR:()=>xa,koy:()=>Zd,t1L:()=>ml,lGY:()=>Jd,d_R:()=>ms,sQ3:()=>U.s,AL3:()=>eh.A,S0v:()=>Xu.S,WVs:()=>th,$gW:()=>ja,N89:()=>nh,TN_:()=>rh,wzB:()=>uh,nGf:()=>or,ruB:()=>Qi,LGj:()=>Ic,w6H:()=>Ai,kwC:()=>ho.k,M25:()=>Tc,UYe:()=>Nc.U,btT:()=>Gf.b,XLQ:()=>Ve.X,GYS:()=>Jr,SDf:()=>Sl,diP:()=>k,sx7:()=>T,mG2:()=>X,QEs:()=>Xf,NMM:()=>fe,bp0:()=>st,iD$:()=>he.i,snQ:()=>tc,zcT:()=>Lo,U8D:()=>Tt,U_I:()=>ht,ODp:()=>Pn,XD2:()=>Fn.X,Xxe:()=>si,tdS:()=>_p,O$l:()=>rs,R_K:()=>Ri,tPi:()=>Zn,jZU:()=>Ka,SmN:()=>qu,CnO:()=>qa,p0P:()=>_l,XAC:()=>Kf,Wvh:()=>ti,fBT:()=>yl,rVs:()=>Nh,ers:()=>nc,uN7:()=>x1,Vl2:()=>Ac,_b3:()=>qe._,h62:()=>ct.h,$i:()=>Tl,L9e:()=>Nl,knu:()=>Yu,Nbs:()=>Yf.N,NXj:()=>Mg,Z_8:()=>C1,luU:()=>Cn.l,Smz:()=>je.S,ORZ:()=>lh,AEp:()=>rt,XeE:()=>Zu.X,RRF:()=>oi,odF:()=>Qu,wOQ:()=>$g.w,yXz:()=>ea,Bfx:()=>Fg,xZs:()=>Ol,Gg6:()=>oe,hg7:()=>Zf,p4s:()=>gh.p,Xu6:()=>fh,Two:()=>Qf,pUJ:()=>ep,HHK:()=>ph,GaM:()=>Ml,VD$:()=>bu,arb:()=>Ss,itS:()=>wu,lls:()=>ri,P84:()=>Mo.P});var _e={};M.r(_e),M.d(_e,{conv2d:()=>vh,depthwiseConv2d:()=>Ll,matMul:()=>zg});var we=M(2519),te=M(3738),Q=M(1070),F=M(9608),j=M(6721);const me=(0,j.op)({acos_:function Ie(N){const b={x:(0,F._1)(N,"x","acos")};return te.BV.runKernel(Q.VGw,b)}}),le=(0,j.op)({acosh_:function Y(N){const b={x:(0,F._1)(N,"x","acosh")};return te.BV.runKernel(Q.SpW,b)}});var ee=M(6849),A=M(1396);const Pe=(0,j.op)({addN_:function de(N){A.hu(Array.isArray(N),()=>"The argument passed to tf.addN() must be a list of tensors"),A.hu(N.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${N.length}`);const I=N.map((L,H)=>(0,F._1)(L,`tensors${H}`,"addN")),b=I[0];return I.forEach(L=>{if(L.dtype!==b.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),I.forEach(L=>{if(!A.cO(L.shape,b.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),te.BV.runKernel(Q.Xze,I)}}),Ze=(0,j.op)({all_:function xe(N,I=null,b=!1){const L={x:(0,F._1)(N,"x","all","bool")};return te.BV.runKernel(Q.oT6,L,{axis:I,keepDims:b})}}),St=(0,j.op)({any_:function ot(N,I=null,b=!1){const L={x:(0,F._1)(N,"x","any","bool")};return te.BV.runKernel(Q.IKK,L,{axis:I,keepDims:b})}}),ke=(0,j.op)({argMax_:function Vt(N,I=0){const R={x:(0,F._1)(N,"x","argMax")};return te.BV.runKernel(Q.sJF,R,{axis:I})}}),It=(0,j.op)({argMin_:function Oe(N,I=0){const R={x:(0,F._1)(N,"x","argMin")};return te.BV.runKernel(Q.aJk,R,{axis:I})}}),Ce=(0,j.op)({asin_:function $e(N){const b={x:(0,F._1)(N,"x","asin")};return te.BV.runKernel(Q.M2y,b)}}),$=(0,j.op)({asinh_:function ye(N){const b={x:(0,F._1)(N,"x","asinh")};return te.BV.runKernel(Q.qw7,b)}}),be=(0,j.op)({atan_:function se(N){const b={x:(0,F._1)(N,"x","atan")};return te.BV.runKernel(Q.jMg,b)}});var ce=M(7904);const He=(0,j.op)({atan2_:function x(N,I){let b=(0,F._1)(N,"a","atan2"),R=(0,F._1)(I,"b","atan2");return[b,R]=(0,ce.makeTypesMatch)(b,R),te.BV.runKernel(Q.QCc,{a:b,b:R})}}),We=(0,j.op)({atanh_:function Me(N){const b={x:(0,F._1)(N,"x","atanh")};return te.BV.runKernel(Q.Oyi,b)}});var nt=M(9734),et=M(744),Ve=M(9416);const Yt=(0,j.op)({avgPool_:function Ft(N,I,b,R,L){const H=(0,F._1)(N,"x","avgPool","float32");A.hu(et.jT(b,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${b} and dilations '1'`);let ne=H,ve=!1;3===H.rank&&(ve=!0,ne=(0,Ve.X)(H,[1,H.shape[0],H.shape[1],H.shape[2]])),A.hu(4===ne.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${ne.rank}.`),et.m("avgPool",R,L);let Ye=te.BV.runKernel(Q.JhU,{x:ne},{filterSize:I,strides:b,pad:R,dimRoundingMode:L});return Ye=(0,nt.p)(Ye,H.dtype),ve?(0,Ve.X)(Ye,[Ye.shape[1],Ye.shape[2],Ye.shape[3]]):Ye}}),yn=(0,j.op)({avgPool3d_:function Zt(N,I,b,R,L,H="NDHWC"){const Z=(0,F._1)(N,"x","avgPool3d","float32");let ne=Z,ve=!1;4===Z.rank&&(ve=!0,ne=(0,Ve.X)(Z,[1,Z.shape[0],Z.shape[1],Z.shape[2],Z.shape[3]])),A.hu(5===ne.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${ne.rank}.`),A.hu("NDHWC"===H,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${H}`),(0,et.m)("avgPool3d",R,L);let Ye=te.BV.runKernel(Q._k9,{x:ne},{filterSize:I,strides:b,pad:R,dimRoundingMode:L,dataFormat:H});return Ye=(0,nt.p)(Ye,ne.dtype),ve?(0,Ve.X)(Ye,[Ye.shape[1],Ye.shape[2],Ye.shape[3],Ye.shape[4]]):Ye}});var Mn=M(4249);const kn=(0,j.op)({concat_:function cr(N,I=0){(0,A.hu)(N.length>=1,()=>"Pass at least one tensor to concat");const b=(0,F.sI)(N,"tensors","concat","string_or_numeric");return"complex64"===b[0].dtype&&b.forEach(H=>{if("complex64"!==H.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${H.dtype}. `)}),1===b.length?(0,Mn.d)(b[0]):te.BV.runKernel(Q.Eh3,b,{axis:I})}});var dn=M(341),un=M(8788),Fn=M(6713);const Zn=(0,j.op)({slice_:function ds(N,I,b){const R=(0,F._1)(N,"x","slice","string_or_numeric");if(0===R.rank)throw new Error("Slicing scalar is not possible");return te.BV.runKernel(Q.p2w,{x:R},{begin:I,size:b})}}),rt=(0,j.op)({tanh_:function Ne(N){const b={x:(0,F._1)(N,"x","tanh","float32")};return te.BV.runKernel(Q.MIZ,b)}}),Nt=(0,j.op)({basicLSTMCell_:function lt(N,I,b,R,L,H){const Z=(0,F._1)(N,"forgetBias","basicLSTMCell"),ne=(0,F._1)(I,"lstmKernel","basicLSTMCell"),ve=(0,F._1)(b,"lstmBias","basicLSTMCell"),Se=(0,F._1)(R,"data","basicLSTMCell"),ze=(0,F._1)(L,"c","basicLSTMCell"),Ye=(0,F._1)(H,"h","basicLSTMCell"),At=kn([Se,Ye],1),Qt=(0,dn.O)(At,ne),nn=(0,ee.I)(Qt,ve),xn=nn.shape[1]/4,ir=[nn.shape[0],xn],gs=Zn(nn,[0,0],ir),ys=Zn(nn,[0,xn],ir),Xr=Zn(nn,[0,2*xn],ir),vs=Zn(nn,[0,3*xn],ir),ar=(0,ee.I)((0,un.d)((0,Fn.X)(gs),rt(ys)),(0,un.d)(ze,(0,Fn.X)((0,ee.I)(Z,Xr))));return[ar,(0,un.d)(rt(ar),(0,Fn.X)(vs))]}}),zn=(0,j.op)({batchToSpaceND_:function wn(N,I,b){const R=(0,F._1)(N,"x","batchToSpaceND"),L=I.reduce((ne,ve)=>ne*ve);return A.hu(R.rank>=1+I.length,()=>`input rank is ${R.rank} but should be > than blockShape.length ${I.length}`),A.hu(b.length===I.length,()=>`crops.length is ${b.length} but should be equal to blockShape.length  ${I.length}`),A.hu(R.shape[0]%L==0,()=>`input tensor batch is ${R.shape[0]} but is not divisible by the product of the elements of blockShape ${I.join(" * ")} === ${L}`),te.BV.runKernel(Q.zws,{x:R},{blockShape:I,crops:b})}});function Jn(N){let I;return I=0===N.rank||1===N.rank?(0,Ve.X)(N,[1,1,1,N.size]):2===N.rank?(0,Ve.X)(N,[1,1,N.shape[0],N.shape[1]]):3===N.rank?(0,Ve.X)(N,[1,N.shape[0],N.shape[1],N.shape[2]]):N,I}const $r=(0,j.op)({batchNorm_:function wr(N,I,b,R,L,H){null==H&&(H=.001);const Z=(0,F._1)(N,"x","batchNorm"),ne=(0,F._1)(I,"mean","batchNorm"),ve=(0,F._1)(b,"variance","batchNorm");let Se,ze;null!=L&&(Se=(0,F._1)(L,"scale","batchNorm")),null!=R&&(ze=(0,F._1)(R,"offset","batchNorm")),A.hu(ne.rank===ve.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),A.hu(null==ze||ne.rank===ze.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),A.hu(null==Se||ne.rank===Se.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const At={x:Jn(Z),scale:Se,offset:ze,mean:ne,variance:ve},nn=te.BV.runKernel(Q.sHE,At,{varianceEpsilon:H});return(0,Ve.X)(nn,Z.shape)}}),qs=(0,j.op)({batchNorm2d_:function _r(N,I,b,R,L,H){const Z=(0,F._1)(N,"x","batchNorm"),ne=(0,F._1)(I,"mean","batchNorm"),ve=(0,F._1)(b,"variance","batchNorm");let Se,ze;return null!=L&&(Se=(0,F._1)(L,"scale","batchNorm")),null!=R&&(ze=(0,F._1)(R,"offset","batchNorm")),A.hu(2===Z.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${Z.rank}.`),A.hu(2===ne.rank||1===ne.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${ne.rank}.`),A.hu(2===ve.rank||1===ve.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${ve.rank}.`),null!=Se&&A.hu(2===Se.rank||1===Se.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${Se.rank}.`),null!=ze&&A.hu(2===ze.rank||1===ze.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${ze.rank}.`),$r(Z,ne,ve,ze,Se,H)}}),Yo=(0,j.op)({batchNorm3d_:function Ys(N,I,b,R,L,H){const Z=(0,F._1)(N,"x","batchNorm"),ne=(0,F._1)(I,"mean","batchNorm"),ve=(0,F._1)(b,"variance","batchNorm");let Se,ze;return null!=L&&(Se=(0,F._1)(L,"scale","batchNorm")),null!=R&&(ze=(0,F._1)(R,"offset","batchNorm")),A.hu(3===Z.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${Z.rank}.`),A.hu(3===ne.rank||1===ne.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${ne.rank}.`),A.hu(3===ve.rank||1===ve.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${ve.rank}.`),null!=Se&&A.hu(3===Se.rank||1===Se.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${Se.rank}.`),null!=ze&&A.hu(3===ze.rank||1===ze.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${ze.rank}.`),$r(Z,ne,ve,ze,Se,H)}}),go=(0,j.op)({batchNorm4d_:function Fr(N,I,b,R,L,H){const Z=(0,F._1)(N,"x","batchNorm"),ne=(0,F._1)(I,"mean","batchNorm"),ve=(0,F._1)(b,"variance","batchNorm");let Se,ze;return null!=L&&(Se=(0,F._1)(L,"scale","batchNorm")),null!=R&&(ze=(0,F._1)(R,"offset","batchNorm")),A.hu(4===Z.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${Z.rank}.`),A.hu(4===ne.rank||1===ne.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${ne.rank}.`),A.hu(4===ve.rank||1===ve.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${ve.rank}.`),null!=Se&&A.hu(4===Se.rank||1===Se.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${Se.rank}.`),null!=ze&&A.hu(4===ze.rank||1===ze.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${ze.rank}.`),$r(Z,ne,ve,ze,Se,H)}}),is=(0,j.op)({bincount_:function os(N,I,b){const R=(0,F._1)(N,"x","bincount"),L=(0,F._1)(I,"weights","bincount");return A.hu("int32"===R.dtype,()=>`Error in bincount: input dtype must be int32, but got ${R.dtype}`),A.hu(b>=0,()=>`size must be non-negative, but got ${b}.`),A.hu(L.size===R.size||0===L.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${R.shape}, weights shape: ${L.shape}.`),te.BV.runKernel(Q.zvY,{x:R,weights:L},{size:b})}}),bi=(0,j.op)({broadcastArgs_:function Zo(N,I){const b=(0,F._1)(N,"s0","broadcastArgs","int32"),R=(0,F._1)(I,"s1","broadcastArgs","int32");if(1!==b.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${b.rank}`);if(1!==R.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${R.rank}`);return te.BV.runKernel(Q.eEB,{s0:b,s1:R})}}),oo=(0,j.op)({broadcastTo_:function Zs(N,I){let b=(0,F._1)(N,"broadcastTo","x");const R=b.shape;if(I.some(Se=>!(Se>0)||Se%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${I}].`);if(I.length<b.rank)throw new Error(`broadcastTo(): shape.length=${I.length} < input.rank=${b.rank}.`);if(I.length>b.rank){const Se=b.shape.slice();for(;Se.length<I.length;)Se.unshift(1);b=(0,Ve.X)(b,Se)}const L=b.shape,H=Array.from(I);for(let Se=I.length-1;Se>=0;Se--)if(L[Se]===I[Se])H[Se]=1;else if(1!==b.shape[Se])throw new Error(`broadcastTo(): [${R}] cannot be broadcast to [${I}].`);return 0===H.map((Se,ze)=>Se>1?ze:-1).filter(Se=>Se>=0).length?(0,Mn.d)(b):te.BV.runKernel(Q.n9L,{x:b},{reps:H})}});var mr=M(8621);const Ao=(0,j.op)({ceil_:function Qo(N){const b={x:(0,F._1)(N,"x","ceil","float32")};return te.BV.runKernel(Q.gJX,b)}});var nr=M(8509);const Re=(0,j.op)({clipByValue_:function Ro(N,I,b){const R=(0,F._1)(N,"x","clipByValue");return A.hu(I<=b,()=>`Error in clip: min (${I}) must be less than or equal to max (${b}).`),I===b?(0,nr.h)(R.shape,I,R.dtype):te.BV.runKernel(Q.xnO,{x:R},{clipValueMin:I,clipValueMax:b})}});var Ur=M(9907);const Bn=(0,j.op)({concat1d_:function Hn(N){return kn(N,0)}}),Ir=(0,j.op)({concat2d_:function hr(N,I){return kn(N,I)}}),ws=(0,j.op)({concat3d_:function Pr(N,I){return kn(N,I)}}),io=(0,j.op)({concat4d_:function sn(N,I){return kn(N,I)}}),Cs=(0,j.op)({conv2d_:function Gr(N,I,b,R,L="NHWC",H=[1,1],Z){const ne=(0,F._1)(N,"x","conv2d","float32"),ve=(0,F._1)(I,"filter","conv2d","float32");let Se=ne,ze=!1;3===ne.rank&&(ze=!0,Se=(0,Ve.X)(ne,[1,ne.shape[0],ne.shape[1],ne.shape[2]])),A.hu(4===Se.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${Se.rank}.`),A.hu(4===ve.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${ve.rank}.`),et.m("conv2d",R,Z);const Ye="NHWC"===L?Se.shape[3]:Se.shape[1];A.hu(Ye===ve.shape[2],()=>`Error in conv2d: depth of input (${Ye}) must match input depth for filter ${ve.shape[2]}.`),A.hu(et.jT(b,H),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${b} and dilations '${H}'`);const nn=te.BV.runKernel(Q.mhS,{x:Se,filter:ve},{strides:b,pad:R,dataFormat:L,dilations:H,dimRoundingMode:Z});return ze?(0,Ve.X)(nn,[nn.shape[1],nn.shape[2],nn.shape[3]]):nn}}),Pt=(0,j.op)({conv1d_:function Vi(N,I,b,R,L="NWC",H=1,Z){const ne=(0,F._1)(N,"x","conv1d"),ve=(0,F._1)(I,"filter","conv1d");let Se=ne,ze=!1;2===ne.rank&&(ze=!0,Se=(0,Ve.X)(ne,[1,ne.shape[0],ne.shape[1]])),A.hu(3===Se.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${Se.rank}.`),A.hu(3===ve.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${ve.rank}.`),et.m("conv1d",R,Z),A.hu(Se.shape[2]===ve.shape[1],()=>`Error in conv1d: depth of input (${Se.shape[2]}) must match input depth for filter ${ve.shape[1]}.`),A.hu(et.jT(b,H),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${b} and dilation '${H}'`),A.hu("NWC"===L,()=>`Error in conv1d: got dataFormat of ${L} but only NWC is currently supported.`);const Ye=(0,Ve.X)(ve,[1,ve.shape[0],ve.shape[1],ve.shape[2]]),At=(0,Ve.X)(Se,[Se.shape[0],1,Se.shape[1],Se.shape[2]]),xn=Cs(At,Ye,[1,b],R,"NHWC",[1,H],Z);return(0,Ve.X)(xn,ze?[xn.shape[2],xn.shape[3]]:[xn.shape[0],xn.shape[2],xn.shape[3]])}}),pn=(0,j.op)({conv2DBackpropInput_:function Lr(N,I,b,R,L,H="NHWC",Z){A.hu(N.length===I.rank,()=>`Length of inShape (${N.length}) and rank of dy (${I.rank}) must match`);let ne=N,ve=I,Se=!1;3===I.rank&&(Se=!0,ve=(0,Ve.X)(I,[1,I.shape[0],I.shape[1],I.shape[2]]),ne=[1,N[0],N[1],N[2]]),A.hu(4===ne.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${ne.length}.`),A.hu(4===ve.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${ve.rank}`),A.hu(4===b.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${b.rank}`);const ze="NHWC"===H?ne[3]:ne[1],Ye="NHWC"===H?ve.shape[3]:ve.shape[1];A.hu(ze===b.shape[2],()=>`Error in conv2dDerInput: depth of input (${ze}) must match input depth for filter ${b.shape[2]}.`),A.hu(Ye===b.shape[3],()=>`Error in conv2dDerInput: depth of output (${Ye}) must match output depth for filter ${b.shape[3]}.`),et.m("conv2dDerInput",L,Z);const nn=te.BV.runKernel(Q.wm,{dy:ve,filter:b},{strides:R,pad:L,dataFormat:H,dimRoundingMode:Z,inputShape:ne});return Se?(0,Ve.X)(nn,[nn.shape[1],nn.shape[2],nn.shape[3]]):nn}}),yo=(0,j.op)({conv2dTranspose_:function rr(N,I,b,R,L,H){const Z=(0,F._1)(N,"x","conv2dTranspose"),ne=(0,F._1)(I,"filter","conv2dTranspose");return pn(b,Z,ne,R,L,"NHWC",H)}}),Oo=(0,j.op)({conv3d_:function $a(N,I,b,R,L="NDHWC",H=[1,1,1]){const Z=(0,F._1)(N,"x","conv3d"),ne=(0,F._1)(I,"filter","conv3d");let ve=Z,Se=!1;4===Z.rank&&(Se=!0,ve=(0,Ve.X)(Z,[1,Z.shape[0],Z.shape[1],Z.shape[2],Z.shape[3]])),A.hu(5===ve.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${ve.rank}.`),A.hu(5===ne.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${ne.rank}.`),A.hu(ve.shape[4]===ne.shape[3],()=>`Error in conv3d: depth of input (${ve.shape[4]}) must match input depth for filter ${ne.shape[3]}.`),A.hu((0,et.jT)(b,H),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${b} and dilations '${H}'`),A.hu("NDHWC"===L,()=>`Error in conv3d: got dataFormat of ${L} but only NDHWC is currently supported.`);const At=te.BV.runKernel(Q.x12,{x:ve,filter:ne},{strides:b,pad:R,dataFormat:L,dilations:H});return Se?(0,Ve.X)(At,[At.shape[1],At.shape[2],At.shape[3],At.shape[4]]):At}}),hs=(0,j.op)({conv3DBackpropInput_:function Us(N,I,b,R,L){A.hu(N.length===I.rank,()=>`Length of inShape (${N.length}) and rank of dy (${I.rank}) must match`);let H=N,Z=I,ne=!1;4===I.rank&&(ne=!0,Z=(0,Ve.X)(I,[1,I.shape[0],I.shape[1],I.shape[2],I.shape[3]]),H=[1,N[0],N[1],N[2],N[3]]);const ve=H[4],Se=Z.shape[4];A.hu(5===H.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${H.length}.`),A.hu(5===Z.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${Z.rank}`),A.hu(5===b.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${b.rank}`),A.hu(ve===b.shape[3],()=>`Error in conv3dDerInput: depth of input (${ve}) must match input depth for filter ${b.shape[3]}.`),A.hu(Se===b.shape[4],()=>`Error in conv3dDerInput: depth of output (${Se}) must match output depth for filter ${b.shape[4]}.`);const At=te.BV.runKernel(Q.ik2,{dy:Z,filter:b},{pad:L,strides:R,inputShape:H});return ne?(0,Ve.X)(At,[At.shape[1],At.shape[2],At.shape[3],At.shape[4]]):At}}),Fa=(0,j.op)({conv3dTranspose_:function Ui(N,I,b,R,L){const H=(0,F._1)(N,"x","conv3dTranspose"),Z=(0,F._1)(I,"filter","conv3dTranspose");return hs(b,H,Z,R,L)}}),ts=(0,j.op)({cos_:function ha(N){const b={x:(0,F._1)(N,"x","cos","float32")};return te.BV.runKernel(Q.mc4,b)}}),Pa=(0,j.op)({cosh_:function wi(N){const b={x:(0,F._1)(N,"x","cosh","float32")};return te.BV.runKernel(Q.TR1,b)}}),Jo=(0,j.op)({cumprod_:function Wi(N,I=0,b=!1,R=!1){const H={x:(0,F._1)(N,"x","cumprod")};return te.BV.runKernel(Q.Byc,H,{axis:I,exclusive:b,reverse:R})}}),La=(0,j.op)({cumsum_:function zi(N,I=0,b=!1,R=!1){const H={x:(0,F._1)(N,"x","cumsum")};return te.BV.runKernel(Q.iHb,H,{axis:I,exclusive:b,reverse:R})}}),Hi=(0,j.op)({denseBincount_:function fa(N,I,b,R=!1){const L=(0,F._1)(N,"x","denseBincount"),H=(0,F._1)(I,"weights","denseBincount");return A.hu("int32"===L.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${L.dtype}`),A.hu(L.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${L.rank}.`),A.hu(b>=0,()=>`size must be non-negative, but got ${b}.`),A.hu(H.size===L.size||0===H.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${L.shape}, weights shape: ${H.shape}.`),te.BV.runKernel(Q.QRR,{x:L,weights:H},{size:b,binaryOutput:R})}}),Qn=(0,j.op)({depthToSpace_:function as(N,I,b="NHWC"){const R=(0,F._1)(N,"x","depthToSpace","float32"),L="NHWC"===b?R.shape[1]:R.shape[2],H="NHWC"===b?R.shape[2]:R.shape[3],Z="NHWC"===b?R.shape[3]:R.shape[1];return A.hu(I>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${I}`),A.hu(L*I>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${L} and ${I}  for depthToSpace with input shape\n    ${R.shape}`),A.hu(H*I>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${H} and ${I} for depthToSpace with input shape\n        ${R.shape}`),A.hu(Z%(I*I)==0,()=>`Dimension size must be evenly divisible by ${I*I} but is ${Z} for depthToSpace with input shape ${R.shape}`),te.BV.runKernel(Q.T0n,{x:R},{blockSize:I,dataFormat:b})}}),ji=(0,j.op)({depthwiseConv2d_:function hu(N,I,b,R,L="NHWC",H=[1,1],Z){const ne=(0,F._1)(N,"x","depthwiseConv2d","float32"),ve=(0,F._1)(I,"filter","depthwiseConv2d","float32");let Se=ne,ze=!1;3===ne.rank&&(ze=!0,Se=(0,Ve.X)(ne,[1,ne.shape[0],ne.shape[1],ne.shape[2]])),A.hu(4===Se.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${Se.rank}.`),A.hu(4===ve.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${ve.rank}.`);const Ye="NHWC"===L?Se.shape[3]:Se.shape[1];A.hu(Ye===ve.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${Ye}) must match the inChannels dimension in filter ${ve.shape[2]}.`),et.m("depthwiseConv2d",R,Z);const nn=te.BV.runKernel(Q.cie,{x:Se,filter:ve},{strides:b,pad:R,dataFormat:L,dilations:H,dimRoundingMode:Z});return ze?(0,Ve.X)(nn,[nn.shape[1],nn.shape[2],nn.shape[3]]):nn}}),vn=(0,j.op)({diag_:function fu(N){const b={x:(0,F._1)(N,"x","diag")};return te.BV.runKernel(Q.$w,b)}}),Ws=(0,j.op)({dilation2d_:function Ba(N,I,b,R,L=[1,1],H="NHWC"){const Z=(0,F._1)(N,"x","dilation2d"),ne=(0,F._1)(I,"filter","dilation2d");A.hu(3===Z.rank||4===Z.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${Z.rank}.`),A.hu(3===ne.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${ne.rank}.`),A.hu("NHWC"===H,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${H}`);let ve=Z,Se=!1;3===Z.rank&&(ve=(0,Ve.X)(Z,[1,Z.shape[0],Z.shape[1],Z.shape[2]]),Se=!0);const At=te.BV.runKernel(Q.p4S,{x:ve,filter:ne},{strides:b,pad:R,dilations:L});return Se?(0,Ve.X)(At,[At.shape[1],At.shape[2],At.shape[3]]):At}});var Dr=M(6635),Br=M(258);const Si=(0,j.op)({equal_:function Ci(N,I){let b=(0,F._1)(N,"a","equal","string_or_numeric"),R=(0,F._1)(I,"b","equal","string_or_numeric");return[b,R]=(0,ce.makeTypesMatch)(b,R),(0,Br.assertAndGetBroadcastShape)(b.shape,R.shape),te.BV.runKernel(Q.hdR,{a:b,b:R})}}),Ss=(0,j.op)({where_:function pa(N,I,b){const R=(0,F._1)(I,"a","where"),L=(0,F._1)(b,"b","where"),H=(0,F._1)(N,"condition","where","bool"),Z=(0,Br.assertAndGetBroadcastShape)((0,Br.assertAndGetBroadcastShape)(H.shape,R.shape),L.shape),ne=oo(H,Z),ve=oo(R,Z),Se=oo(L,Z);return te.BV.runKernel(Q.PhF,{condition:ne,t:ve,e:Se})}});var Mo=M(37);const Ki=(0,j.op)({divNoNan_:function Gi(N,I){let b=(0,F._1)(N,"a","div"),R=(0,F._1)(I,"b","div");[b,R]=(0,ce.makeTypesMatch)(b,R);const L=(0,Dr.h)(b,R),H=(0,Mo.P)(L),Z=Si(R,H);return Ss(Z,H,L)}}),ei=(0,j.op)({dot_:function mn(N,I){const b=(0,F._1)(N,"t1","dot"),R=(0,F._1)(I,"t2","dot");A.hu(!(1!==b.rank&&2!==b.rank||1!==R.rank&&2!==R.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${b.rank} and ${R.rank}.`);const L=1===b.rank?b.size:b.shape[1],H=1===R.rank?R.size:R.shape[0];if(A.hu(L===H,()=>`Error in dot: inner dimensions of inputs must match, but got ${L} and ${H}.`),1===b.rank&&1===R.rank){const Z=(0,Ve.X)(b,[1,-1]),ne=(0,Ve.X)(R,[-1,1]),ve=(0,dn.O)(Z,ne);return(0,Ve.X)(ve,[])}if(1===b.rank&&2===R.rank){const Z=(0,Ve.X)(b,[1,-1]),ne=(0,Ve.X)(R,[R.shape[0],R.shape[1]]),ve=(0,dn.O)(Z,ne);return(0,Ve.X)(ve,[ve.size])}if(2===b.rank&&1===R.rank){const Z=(0,Ve.X)(R,[-1,1]),ne=(0,dn.O)(b,Z);return(0,Ve.X)(ne,[ne.size])}{const Z=(0,Ve.X)(R,[R.shape[0],R.shape[1]]);return(0,dn.O)(b,Z)}}}),Kr=(0,j.op)({einsum_:function Ei(N,...I){const b=I.map((L,H)=>(0,F._1)(L,`tensors${H}`,"einsum"));return te.BV.runKernel(Q.$g6,b,{equation:N})}});var $o=M(4609);const fr=(0,j.op)({erf_:function ma(N){let I=(0,F._1)(N,"x","erf");return A.hu("int32"===I.dtype||"float32"===I.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===I.dtype&&(I=(0,nt.p)(I,"float32")),te.BV.runKernel(Q.Omj,{x:I})}});var Fo=M(7745);const ao=(0,j.op)({max_:function Va(N,I=null,b=!1){const L={x:(0,F._1)(N,"x","max")};return te.BV.runKernel(Q.YoZ,L,{reductionIndices:I,keepDims:b})}}),V=(0,j.op)({min_:function _(N,I=null,b=!1){const L={x:(0,F._1)(N,"x","min")};return te.BV.runKernel(Q.c17,L,{axis:I,keepDims:b})}});var U=M(9043),he=M(316),qe=M(5562),ct=M(4164),je=M(5214);function ge(N,I,b=null){if(0===N.rank)return(0,we.W)(N);if(1!==N.rank&&null===b)return ge((0,Ve.X)(N,[-1]),I,b);if(1===N.rank||"number"==typeof b||Array.isArray(b)&&1===b.length){if(1===I)return(0,je.S)((0,we.W)(N),b);if(I===1/0)return ao((0,we.W)(N),b);if(I===-1/0)return V((0,we.W)(N),b);if("euclidean"===I||2===I)return(0,qe._)((0,je.S)((0,U.s)((0,we.W)(N),(0,he.i)(2,"int32")),b));throw new Error(`Error in norm: invalid ord value: ${I}`)}if(Array.isArray(b)&&2===b.length){if(1===I)return ao((0,je.S)((0,we.W)(N),b[0]),b[1]-1);if(I===1/0)return ao((0,je.S)((0,we.W)(N),b[1]),b[0]);if(I===-1/0)return V((0,je.S)((0,we.W)(N),b[1]),b[0]);if("fro"===I||"euclidean"===I)return(0,qe._)((0,je.S)((0,ct.h)(N),b));throw new Error(`Error in norm: invalid ord value: ${I}`)}throw new Error(`Error in norm: invalid axis: ${b}`)}const Lt=(0,j.op)({norm_:function at(N,I="euclidean",b=null,R=!1){const L=ge(N=(0,F._1)(N,"x","norm"),I,b);let H=L.shape;if(R){const Z=(0,A.EC)(b,N.shape);H=Fo.rv(L.shape,Z)}return(0,Ve.X)(L,H)}}),Un=(0,j.op)({euclideanNorm_:function kt(N,I=null,b=!1){return Lt(N,"euclidean",I,b)}}),p=(0,j.op)({exp_:function v(N){const b={x:(0,F._1)(N,"x","exp")};return te.BV.runKernel(Q.NEP,b)}}),C=(0,j.op)({expandDims_:function g(N,I=0){const b=(0,F._1)(N,"x","expandDims","string_or_numeric");return A.hu(I<=b.rank,()=>"Axis must be <= rank of the tensor"),te.BV.runKernel(Q.YFo,{input:b},{dim:I})}}),K=(0,j.op)({expm1_:function G(N){const b={x:(0,F._1)(N,"x","expm1")};return te.BV.runKernel(Q.Y0y,b)}}),oe=(0,j.op)({tile_:function ae(N,I){const b=(0,F._1)(N,"x","tile","string_or_numeric");return A.hu(b.rank===I.length,()=>`Error in transpose: rank of input ${b.rank} must match length of reps ${I}.`),te.BV.runKernel(Q.n9L,{x:b},{reps:I})}}),ut=(0,j.op)({eye_:function Ue(N,I,b,R="float32"){null==I&&(I=N);const L=(0,mr.f)([N,I],R),H=N<=I?N:I;for(let ne=0;ne<H;++ne)L.set(1,ne,ne);const Z=(0,Ve.X)(L.toTensor(),[N,I]);if(null==b)return Z;if(1===b.length)return oe(C(Z,0),[b[0],1,1]);if(2===b.length)return oe(C(C(Z,0),0),[b[0],b[1],1,1]);if(3===b.length)return oe(C(C(C(Z,0),0),0),[b[0],b[1],b[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${b.length}D.`)}}),Je=(0,j.op)({floor_:function tt(N){const b={x:(0,F._1)(N,"x","floor","float32")};return te.BV.runKernel(Q.OR,b)}});var bt=M(3273);const Gt=(0,j.op)({gather_:function Wt(N,I,b=0,R=0){const L=(0,F._1)(N,"x","gather"),H=(0,F._1)(I,"indices","gather","int32");return te.BV.runKernel(Q.qi_,{x:L,indices:H},{axis:b,batchDims:R})}}),ln=(0,j.op)({greater_:function Ht(N,I){let b=(0,F._1)(N,"a","greater","string_or_numeric"),R=(0,F._1)(I,"b","greater","string_or_numeric");return[b,R]=(0,ce.makeTypesMatch)(b,R),(0,Br.assertAndGetBroadcastShape)(b.shape,R.shape),te.BV.runKernel(Q.iZT,{a:b,b:R})}}),zs=(0,j.op)({greaterEqual_:function xr(N,I){let b=(0,F._1)(N,"a","greaterEqual","string_or_numeric"),R=(0,F._1)(I,"b","greaterEqual","string_or_numeric");return[b,R]=(0,ce.makeTypesMatch)(b,R),(0,Br.assertAndGetBroadcastShape)(b.shape,R.shape),te.BV.runKernel(Q.Acj,{a:b,b:R})}});var ns=M(5294);const Po=(0,j.op)({isFinite_:function kr(N){const b={x:(0,F._1)(N,"x","isFinite")};return te.BV.runKernel(Q.avt,b)}}),Hs=(0,j.op)({isInf_:function _i(N){const b={x:(0,F._1)(N,"x","isInf")};return te.BV.runKernel(Q.iWB,b)}}),pu=(0,j.op)({isNaN_:function Hu(N){const b={x:(0,F._1)(N,"x","isNaN")};return te.BV.runKernel(Q.r7n,b)}});var Es=M(6151);const br=(0,j.op)({less_:function Qs(N,I){let b=(0,F._1)(N,"a","less","string_or_numeric"),R=(0,F._1)(I,"b","less","string_or_numeric");return[b,R]=(0,ce.makeTypesMatch)(b,R),(0,Br.assertAndGetBroadcastShape)(b.shape,R.shape),te.BV.runKernel(Q.vtC,{a:b,b:R})}}),Ms=(0,j.op)({lessEqual_:function Os(N,I){let b=(0,F._1)(N,"a","lessEqual","string_or_numeric"),R=(0,F._1)(I,"b","lessEqual","string_or_numeric");return[b,R]=(0,ce.makeTypesMatch)(b,R),(0,Br.assertAndGetBroadcastShape)(b.shape,R.shape),te.BV.runKernel(Q.CAk,{a:b,b:R})}});function ga(N,I,b){if(b<=0)throw new Error("The number of values should be positive.");return te.BV.runKernel(Q.e7N,{},{start:N,stop:I,num:b})}const Ii=(0,j.op)({localResponseNormalization_:function Js(N,I=5,b=1,R=1,L=.5){const H=(0,F._1)(N,"x","localResponseNormalization");A.hu(4===H.rank||3===H.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${H.rank}.`),A.hu(A.GN(I),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${I}.`);let Z=H,ne=!1;3===H.rank&&(ne=!0,Z=(0,Ve.X)(H,[1,H.shape[0],H.shape[1],H.shape[2]]));const ze=te.BV.runKernel(Q.eZ0,{x:Z},{depthRadius:I,bias:b,alpha:R,beta:L});return ne?(0,Ve.X)(ze,[ze.shape[1],ze.shape[2],ze.shape[3]]):ze}}),Xi=(0,j.op)({log_:function Di(N){const b={x:(0,F._1)(N,"x","log","float32")};return te.BV.runKernel(Q.ZbH,b)}}),Jt=(0,j.op)({log1p_:function vo(N){const b={x:(0,F._1)(N,"x","log1p")};return te.BV.runKernel(Q.kU,b)}});var _n=M(1335),Cr=M(3304);const ti=(0,j.op)({softplus_:function uo(N){const b={x:(0,F._1)(N,"x","softplus")};return te.BV.runKernel(Q.MRv,b)}}),Ua=(0,j.op)({logSigmoid_:function $s(N){const I=(0,F._1)(N,"x","logSigmoid");return(0,_n.cb)(R=>({value:(0,Cr.W)(ti((0,Cr.W)(R))),gradFunc:Z=>(0,un.d)(Z,(0,Fn.X)((0,Cr.W)(R)))}))(I)}});var Cn=M(8578);const ju=(0,j.op)({logSoftmax_:function Wa(N,I=-1){const b=(0,F._1)(N,"logits","logSoftmax");if(-1===I&&(I=b.rank-1),I!==b.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${b.rank} and axis was ${I}`);return(0,_n.cb)((L,H)=>{const ne=ao(L,I,!0),ve=(0,Cn.l)(L,ne),Se=(0,Cn.l)((0,nt.p)(ve,"float32"),Xi((0,je.S)(p(ve),I,!0)));return H([Se]),{value:Se,gradFunc:(Ye,At)=>{const[Qt]=At,Wn=p(Qt);return(0,Cn.l)(Ye,(0,un.d)((0,je.S)(Ye,I,!0),Wn))}}})(b)}}),mu=(0,j.op)({logSumExp_:function Kn(N,I=null,b=!1){const R=(0,F._1)(N,"x","logSumExp"),L=(0,A.EC)(I,R.shape),H=ao(R,L,!0),Z=(0,Cn.l)(R,H),ne=p(Z),ve=(0,je.S)(ne,L),Se=Xi(ve),ze=(0,ee.I)((0,Ve.X)(H,Se.shape),Se);if(b){const Ye=(0,Fo.rv)(ze.shape,L);return(0,Ve.X)(ze,Ye)}return ze}}),yu=(0,j.op)({logicalAnd_:function gu(N,I){const b=(0,F._1)(N,"a","logicalAnd","bool"),R=(0,F._1)(I,"b","logicalAnd","bool");return(0,Br.assertAndGetBroadcastShape)(b.shape,R.shape),te.BV.runKernel(Q.PYm,{a:b,b:R})}}),_s=(0,j.op)({logicalNot_:function qi(N){const b={x:(0,F._1)(N,"x","logicalNot","bool")};return te.BV.runKernel(Q.VfG,b)}}),sr=(0,j.op)({logicalOr_:function fn(N,I){const b=(0,F._1)(N,"a","logicalOr","bool"),R=(0,F._1)(I,"b","logicalOr","bool");return(0,Br.assertAndGetBroadcastShape)(b.shape,R.shape),te.BV.runKernel(Q.MZg,{a:b,b:R})}}),qn=(0,j.op)({logicalXor_:function us(N,I){const b=(0,F._1)(N,"a","logicalXor","bool"),R=(0,F._1)(I,"b","logicalXor","bool");return(0,Br.assertAndGetBroadcastShape)(b.shape,R.shape),yu(sr(N,I),_s(yu(N,I)))}}),ni=2147483648,Lo=(0,j.op)({searchSorted_:function gr(N,I,b="left"){const R=(0,F._1)(N,"sortedSequence","searchSorted"),L=(0,F._1)(I,"values","searchSorted"),Z=L.shape[L.shape.length-1],ne=(0,Ve.X)(R,[-1,R.shape[R.shape.length-1]]),ve=(0,Ve.X)(L,[-1,Z]);if(ne.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(ne.shape[0]!==ve.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,A.NA)(ve.shape)>=ni)throw new Error(`values tensor size must less than ${ni}`);if(ne.shape[1]>=ni)throw new Error(`trailing dim_size must less than ${ni} for int32 output type, was ${ne.shape[1]}`);return te.BV.runKernel(Q.nr8,{sortedSequence:ne,values:ve},{side:b})}});function Ti(N,I){return Lo(N,I,"left")}const xo=(0,j.op)({maxPool_:function Yi(N,I,b,R,L){const H=(0,F._1)(N,"x","maxPool");let ne=H,ve=!1;3===H.rank&&(ve=!0,ne=(0,Ve.X)(H,[1,H.shape[0],H.shape[1],H.shape[2]])),A.hu(4===ne.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${ne.rank}.`),A.hu(et.jT(b,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${b} and dilations '1'`),et.m("maxPool",R,L);const Ye=te.BV.runKernel(Q.mTV,{x:ne},{filterSize:I,strides:b,pad:R,dimRoundingMode:L});return ve?(0,Ve.X)(Ye,[Ye.shape[1],Ye.shape[2],Ye.shape[3]]):Ye}}),za=(0,j.op)({maxPool3d_:function ya(N,I=[1,1,1],b,R,L,H="NDHWC"){const Z=(0,F._1)(N,"x","maxPool3d");let ne=Z,ve=!1;4===Z.rank&&(ve=!0,ne=(0,Ve.X)(Z,[1,Z.shape[0],Z.shape[1],Z.shape[2],Z.shape[3]])),A.hu(5===ne.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${ne.rank}.`),A.hu("NDHWC"===H,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${H}`),(0,et.m)("maxPool3d",R,L);const Ye=te.BV.runKernel(Q.OAf,{x:ne},{filterSize:I,strides:b,pad:R,dimRoundingMode:L,dataFormat:H});return ve?(0,Ve.X)(Ye,[Ye.shape[1],Ye.shape[2],Ye.shape[3],Ye.shape[4]]):Ye}}),qd=(0,j.op)({maxPoolWithArgmax_:function fs(N,I,b,R,L=!1){const Z={x:(0,F._1)(N,"x","maxPoolWithArgmax")},ve=te.BV.runKernel(Q.vFR,Z,{filterSize:I,strides:b,pad:R,includeBatchInIndex:L});return{result:ve[0],indexes:ve[1]}}});var ps=M(6825);const Ha=(0,j.op)({mean_:function eo(N,I=null,b=!1){const L={x:(0,F._1)(N,"x","mean")};return te.BV.runKernel(Q.q2K,L,{axis:I,keepDims:b})}});function ri(N,I="float32"){if("complex64"===I){const R=ri(N,"float32"),L=ri(N,"float32");return(0,Ur.P)(R,L)}const b=(0,A.wT)((0,A.NA)(N),I);return te.BV.makeTensor(b,N,I)}function co(N,I="float32"){if("complex64"===I){const R=co(N,"float32"),L=ri(N,"float32");return(0,Ur.P)(R,L)}const b=(0,A.p8)((0,A.NA)(N),I);return te.BV.makeTensor(b,N,I)}var cs=M(708);function Gu(N,I,{indexing:b="xy"}={}){if("xy"!==b&&"ij"!==b)throw new TypeError(`${b} is not a valid third argument to meshgrid`);if(void 0===N)return[];let R=(0,F._1)(N,"x","meshgrid",N instanceof cs.es?N.dtype:"float32");if(void 0===I)return[R];let L=(0,F._1)(I,"y","meshgrid",I instanceof cs.es?I.dtype:"float32");const H=(0,A.NA)(R.shape),Z=(0,A.NA)(L.shape);return"xy"===b?(R=(0,Ve.X)(R,[1,-1]),L=(0,Ve.X)(L,[-1,1]),[(0,dn.O)(co([Z,1],R.dtype),R),(0,dn.O)(L,co([1,H],L.dtype))]):(R=(0,Ve.X)(R,[-1,1]),L=(0,Ve.X)(L,[1,-1]),[(0,dn.O)(R,co([1,Z],R.dtype)),(0,dn.O)(co([H,1],L.dtype),L)])}const Ni=(0,j.op)({minimum_:function wc(N,I){let b=(0,F._1)(N,"a","minimum"),R=(0,F._1)(I,"b","minimum");return[b,R]=(0,ce.makeTypesMatch)(b,R),"bool"===b.dtype&&(b=(0,nt.p)(b,"int32"),R=(0,nt.p)(R,"int32")),(0,Br.assertAndGetBroadcastShape)(b.shape,R.shape),te.BV.runKernel(Q.q8u,{a:b,b:R})}}),Fe=(0,j.op)({mirrorPad_:function Ku(N,I,b){A.hu("reflect"===b||"symmetric"===b,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${b}.`);const R=(0,F._1)(N,"x","mirrorPad");if(0===R.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");A.hu(I.length===R.rank,()=>`Padding doesn't match input. Must be ${R.rank}. Got ${I.length}.`);const L="reflect"===b?1:0;for(let ne=0;ne<R.rank;ne++)A.hu(2===I[ne].length,()=>"Invalid number of paddings. Must be length of 2 each."),A.hu(I[ne][0]>=0&&I[ne][0]<=R.shape[ne]-L&&I[ne][1]>=0&&I[ne][1]<=R.shape[ne]-L,()=>`Padding in dimension ${ne} cannot be greater than or equal to ${R.shape[ne]-L} or less than 0 for input of shape ${R.shape}`);return te.BV.runKernel(Q.jQs,{x:R},{paddings:I,mode:b})}}),Lf=(0,j.op)({mod_:function Pf(N,I){let b=(0,F._1)(N,"a","mod"),R=(0,F._1)(I,"b","mod");return[b,R]=(0,ce.makeTypesMatch)(b,R),te.BV.runKernel(Q.Vbg,{a:b,b:R})}}),Vf=(0,j.op)({moments_:function Bf(N,I=null,b=!1){N=(0,F._1)(N,"x","moments");const R=(0,A.EC)(I,N.shape),L=Ha(N,R,b);let H=L.shape;b||(H=(0,Fo.rv)(L.shape,R));const Z=(0,ct.h)((0,Cn.l)((0,nt.p)(N,"float32"),(0,Ve.X)(L,H)));return{mean:L,variance:Ha(Z,R,b)}}}),Uf=(0,j.op)({multiRNNCell_:function va(N,I,b,R){const L=(0,F._1)(I,"data","multiRNNCell"),H=(0,F.sI)(b,"c","multiRNNCell"),Z=(0,F.sI)(R,"h","multiRNNCell");let ne=L;const ve=[];for(let Ye=0;Ye<N.length;Ye++){const At=N[Ye](ne,H[Ye],Z[Ye]);ve.push(At[0]),ve.push(At[1]),ne=At[1]}const Se=[],ze=[];for(let Ye=0;Ye<ve.length;Ye+=2)Se.push(ve[Ye]),ze.push(ve[Ye+1]);return[Se,ze]}}),ki=(0,j.op)({multinomial_:function Wf(N,I,b,R=!1){const L=(0,F._1)(N,"logits","multinomial"),H=L.size,Z=L.rank;if(H<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${H}.`);if(Z>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${Z}`);b=b||Math.random();const ve={logits:1===Z?(0,Ve.X)(L,[1,-1]):L},ze=te.BV.runKernel(Q.NZg,ve,{numSamples:I,seed:b,normalized:R});return 1===Z?(0,Ve.X)(ze,[ze.size]):ze}}),Bo=(0,j.op)({notEqual_:function Cc(N,I){let b=(0,F._1)(N,"a","notEqual","string_or_numeric"),R=(0,F._1)(I,"b","notEqual","string_or_numeric");return[b,R]=(0,ce.makeTypesMatch)(b,R),(0,Br.assertAndGetBroadcastShape)(b.shape,R.shape),te.BV.runKernel(Q.yQU,{a:b,b:R})}});var zf=M(2738);const hl=(0,j.op)({onesLike_:function dl(N){const b={x:(0,F._1)(N,"x","onesLike")};return te.BV.runKernel(Q.qWM,b)}}),fl=(0,j.op)({outerProduct_:function Hf(N,I){const b=(0,F._1)(N,"v1","outerProduct"),R=(0,F._1)(I,"v2","outerProduct");A.hu(1===b.rank&&1===R.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${b.rank} and ${R.rank}.`);const L=(0,Ve.X)(b,[-1,1]),H=(0,Ve.X)(R,[1,-1]);return(0,dn.O)(L,H)}}),Vo=(0,j.op)({pad_:function jf(N,I,b=0){const R=(0,F._1)(N,"x","pad");if(0===R.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return te.BV.runKernel(Q.lyA,{x:R},{paddings:I,constantValue:b})}}),xa=(0,j.op)({pad1d_:function Yd(N,I,b=0){return(0,A.hu)(2===I.length,()=>"Invalid number of paddings. Must be length of 2."),Vo(N,[I],b)}}),Zd=(0,j.op)({pad2d_:function pl(N,I,b=0){return(0,A.hu)(2===I.length&&2===I[0].length&&2===I[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),Vo(N,I,b)}}),ml=(0,j.op)({pad3d_:function Qd(N,I,b=0){return(0,A.hu)(3===I.length&&2===I[0].length&&2===I[1].length&&2===I[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),Vo(N,I,b)}}),Jd=(0,j.op)({pad4d_:function gl(N,I,b=0){return(0,A.hu)(4===I.length&&2===I[0].length&&2===I[1].length&&2===I[2].length&&2===I[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),Vo(N,I,b)}}),yl=(0,j.op)({spaceToBatchND_:function Sc(N,I,b){const R=(0,F._1)(N,"x","spaceToBatchND");return A.hu(R.rank>=1+I.length,()=>`input rank ${R.rank} should be > than [blockShape] ${I.length}`),A.hu(b.length===I.length,()=>`paddings.shape[0] ${b.length} must be equal to [blockShape] ${I.length}`),A.hu(R.shape.reduce((Z,ne,ve)=>ve>0&&ve<=I.length?Z&&(ne+b[ve-1][0]+b[ve-1][1])%I[ve-1]==0:Z,!0),()=>`input spatial dimensions ${R.shape.slice(1)} with paddings ${b.toString()} must be divisible by blockShapes ${I.toString()}`),te.BV.runKernel(Q.TQc,{x:R},{blockShape:I,paddings:b})}}),ms=(0,j.op)({pool_:function bo(N,I,b,R,L,H,Z){null==L&&(L=[1,1]),null==H&&(H=1),0===R&&(R="valid");const ne=(0,F._1)(N,"x","maxPool");let ve=ne,Se=!1;3===ne.rank&&(Se=!0,ve=(0,Ve.X)(ne,[1,ne.shape[0],ne.shape[1],ne.shape[2]])),A.hu(et.jT(H,L),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${H} and dilations '${L}'`);const ze=et.Xw(ve.shape,I,H,L,R),Ye=[ze.dilationHeight,ze.dilationWidth];let At;At="same"===R?function xl(N,I){const R=N.map((Z,ne)=>Z+(Z-1)*(I[ne]-1)).map(Z=>Z-1),L=R.map(Z=>Math.floor(Z/2)),H=R.map((Z,ne)=>Z-L[ne]);return R.map((Z,ne)=>[L[ne],H[ne]])}([ze.filterHeight,ze.filterWidth],Ye):[[0,0],[0,0]];const Qt=1===Ye[0]&&1===Ye[1],[nn,Wn]=function vl(N,I,b){const R=b.map(ze=>ze[0]),L=b.map(ze=>ze[1]),H=N.concat(R,L),Z=I.map((ze,Ye)=>(ze-H[Ye]%ze)%ze),ne=L.map((ze,Ye)=>ze+Z[Ye]),ve=I.map((ze,Ye)=>[R[Ye],ne[Ye]]),Se=I.map((ze,Ye)=>[0,Z[Ye]]);return[ve,Se]}([ze.inHeight,ze.inWidth],Ye,At),xn=Qt?R:"valid",ir=Qt?ve:yl(ve,Ye,nn),ys=("avg"===b?()=>Yt(ir,I,H,xn,Z):()=>xo(ir,I,H,xn,Z))(),Xr=Qt?ys:zn(ys,Ye,Wn);return Se?(0,Ve.X)(Xr,[Xr.shape[1],Xr.shape[2],Xr.shape[3]]):Xr}});var eh=M(1426),Xu=M(2174);const th=(0,j.op)({prod_:function lo(N,I=null,b=!1){let R=(0,F._1)(N,"x","prod");return"bool"===R.dtype&&(R=(0,nt.p)(R,"int32")),te.BV.runKernel(Q.DlI,{x:R},{axis:I,keepDims:b})}}),ja=(0,j.op)({raggedGather_:function bl(N,I,b,R){const L=N.map((ze,Ye)=>(0,F._1)(ze,`tensors${Ye}`,"raggedGather","int32")),H=(0,F._1)(I,"paramsDenseValues","raggedGather"),Z=(0,F._1)(b,"indices","raggedGather","int32"),Se=te.BV.runKernel(Q.dDz,{paramsNestedSplits:L,paramsDenseValues:H,indices:Z},{outputRaggedRank:R});return{outputNestedSplits:Se.slice(0,Se.length-1),outputDenseValues:Se[Se.length-1]}}}),nh=(0,j.op)({raggedTensorToTensor_:function to(N,I,b,R,L){const H=(0,F._1)(N,"shape","raggedTensorToTensor","int32"),Z=(0,F._1)(I,"values","raggedTensorToTensor"),ne=(0,F._1)(b,"defaultValue","raggedTensorToTensor",Z.dtype),ve=R.map((Ye,At)=>(0,F._1)(Ye,`tensors${At}`,"raggedTensorToTensor","int32"));return te.BV.runKernel(Q.BiW,{shape:H,values:Z,defaultValue:ne,rowPartitionTensors:ve},{rowPartitionTypes:L})}}),rh=(0,j.op)({rand_:function Ga(N,I,b){const R=(0,A.NA)(N);let L=null;if(null==b||"float32"===b)L=new Float32Array(R);else if("int32"===b)L=new Int32Array(R);else{if("bool"!==b)throw new Error(`Unknown data type ${b}`);L=new Uint8Array(R)}for(let H=0;H<R;H++)L[H]=I();return te.BV.makeTensor(L,N,b)}});var Uo=M(340);class vu{constructor(I,b,R,L,H){this.mean=I,this.stdDev=b,this.dtype=R,this.nextVal=NaN,this.truncated=L,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const Z=H||Math.random();this.random=Uo.alea(Z.toString())}nextValue(){if(!isNaN(this.nextVal)){const L=this.nextVal;return this.nextVal=NaN,L}let I,b,R=!1;for(;!R;){let L,H,Z;do{L=2*this.random()-1,H=2*this.random()-1,Z=L*L+H*H}while(Z>=1||0===Z);const ne=Math.sqrt(-2*Math.log(Z)/Z);I=this.mean+this.stdDev*L*ne,b=this.mean+this.stdDev*H*ne,(!this.truncated||this.isValidTruncated(I))&&(R=!0)}return(!this.truncated||this.isValidTruncated(b))&&(this.nextVal=this.convertValue(b)),this.convertValue(I)}convertValue(I){return null==this.dtype||"float32"===this.dtype?I:Math.round(I)}isValidTruncated(I){return I<=this.upper&&I>=this.lower}}class Ec{constructor(I,b,R,L){this.alpha=I,this.beta=1/b,this.dtype=R;const H=L||Math.random();this.randu=Uo.alea(H.toString()),this.randn=new vu(0,1,R,!1,this.randu()),this.d=I<1?I+2/3:I-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let I,b,R,L,H,Z;for(;;){do{L=this.randn.nextValue(),Z=1+this.c*L}while(Z<=0);if(Z*=Z*Z,I=L*L,b=1-.331*I*I,R=.5*I+this.d*(1-Z+Math.log(Z)),H=this.randu(),H<b||Math.log(H)<R)break}return Z*=1/this.beta*this.d,this.alpha<1&&(Z*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(Z)}convertValue(I){return"float32"===this.dtype?I:Math.round(I)}}class Vn{constructor(I=0,b=1,R,L){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=I,this.range=b-I,this.dtype=R,null==L&&(L=Math.random()),"number"==typeof L&&(L=L.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${I} - ${b} <= 1 and dtype is not float`);this.random=Uo.alea(L)}convertValue(I){return this.canReturnFloat()?I:Math.round(I)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const uh=(0,j.op)({randomGamma_:function ah(N,I,b=1,R="float32",L){if(null==b&&(b=1),null==R&&(R="float32"),"float32"!==R&&"int32"!==R)throw new Error(`Unsupported data type ${R}`);const H=new Ec(I,b,R,L),Z=(0,mr.f)(N,R);for(let ne=0;ne<Z.values.length;ne++)Z.values[ne]=H.nextValue();return Z.toTensor()}}),or=(0,j.op)({randomNormal_:function Dt(N,I=0,b=1,R,L){if(null!=R&&"bool"===R)throw new Error(`Unsupported data type ${R}`);const H=new vu(I,b,R,!1,L),Z=(0,mr.f)(N,R);for(let ne=0;ne<Z.values.length;ne++)Z.values[ne]=H.nextValue();return Z.toTensor()}}),Qi=(0,j.op)({randomStandardNormal_:function Zi(N,I,b){if(null!=I&&"bool"===I)throw new Error(`Unsupported data type ${I}`);return or(N,0,1,I,b)}}),Ic=(0,j.op)({randomUniform_:function Is(N,I=0,b=1,R="float32",L){const H=(0,mr.f)(N,R),Z=new Vn(I,b,null,L);for(let ne=0;ne<H.values.length;ne++)H.values[ne]=Z.nextValue();return H.toTensor()}});function Ai(N,I,b=1,R="float32"){if(0===b)throw new Error("Cannot have a step of zero");return te.BV.runKernel(Q.e6w,{},{start:N,stop:I,step:b,dtype:R})}var ho=M(5732);const Tc=(0,j.op)({reciprocal_:function Dc(N){const b={x:(0,F._1)(N,"x","reciprocal")};return te.BV.runKernel(Q.$HU,b)}});var Nc=M(4563),Gf=M(5049);const Jr=(0,j.op)({reverse_:function Cl(N,I){const R={x:(0,F._1)(N,"x","reverse")};return te.BV.runKernel(Q.mKl,R,{dims:I})}}),Sl=(0,j.op)({reverse1d_:function Wo(N){const I=(0,F._1)(N,"x","reverse");return A.hu(1===I.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${I.rank}.`),Jr(I,0)}}),k=(0,j.op)({reverse2d_:function ba(N,I){const b=(0,F._1)(N,"x","reverse");return A.hu(2===b.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${b.rank}.`),Jr(b,I)}}),T=(0,j.op)({reverse3d_:function P(N,I){const b=(0,F._1)(N,"x","reverse");return A.hu(3===b.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${b.rank}.`),Jr(b,I)}}),X=(0,j.op)({reverse4d_:function B(N,I){const b=(0,F._1)(N,"x","reverse");return A.hu(4===b.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${b.rank}.`),Jr(b,I)}}),fe=(0,j.op)({round_:function ue(N){const b={x:(0,F._1)(N,"x","round")};return te.BV.runKernel(Q.e07,b)}}),st=(0,j.op)({rsqrt_:function Le(N){const b={x:(0,F._1)(N,"x","rsqrt","float32")};return te.BV.runKernel(Q.bV0,b)}}),Tt=(0,j.op)({selu_:function it(N){const b={x:(0,F._1)(N,"x","selu")};return te.BV.runKernel(Q.oFR,b)}}),ht=(0,j.op)({separableConv2d_:function dt(N,I,b,R,L,H=[1,1],Z="NHWC"){const ne=(0,F._1)(N,"x","separableConv2d"),ve=(0,F._1)(I,"depthwiseFilter","separableConv2d"),Se=(0,F._1)(b,"pointwiseFilter","separableConv2d");let ze=ne,Ye=!1;if(3===ne.rank&&(Ye=!0,ze=(0,Ve.X)(ne,[1,ne.shape[0],ne.shape[1],ne.shape[2]])),"NCHW"===Z)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");A.hu(4===ze.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${ze.rank}.`),A.hu(4===ve.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${ve.rank}.`),A.hu(4===Se.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${ve.rank}.`),A.hu(1===Se.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${Se.shape[0]}.`),A.hu(1===Se.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${Se.shape[1]}.`);const At=ve.shape[2],Qt=ve.shape[3];A.hu(Se.shape[2]===At*Qt,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${At*Qt}, but got ${Se.shape[2]}.`);const nn=ji(ze,ve,R,L,Z,H),xn=Cs(nn,Se,1,"valid",Z);return Ye?(0,Ve.X)(xn,[xn.shape[1],xn.shape[2],xn.shape[3]]):xn}});var Mt=M(5861);function Sn(){return(Sn=(0,Mt.Z)(function*(N,I){const b=(0,F._1)(N,"x","setdiff1d"),R=(0,F._1)(I,"y","setdiff1d");A.hu(b.dtype===R.dtype,()=>`x and y should have the same dtype, but got x (${b.dtype}) and y (${R.dtype}).`),A.hu(1===b.rank,()=>`x should be 1D tensor, but got x (${b.shape}).`),A.hu(1===R.rank,()=>`y should be 1D tensor, but got y (${R.shape}).`);const L=yield b.data(),H=yield R.data(),Z=new Set(H);let ne=0;for(let ze=0;ze<L.length;ze++)Z.has(L[ze])||ne++;const ve=new cs.YD([ne],b.dtype),Se=new cs.YD([ne],"int32");for(let ze=0,Ye=0;ze<L.length;ze++)Z.has(L[ze])||(ve.values[Ye]=L[ze],Se.values[Ye]=ze,Ye++);return[ve.toTensor(),Se.toTensor()]})).apply(this,arguments)}const Pn=function on(N,I){return Sn.apply(this,arguments)},si=(0,j.op)({sign_:function lr(N){const b={x:(0,F._1)(N,"x","sign")};return te.BV.runKernel(Q.i5y,b)}}),rs=(0,j.op)({sin_:function Xt(N){const b={x:(0,F._1)(N,"x","sin","float32")};return te.BV.runKernel(Q.RQH,b)}}),Ri=(0,j.op)({sinh_:function Tn(N){const b={x:(0,F._1)(N,"x","sinh")};return te.BV.runKernel(Q.wYB,b)}}),Ka=(0,j.op)({slice1d_:function xu(N,I,b){const R=(0,F._1)(N,"x","slice1d");return A.hu(1===R.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${R.rank} tensor`),Zn(R,[I],[b])}}),qu=(0,j.op)({slice2d_:function Ji(N,I,b){const R=(0,F._1)(N,"x","slice2d");return A.hu(2===R.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${R.rank} tensor`),Zn(R,I,b)}}),qa=(0,j.op)({slice3d_:function Xa(N,I,b){const R=(0,F._1)(N,"x","slice3d");return A.hu(3===R.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${R.rank} tensor`),Zn(R,I,b)}}),_l=(0,j.op)({slice4d_:function El(N,I,b){const R=(0,F._1)(N,"x","slice4d");return A.hu(4===R.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${R.rank} tensor`),Zn(R,I,b)}}),Kf=(0,j.op)({softmax_:function ch(N,I=-1){const b=(0,F._1)(N,"logits","softmax","float32");if(-1===I&&(I=b.rank-1),I!==b.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${b.rank} and dim was ${I}`);return te.BV.runKernel(Q.Gcp,{logits:b},{dim:I})}}),Ya=(0,j.op)({fft_:function Rg(N){return(0,A.hu)("complex64"===N.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${N.dtype}.`),te.BV.runKernel(Q.vwp,{input:N})}}),Il=(0,j.op)({ifft_:function kc(N){return(0,A.hu)("complex64"===N.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${N.dtype}.`),te.BV.runKernel(Q.Qg5,{input:N})}}),Dl=(0,j.op)({irfft_:function ey(N){const I=N.shape[N.shape.length-1],b=N.size/I;let R;if(I<=2){const L=(0,Ve.X)(N,[b,I]);R=Il(L)}else{const L=[b,2*(I-1)],H=(0,Ve.X)((0,ho.k)(N),[b,I]),Z=(0,Ve.X)((0,ns.a)(N),[b,I]),ne=Jr(Zn(H,[0,1],[b,I-2]),1),ve=(0,un.d)(Jr(Zn(Z,[0,1],[b,I-2]),1),(0,he.i)(-1)),Se=kn([H,ne],1),ze=kn([Z,ve],1),Ye=(0,Ve.X)((0,Ur.P)(Se,ze),[L[0],L[1]]);R=Il(Ye)}if(R=(0,ho.k)(R),3===N.rank&&0!==N.shape[0]){const L=R,H=N.shape[0];R=(0,Ve.X)(R,[H,R.shape[0]/H,R.shape[1]]),L.dispose()}return R}}),Ac=(0,j.op)({split_:function ty(N,I,b=0){const L={x:(0,F._1)(N,"x","split")};return te.BV.runKernel(Q.L8s,L,{numOrSizeSplits:I,axis:b})}}),Xf=(0,j.op)({rfft_:function Og(N,I){(0,A.hu)("float32"===N.dtype,()=>`The dtype for rfft() must be real value but got ${N.dtype}`);let b=N.shape[N.shape.length-1];const R=N.size/b;let L;if(null!=I&&I<b){const nn=N.shape.map(xn=>0),Wn=N.shape.map(xn=>xn);Wn[N.shape.length-1]=I,L=Zn(N,nn,Wn),b=I}else if(null!=I&&I>b){const nn=N.shape.map(Wn=>Wn);nn[N.shape.length-1]=I-b,L=kn([N,ri(nn)],N.shape.length-1),b=I}else L=N;const H=(0,Mo.P)(L),Z=(0,Ve.X)((0,Ur.P)(L,H),[R,b]),ne=Ya(Z),ve=Math.floor(b/2)+1,Se=(0,ho.k)(ne),ze=(0,ns.a)(ne),Ye=Ac(Se,[ve,b-ve],Se.shape.length-1),At=Ac(ze,[ve,b-ve],ze.shape.length-1),Qt=L.shape.slice();return Qt[L.shape.length-1]=ve,(0,Ve.X)((0,Ur.P)(Ye[0],At[0]),Qt)}}),Tl=(0,j.op)({squaredDifference_:function ny(N,I){let b=(0,F._1)(N,"a","squaredDifference"),R=(0,F._1)(I,"b","squaredDifference");return[b,R]=(0,ce.makeTypesMatch)(b,R),(0,Br.assertAndGetBroadcastShape)(b.shape,R.shape),te.BV.runKernel(Q._tC,{a:b,b:R},{})}}),Nl=(0,j.op)({squeeze_:function qf(N,I){const b=(0,F._1)(N,"x","squeeze","string_or_numeric");return(0,Ve.X)(b,(0,A.bp)(b.shape,I).newShape)}}),Yu=(0,j.op)({stack_:function Rc(N,I=0){const b=(0,F.sI)(N,"tensors","stack","string_or_numeric");return A.hu(b.length>=1,()=>"Pass at least one tensor to tf.stack"),b.length>0&&A.hu(I<=b[0].rank,()=>"Axis must be <= rank of the tensor"),te.BV.runKernel(Q.QiL,b,{axis:I})}});var Yf=M(6166);const Mg=(0,j.op)({stridedSlice_:function kl(N,I,b,R,L=0,H=0,Z=0,ne=0,ve=0){const ze={x:(0,F._1)(N,"x","stridedSlice","string_or_numeric")};return te.BV.runKernel(Q.jQk,ze,{begin:I,end:b,strides:R,beginMask:L,endMask:H,ellipsisMask:Z,newAxisMask:ne,shrinkAxisMask:ve})}}),lh=(0,j.op)({tan_:function Al(N){const b={x:(0,F._1)(N,"x","tan","float32")};return te.BV.runKernel(Q.sEM,b)}});var Zu=M(1973),Rl=M(3906);function oi(N,I){(0,A.Cq)(N);const b=(0,F.C)(N,I);if(1!==b.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,Rl.H)(N,null,b,I)}function Qu(N,I,b){if((0,A.Cq)(N),null!=I&&2!==I.length)throw new Error("tensor2d() requires shape to have two numbers");const R=(0,F.C)(N,b);if(2!==R.length&&1!==R.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===R.length&&null==I)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,Rl.H)(N,I,R,b)}var $g=M(3157);function ea(N,I,b){if((0,A.Cq)(N),null!=I&&4!==I.length)throw new Error("tensor4d() requires shape to have four numbers");const R=(0,F.C)(N,b);if(4!==R.length&&1!==R.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===R.length&&null==I)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,Rl.H)(N,I,R,b)}function Fg(N,I,b){if((0,A.Cq)(N),null!=I&&5!==I.length)throw new Error("tensor5d() requires shape to have five numbers");const R=(0,F.C)(N,b);if(5!==R.length&&1!==R.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===R.length&&null==I)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,Rl.H)(N,I,R,b)}function Ol(N,I,b){if((0,A.Cq)(N),null!=I&&6!==I.length)throw new Error("tensor6d() requires shape to have six numbers");const R=(0,F.C)(N,b);if(6!==R.length&&1!==R.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===R.length&&null==I)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return(0,Rl.H)(N,I=I||R,R,b)}const Zf=(0,j.op)({topk_:function dh(N,I=1,b=!0){const R=(0,F._1)(N,"x","topk");if(0===R.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const L=R.shape[R.shape.length-1];if(I<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${I}`);if(I>L)throw new Error(`'k' passed to topk() must be <= the last dimension (${L}) but got ${I}`);const H={x:R},Z={k:I,sorted:b},[ne,ve]=te.BV.runKernel(Q.cWu,H,Z);return{values:ne,indices:ve}}}),fh=(0,j.op)({truncatedNormal_:function hh(N,I=0,b=1,R,L){if(null!=R&&"bool"===R)throw new Error("Unsupported data type $ { dtype }");const H=new vu(I,b,R,!0,L),Z=(0,mr.f)(N,R);for(let ne=0;ne<Z.values.length;ne++)Z.values[ne]=H.nextValue();return Z.toTensor()}}),Qf=(0,j.op)({unique_:function Pg(N,I=0){const b=(0,F._1)(N,"x","unique","string_or_numeric");(0,A.hu)(b.rank>0,()=>"The input tensor must be at least 1D");const R={x:b},L={axis:I},[H,Z]=te.BV.runKernel(Q.kpP,R,L);return{values:H,indices:Z}}}),ep=(0,j.op)({unsortedSegmentSum_:function Jf(N,I,b){const R=(0,F._1)(N,"x","unsortedSegmentSum"),L=(0,F._1)(I,"segmentIds","unsortedSegmentSum","int32");return(0,A.hu)((0,A.GN)(b),()=>"numSegments must be of dtype int"),te.BV.runKernel(Q.Qvg,{x:R,segmentIds:L},{numSegments:b})}}),ph=(0,j.op)({unstack_:function tp(N,I=0){const b=(0,F._1)(N,"x","unstack","string_or_numeric");return A.hu(I>=-b.shape.length&&I<b.shape.length,()=>`Axis = ${I} is not in [-${b.shape.length}, ${b.shape.length})`),te.BV.runKernel(Q.ToN,{value:b},{axis:I})}});function Ml(N,I){return Lo(N,I,"right")}function bu(N,I=!0,b,R){return te.BV.makeVariable(N,I,b,R)}var Lg=M(2842);function $l(){return($l=(0,Mt.Z)(function*(N){const I=(0,F._1)(N,"condition","whereAsync","bool"),b=yield I.data(),R=(0,Lg.Z)(I.shape,b);return N!==I&&I.dispose(),R})).apply(this,arguments)}const wu=function np(N){return $l.apply(this,arguments)};function Fl(){return(Fl=(0,Mt.Z)(function*(N,I,b){const R=(0,F._1)(N,"tensor","boolMask"),L=(0,F._1)(I,"mask","boolMask","bool"),H=b??0,Z=L.rank,ne=R.shape;A.hu(Z>0,()=>"mask cannot be scalar"),A.k5(ne.slice(H,H+Z),L.shape,"mask's shape must match the first K dimensions of tensor's shape,");let ve=1;for(let Wn=H;Wn<H+Z;Wn++)ve*=ne[Wn];const Se=ne.slice(0,H).concat([ve],ne.slice(H+Z)),ze=(0,Ve.X)(R,Se),Ye=(0,Ve.X)(L,[-1]),At=yield wu(Ye),Qt=Nl(At,[1]),nn=Gt(ze,Qt,H);return N!==R&&R.dispose(),I!==L&&L.dispose(),Qt.dispose(),ze.dispose(),Ye.dispose(),At.dispose(),nn})).apply(this,arguments)}const mh=function Bg(N,I,b){return Fl.apply(this,arguments)};var gh=M(9540);const Pl=(0,j.op)({movingAverage_:function rp(N,I,b,R,L=!0){const H=(0,F._1)(N,"v","movingAverage"),Z=(0,F._1)(I,"x","movingAverage"),ne=(0,F._1)(b,"decay","movingAverage");(0,ce.assertTypesMatch)(H,Z),A.hu(A.cO(H.shape,Z.shape),()=>"Shape mismatch in v and x");const ve=(0,he.i)(1),Se=(0,Cn.l)(ve,ne);let ze=(0,un.d)((0,Cn.l)(Z,H),Se);if(L){A.hu(null!=R,()=>"When using zeroDebias: true, step is required.");const Ye=(0,F._1)(R,"step","movingAverage");ze=(0,Dr.h)(ze,(0,Cn.l)(ve,(0,U.s)(ne,Ye)))}return(0,ee.I)(H,ze)}});var Ju=M(2808);const tc=(0,j.op)({scatterND_:function ec(N,I,b){const R=(0,F._1)(N,"indices","scatterND","int32"),L=(0,F._1)(I,"updates","scatterND");return Ju.validateInput(L,R,b),te.BV.runKernel(Q.xQA,{indices:R,updates:L},{shape:b})}}),nc=(0,j.op)({sparseToDense_:function yh(N,I,b,R=0){const L=(0,F._1)(N,"sparseIndices","sparseToDense","int32"),H=(0,F._1)(I,"sparseValues","sparseToDense","string_or_numeric"),Z=(0,F._1)(R,"defaultValue","sparseToDense",H.dtype);return function sp(N,I,b,R){if("int32"!==N.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${N.dtype}.`);if(N.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${N.shape}.`);const L=N.rank>0?N.shape[0]:1,H=N.rank>1?N.shape[1]:1;if(b.length!==H)throw new Error(`outputShape has incorrect number of elements:, ${b.length}, should be: ${H}.`);if(0!==I.rank&&(1!==I.rank||I.size!==L))throw new Error(`sparseValues has incorrect shape ${I.shape}, should be [] or [${L}]`);if(I.dtype!==R.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(L,H,b,Z),te.BV.runKernel(Q.D2d,{sparseIndices:L,sparseValues:H,defaultValue:Z},{outputShape:b})}}),Vg=(0,j.op)({gatherND_:function ry(N,I){const b=(0,F._1)(I,"indices","gatherND","int32"),L={params:(0,F._1)(N,"x","gatherND","string_or_numeric"),indices:b};return te.BV.runKernel(Q.q1x,L)}}),oy=(0,j.op)({dropout_:function sy(N,I,b,R){const L=(0,F._1)(N,"x","dropout");if(A.hu("float32"===L.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${L.dtype} tensor instead.`),A.hu(I>=0&&I<1,()=>`rate must be a float in the range [0, 1), but got ${I}.`),0===I)return N instanceof cs.es?L.clone():L;const H=function An(N,I){if(null==I)return N.shape.slice();if(A.cO(N.shape,I))return I;if(N.shape.length===I.length){const b=[];for(let R=0;R<N.shape.length;R++)b.push(null==I[R]&&null!=N.shape[R]?N.shape[R]:I[R]);return b}return I}(L,b),Z=1-I,ne=(0,Dr.h)(Je((0,ee.I)(Ic(H,0,1,"float32",R),Z)),Z);return(0,un.d)(L,ne)}});function Ug(N){return Math.floor(Math.pow(2,Math.ceil(Math.log(N)/Math.log(2))))}function op(N,I,b){const R=1-N%2,L=new Float32Array(N);for(let H=0;H<N;++H){const Z=2*Math.PI*H/(N+R-1);L[H]=I-b*Math.cos(Z)}return oi(L,"float32")}function ip(){return(ip=(0,Mt.Z)(function*(N,I,b=1){const R=(0,F._1)(N,"predictions","inTopK"),L=(0,F._1)(I,"targets","inTopK");(0,A.hu)(R.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${R.rank}`),(0,A.hu)(R.rank-1===L.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${R.rank} and targets rank ${L.rank}`),(0,A.k5)(R.shape.slice(0,R.shape.length-1),L.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const H=R.shape[R.shape.length-1];(0,A.hu)(b>0&&b<=H,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${H}), but got ${b}`);const Z=yield R.data(),ne=yield L.data(),[ve,Se]=[Z.length/H,H],ze=(0,A.WP)("bool",ve);for(let Ye=0;Ye<ve;Ye++){const At=Ye*Se,Qt=Z.subarray(At,At+Se),nn=[];for(let Wn=0;Wn<Qt.length;Wn++)nn.push({value:Qt[Wn],index:Wn});nn.sort((Wn,xn)=>xn.value-Wn.value),ze[Ye]=0;for(let Wn=0;Wn<b;Wn++)if(nn[Wn].index===ne[Ye]){ze[Ye]=1;break}}return N!==R&&R.dispose(),I!==L&&L.dispose(),(0,Zu.X)(ze,L.shape,"bool")})).apply(this,arguments)}const ay=function iy(N,I){return ip.apply(this,arguments)},uy=(0,j.op)({conv2DBackpropFilter_:function Oc(N,I,b,R,L,H="NHWC",Z){let ne=N;3===N.rank&&(ne=(0,Ve.X)(N,[1,N.shape[0],N.shape[1],N.shape[2]]));let ve=I;3===ve.rank&&(ve=(0,Ve.X)(I,[1,I.shape[0],I.shape[1],I.shape[2]])),A.hu(4===ne.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${ne.shape}.`),A.hu(4===ve.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${ve.shape}.`),A.hu(4===b.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${b}.`);const Se="NHWC"===H?ne.shape[3]:ne.shape[1],ze="NHWC"===H?ve.shape[3]:ve.shape[1];return A.hu(Se===b[2],()=>`Error in conv2dDerFilter: depth of input ${Se}) must match input depth in filter (${b[2]}.`),A.hu(ze===b[3],()=>`Error in conv2dDerFilter: depth of dy (${ze}) must match output depth for filter (${b[3]}).`),et.m("conv2dDerFilter",L,Z),te.BV.runKernel(Q.wUP,{x:ne,dy:ve},{strides:R,pad:L,dataFormat:H,dimRoundingMode:Z,filterShape:b})}});var Oi=M(8868);const vh=(0,j.op)({fusedConv2d_:function Ds({x:N,filter:I,strides:b,pad:R,dataFormat:L="NHWC",dilations:H=[1,1],dimRoundingMode:Z,bias:ne,activation:ve="linear",preluActivationWeights:Se,leakyreluAlpha:ze}){if(!1===(0,Oi.uy)(te.BV.state.gradientDepth,ve=ve||"linear")){A.hu("NHWC"===L,()=>`Error in fused conv2d: got dataFormat of ${L} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let ar=Cs(N,I,b,R,L,H,Z);return null!=ne&&(ar=(0,ee.I)(ar,ne)),(0,Oi.QH)(ar,ve,Se,ze)}const Ye=(0,F._1)(N,"x","conv2d","float32"),At=(0,F._1)(I,"filter","conv2d","float32");let Qt=Ye,nn=!1;3===Ye.rank&&(nn=!0,Qt=(0,Ve.X)(Ye,[1,Ye.shape[0],Ye.shape[1],Ye.shape[2]])),A.hu(4===Qt.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${Qt.rank}.`),A.hu(4===At.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${At.rank}.`),et.m("fused conv2d",R,Z);const Wn="NHWC"===L?Qt.shape[3]:Qt.shape[1];A.hu(At.shape[2]===Wn,()=>`Error in conv2d: depth of input (${Wn}) must match input depth for filter ${At.shape[2]}.`),A.hu(et.jT(b,H),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${b} and dilations '${H}'`);const xn=et.Ix(Qt.shape,At.shape,b,H,R,Z);let ir,gs;if(null!=ne&&(ir=(0,F._1)(ne,"bias","fused conv2d"),[ir]=(0,ce.makeTypesMatch)(ir,Ye),"NHWC"===L?Br.assertAndGetBroadcastShape(xn.outShape,ir.shape):(A.hu(ir.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${ir.shape.length}.`),A.hu(0===ir.shape.length||ir.shape[0]===xn.outChannels||1===ir.shape[0],()=>`Error in fused conv2d: bias shape (${ir.shape}) is not compatible with the number of output channels (${xn.outChannels})`))),null!=Se){const ar=Se.shape;if(A.hu(ar.length<=1||3===ar.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${ar.length}.`),1===ar.length)A.hu(1===ar[0]||ar[0]===xn.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${ar}) is not compatible with the number of output channels (${xn.outChannels}).`);else if(3===ar.length)try{Br.assertAndGetBroadcastShape(ar,xn.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${ar}) is not compatible with the output shape of the conv2d (${xn.outShape}).`)}gs=(0,F._1)(Se,"prelu weights","fused conv2d")}const ys=(ar,ss)=>{A.hu("NHWC"===L,()=>`Error in gradient of fused conv2D: got dataFormat of ${L} but only NHWC is currently supported.`);const[qr,Sr,Wr,es]=ss,ui=(0,Oi.Fr)(ar,Wr,ve);A.hu(et.I0(H),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${H}'`);const ta=[pn(Sr.shape,ui,qr,b,R),uy(Sr,ui,qr.shape,b,R)];if(null!=es){const _u=(0,Oi.pf)(es,ui);ta.push(_u)}return ta},Xr={x:Qt,filter:At,bias:ir,preluActivationWeights:gs},vs={strides:b,pad:R,dataFormat:L,dilations:H,dimRoundingMode:Z,activation:ve,leakyreluAlpha:ze};return null==ne?(0,_n.cb)((ss,qr,Sr)=>{let Wr=te.BV.runKernel(Q._V0,Xr,vs);return Sr([qr,ss,Wr]),nn&&(Wr=(0,Ve.X)(Wr,[Wr.shape[1],Wr.shape[2],Wr.shape[3]])),{value:Wr,gradFunc:ys}})(Qt,At):(0,_n.cb)((ss,qr,Sr,Wr)=>{let es=te.BV.runKernel(Q._V0,Xr,vs);return Wr([qr,ss,es,Sr]),nn&&(es=(0,Ve.X)(es,[es.shape[1],es.shape[2],es.shape[3]])),{value:es,gradFunc:ys}})(Qt,At,ir)}}),Wg=(0,j.op)({depthwiseConv2dNativeBackpropFilter_:function Mc(N,I,b,R,L,H=[1,1],Z){let ne=N;3===N.rank&&(ne=(0,Ve.X)(N,[1,N.shape[0],N.shape[1],N.shape[2]]));let ve=I;return 3===ve.rank&&(ve=(0,Ve.X)(I,[1,I.shape[0],I.shape[1],I.shape[2]])),te.BV.runKernel(Q.sL$,{x:ne,dy:ve},{strides:R,pad:L,dimRoundingMode:Z,dilations:H,filterShape:b})}}),Cu=(0,j.op)({depthwiseConv2dNativeBackpropInput_:function ii(N,I,b,R,L,H=[1,1],Z){let ne=I,ve=!1;3===I.rank&&(ve=!0,ne=(0,Ve.X)(I,[1,I.shape[0],I.shape[1],I.shape[2]]));const Ye=te.BV.runKernel(Q.y7R,{dy:ne,filter:b},{strides:R,pad:L,dimRoundingMode:Z,dilations:H,inputShape:N});return ve?(0,Ve.X)(Ye,[Ye.shape[1],Ye.shape[2],Ye.shape[3]]):Ye}}),Ll=(0,j.op)({fusedDepthwiseConv2d_:function ap({x:N,filter:I,strides:b,pad:R,dataFormat:L="NHWC",dilations:H=[1,1],dimRoundingMode:Z,bias:ne,activation:ve="linear",preluActivationWeights:Se,leakyreluAlpha:ze}){if(!1===(0,Oi.uy)(te.BV.state.gradientDepth,ve)){let vs=ji(N,I,b,R,L,H,Z);return null!=ne&&(vs=(0,ee.I)(vs,ne)),(0,Oi.QH)(vs,ve,Se,ze)}const Ye=(0,F._1)(N,"x","depthwiseConv2d","float32"),At=(0,F._1)(I,"filter","depthwiseConv2d","float32");let Qt=Ye,nn=!1;3===Ye.rank&&(nn=!0,Qt=(0,Ve.X)(Ye,[1,Ye.shape[0],Ye.shape[1],Ye.shape[2]])),A.hu(4===Qt.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${Qt.rank}.`),A.hu(4===At.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${At.rank}.`),A.hu(Qt.shape[3]===At.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${Qt.shape[3]}) must match the inChannels dimension in filter ${At.shape[2]}.`),null==H&&(H=[1,1]),A.hu(et.jT(b,H),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${b} and dilations '${H}'`),et.m("fused depthwiseConv2d",R,Z);const Wn=et.Ix(Qt.shape,At.shape,b,H,R,Z,!0);let xn,ir;null!=ne&&(xn=(0,F._1)(ne,"bias","fused conv2d"),[xn]=(0,ce.makeTypesMatch)(xn,Ye),Br.assertAndGetBroadcastShape(Wn.outShape,xn.shape)),null!=Se&&(ir=(0,F._1)(Se,"prelu weights","fused depthwiseConv2d"));const gs=(vs,ar)=>{A.hu(et.I0(H),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${H}'`);const[ss,qr,Sr,Wr]=ar,es=(0,Oi.Fr)(vs,Sr,ve),ui=Cu(qr.shape,es,ss,b,R,H,Z),ci=Wg(qr,es,ss.shape,b,R,H,Z);return null!=Wr?[ui,ci,(0,Oi.pf)(xn,es)]:[ui,ci]},ys={x:Qt,filter:At,bias:xn,preluActivationWeights:ir},Xr={strides:b,pad:R,dataFormat:L,dilations:H,dimRoundingMode:Z,activation:ve,leakyreluAlpha:ze};return null==ne?(0,_n.cb)((ar,ss,qr)=>{let Sr=te.BV.runKernel(Q.luS,ys,Xr);return qr([ss,ar,Sr]),nn&&(Sr=(0,Ve.X)(Sr,[Sr.shape[1],Sr.shape[2],Sr.shape[3]])),{value:Sr,gradFunc:gs}})(Qt,At):(0,_n.cb)((ar,ss,qr,Sr)=>{let Wr=te.BV.runKernel(Q.luS,ys,Xr);return Sr([ss,ar,Wr,qr]),nn&&(Wr=(0,Ve.X)(Wr,[Wr.shape[1],Wr.shape[2],Wr.shape[3]])),{value:Wr,gradFunc:gs}})(Qt,At,xn)}}),zg=(0,j.op)({fusedMatMul_:function $c({a:N,b:I,transposeA:b=!1,transposeB:R=!1,bias:L,activation:H="linear",preluActivationWeights:Z,leakyreluAlpha:ne=.2}){if(!1===(0,Oi.uy)(te.BV.state.gradientDepth,H)){let es=(0,dn.O)(N,I,b,R);return null!=L&&(es=(0,ee.I)(es,L)),(0,Oi.QH)(es,H,Z,ne)}let ve=(0,F._1)(N,"a","fused matMul"),Se=(0,F._1)(I,"b","fused matMul");[ve,Se]=(0,ce.makeTypesMatch)(ve,Se);const ze=b?ve.shape[ve.rank-2]:ve.shape[ve.rank-1],Ye=R?Se.shape[Se.rank-1]:Se.shape[Se.rank-2],At=b?ve.shape[ve.rank-1]:ve.shape[ve.rank-2],Qt=R?Se.shape[Se.rank-2]:Se.shape[Se.rank-1],nn=ve.shape.slice(0,-2),Wn=Se.shape.slice(0,-2),xn=A.NA(nn),ir=A.NA(Wn);A.hu(ze===Ye,()=>`Error in fused matMul: inner shapes (${ze}) and (${Ye}) of Tensors with shapes ${ve.shape} and ${Se.shape} and transposeA=${b} and transposeB=${R} must match.`);const ys=Br.assertAndGetBroadcastShape(ve.shape.slice(0,-2),Se.shape.slice(0,-2)).concat([At,Qt]),Xr=(0,Ve.X)(ve,b?[xn,ze,At]:[xn,At,ze]),vs=(0,Ve.X)(Se,R?[ir,Qt,Ye]:[ir,Ye,Qt]);let ar,ss;null!=L&&(ar=(0,F._1)(L,"bias","fused matMul"),[ar]=(0,ce.makeTypesMatch)(ar,ve),Br.assertAndGetBroadcastShape(ys,ar.shape)),null!=Z&&(ss=(0,F._1)(Z,"prelu weights","fused matMul"));const qr=(es,ui)=>{const[ci,fo,ta,_u]=ui,na=(0,Oi.Fr)((0,Ve.X)(es,ta.shape),ta,H);let Iu,Ja;return b||R?!b&&R?(Iu=(0,dn.O)(na,fo,!1,!1),Ja=(0,dn.O)(na,ci,!0,!1)):b&&!R?(Iu=(0,dn.O)(fo,na,!1,!0),Ja=(0,dn.O)(ci,na,!1,!1)):(Iu=(0,dn.O)(fo,na,!0,!0),Ja=(0,dn.O)(na,ci,!0,!0)):(Iu=(0,dn.O)(na,fo,!1,!0),Ja=(0,dn.O)(ci,na,!0,!1)),null!=L?[Iu,Ja,(0,Oi.pf)(_u,na)]:[Iu,Ja]},Sr={a:Xr,b:vs,bias:ar,preluActivationWeights:ss},Wr={transposeA:b,transposeB:R,activation:H,leakyreluAlpha:ne};return null==L?(0,_n.cb)((ui,ci,fo)=>{const ta=te.BV.runKernel(Q.usg,Sr,Wr);return fo([ui,ci,ta]),{value:(0,Ve.X)(ta,ys),gradFunc:qr}})(Xr,vs):(0,_n.cb)((ui,ci,fo,ta)=>{const _u=te.BV.runKernel(Q.usg,Sr,Wr);return ta([ui,ci,_u,fo]),{value:(0,Ve.X)(_u,ys),gradFunc:qr}})(Xr,vs,ar)}}),Hg=(0,j.op)({hammingWindow_:function cy(N){return op(N,.54,.46)}}),wo=(0,j.op)({hannWindow_:function ly(N){return op(N,.5,.5)}}),Su=(0,j.op)({frame_:function xh(N,I,b,R=!1,L=0){let H=0;const Z=[];for(;H+I<=N.size;)Z.push(Zn(N,H,I)),H+=b;if(R)for(;H<N.size;){const ne=H+I-N.size,ve=kn([Zn(N,H,I-ne),(0,nr.h)([ne],L)]);Z.push(ve),H+=b}return 0===Z.length?Qu([],[0,I]):(0,Ve.X)(kn(Z),[Z.length,I])}}),up=(0,j.op)({stft_:function dy(N,I,b,R,L=wo){null==R&&(R=Ug(I));const H=Su(N,I,b),Z=(0,un.d)(H,L(I));return Xf(Z,R)}}),Gg=(0,j.op)({cropAndResize_:function jg(N,I,b,R,L="bilinear",H=0){const Z=(0,F._1)(N,"image","cropAndResize"),ne=(0,F._1)(I,"boxes","cropAndResize","float32"),ve=(0,F._1)(b,"boxInd","cropAndResize","int32"),Se=ne.shape[0];return A.hu(4===Z.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${Z.rank}.`),A.hu(2===ne.rank&&4===ne.shape[1],()=>`Error in cropAndResize: boxes must be have size [${Se},4] but had shape ${ne.shape}.`),A.hu(1===ve.rank&&ve.shape[0]===Se,()=>`Error in cropAndResize: boxInd must be have size [${Se}] but had shape ${ne.shape}.`),A.hu(2===R.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${R.length}.`),A.hu(R[0]>=1&&R[1]>=1,()=>`cropSize must be atleast [1,1], but was ${R}`),A.hu("bilinear"===L||"nearest"===L,()=>`method must be bilinear or nearest, but was ${L}`),te.BV.runKernel(Q.VcC,{image:Z,boxes:ne,boxInd:ve},{method:L,extrapolationValue:H,cropSize:R})}}),Xg=(0,j.op)({flipLeftRight_:function Kg(N){const I=(0,F._1)(N,"image","flipLeftRight","float32");return A.hu(4===I.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${I.rank}.`),te.BV.runKernel(Q.Uyb,{image:I},{})}}),Yg=(0,j.op)({grayscaleToRGB_:function qg(N){const I=(0,F._1)(N,"image","grayscaleToRGB"),b=I.rank-1,R=I.shape[b];A.hu(I.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${I.rank}.`),A.hu(1===R,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${R}.`);const L=new Array(I.rank);return L.fill(1,0,b),L[b]=3,oe(I,L)}}),Bl=(0,j.op)({rotateWithOffset_:function bh(N,I,b=0,R=.5){const L=(0,F._1)(N,"image","rotateWithOffset","float32");return A.hu(4===L.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${L.rank}.`),te.BV.runKernel(Q.b9H,{image:L},{radians:I,fillValue:b,center:R})}});function Za(N,I,b,R,L,H){null==R&&(R=.5),null==L&&(L=Number.NEGATIVE_INFINITY),null==H&&(H=0);const Z=N.shape[0];return b=Math.min(b,Z),A.hu(0<=R&&R<=1,()=>`iouThreshold must be in [0, 1], but was '${R}'`),A.hu(2===N.rank,()=>`boxes must be a 2D tensor, but was of rank '${N.rank}'`),A.hu(4===N.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${N.shape[1]}`),A.hu(1===I.rank,()=>"scores must be a 1D tensor"),A.hu(I.shape[0]===Z,()=>`scores has incompatible shape with boxes. Expected ${Z}, but was ${I.shape[0]}`),A.hu(0<=H&&H<=1,()=>`softNmsSigma must be in [0, 1], but was '${H}'`),{maxOutputSize:b,iouThreshold:R,scoreThreshold:L,softNmsSigma:H}}const cp=(0,j.op)({nonMaxSuppression_:function Fc(N,I,b,R=.5,L=Number.NEGATIVE_INFINITY){const H=(0,F._1)(N,"boxes","nonMaxSuppression","float32"),Z=(0,F._1)(I,"scores","nonMaxSuppression","float32"),ne=Za(H,Z,b,R,L);return te.BV.runKernel(Q.uv1,{boxes:H,scores:Z},{maxOutputSize:b=ne.maxOutputSize,iouThreshold:R=ne.iouThreshold,scoreThreshold:L=ne.scoreThreshold})}});var Eu=M(152);function Vl(){return(Vl=(0,Mt.Z)(function*(N,I,b,R=.5,L=Number.NEGATIVE_INFINITY){const H=(0,F._1)(N,"boxes","nonMaxSuppressionAsync"),Z=(0,F._1)(I,"scores","nonMaxSuppressionAsync"),ne=Za(H,Z,b,R,L);b=ne.maxOutputSize,R=ne.iouThreshold,L=ne.scoreThreshold;const ve=yield Promise.all([H.data(),Z.data()]),Se=ve[0],ze=ve[1],{selectedIndices:Ye}=(0,Eu.GP)(Se,ze,b,R,L);return H!==N&&H.dispose(),Z!==I&&Z.dispose(),oi(Ye,"int32")})).apply(this,arguments)}const lp=(0,j.op)({nonMaxSuppressionWithScore_:function Ul(N,I,b,R=.5,L=Number.NEGATIVE_INFINITY,H=0){const Z=(0,F._1)(N,"boxes","nonMaxSuppression"),ne=(0,F._1)(I,"scores","nonMaxSuppression"),ve=Za(Z,ne,b,R,L,H),Ye=te.BV.runKernel(Q.W0H,{boxes:Z,scores:ne},{maxOutputSize:b=ve.maxOutputSize,iouThreshold:R=ve.iouThreshold,scoreThreshold:L=ve.scoreThreshold,softNmsSigma:H=ve.softNmsSigma});return{selectedIndices:Ye[0],selectedScores:Ye[1]}}});function wh(){return(wh=(0,Mt.Z)(function*(N,I,b,R=.5,L=Number.NEGATIVE_INFINITY,H=0){const Z=(0,F._1)(N,"boxes","nonMaxSuppressionAsync"),ne=(0,F._1)(I,"scores","nonMaxSuppressionAsync"),ve=Za(Z,ne,b,R,L,H);b=ve.maxOutputSize,R=ve.iouThreshold,L=ve.scoreThreshold,H=ve.softNmsSigma;const Se=yield Promise.all([Z.data(),ne.data()]),ze=Se[0],Ye=Se[1],{selectedIndices:At,selectedScores:Qt}=(0,Eu.pA)(ze,Ye,b,R,L,H);return Z!==N&&Z.dispose(),ne!==I&&ne.dispose(),{selectedIndices:oi(At,"int32"),selectedScores:oi(Qt)}})).apply(this,arguments)}const Jg=(0,j.op)({nonMaxSuppressionPadded_:function Lc(N,I,b,R=.5,L=Number.NEGATIVE_INFINITY,H=!1){const Z=(0,F._1)(N,"boxes","nonMaxSuppression"),ne=(0,F._1)(I,"scores","nonMaxSuppression"),ve=Za(Z,ne,b,R,L,null),nn=te.BV.runKernel(Q.cye,{boxes:Z,scores:ne},{maxOutputSize:ve.maxOutputSize,iouThreshold:ve.iouThreshold,scoreThreshold:ve.scoreThreshold,padToMaxOutputSize:H});return{selectedIndices:nn[0],validOutputs:nn[1]}}});function Wl(){return(Wl=(0,Mt.Z)(function*(N,I,b,R=.5,L=Number.NEGATIVE_INFINITY,H=!1){const Z=(0,F._1)(N,"boxes","nonMaxSuppressionAsync"),ne=(0,F._1)(I,"scores","nonMaxSuppressionAsync"),ve=Za(Z,ne,b,R,L,null),Se=ve.maxOutputSize,ze=ve.iouThreshold,Ye=ve.scoreThreshold,[At,Qt]=yield Promise.all([Z.data(),ne.data()]),{selectedIndices:nn,validOutputs:Wn}=(0,Eu.qP)(At,Qt,Se,ze,Ye,H);return Z!==N&&Z.dispose(),ne!==I&&ne.dispose(),{selectedIndices:oi(nn,"int32"),validOutputs:(0,he.i)(Wn,"int32")}})).apply(this,arguments)}const t1=(0,j.op)({resizeBilinear_:function fy(N,I,b=!1,R=!1){const L=(0,F._1)(N,"images","resizeBilinear");A.hu(3===L.rank||4===L.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${L.rank}.`),A.hu(2===I.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${I}.`),A.hu(!1===R||!1===b,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let H=L,Z=!1;3===L.rank&&(Z=!0,H=(0,Ve.X)(L,[1,L.shape[0],L.shape[1],L.shape[2]]));const[]=I,Se=te.BV.runKernel(Q._Yw,{images:H},{alignCorners:b,halfPixelCenters:R,size:I});return Z?(0,Ve.X)(Se,[Se.shape[1],Se.shape[2],Se.shape[3]]):Se}}),r1=(0,j.op)({resizeNearestNeighbor_:function n1(N,I,b=!1,R=!1){const L=(0,F._1)(N,"images","resizeNearestNeighbor");A.hu(3===L.rank||4===L.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${L.rank}.`),A.hu(2===I.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${I}.`),A.hu("float32"===L.dtype||"int32"===L.dtype,()=>"`images` must have `int32` or `float32` as dtype"),A.hu(!1===R||!1===b,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let H=L,Z=!1;3===L.rank&&(Z=!0,H=(0,Ve.X)(L,[1,L.shape[0],L.shape[1],L.shape[2]]));const[]=I,Se=te.BV.runKernel(Q.dpD,{images:H},{alignCorners:b,halfPixelCenters:R,size:I});return Z?(0,Ve.X)(Se,[Se.shape[1],Se.shape[2],Se.shape[3]]):Se}}),s1=(0,j.op)({threshold_:function zl(N,I="binary",b=!1,R=.5){const L=(0,F._1)(N,"image","threshold"),ve=L.shape[0]*L.shape[1];let ze,Ye,At,Qt,Se=(0,un.d)(oi([R]),255);if(A.hu(3===L.rank,()=>`Error in threshold: image must be rank 3,but got rank ${L.rank}.`),A.hu(3===L.shape[2]||1===L.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${L.shape[2]}.`),A.hu("int32"===L.dtype||"float32"===L.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${L.dtype}.`),A.hu("otsu"===I||"binary"===I,()=>`Method must be binary or otsu, but was ${I}`),3===L.shape[2]){[ze,Ye,At]=Ac(L,[1,1,1],-1);const xn=(0,un.d)(ze,.2989),ir=(0,un.d)(Ye,.587),gs=(0,un.d)(At,.114);Qt=(0,ee.I)((0,ee.I)(xn,ir),gs)}else Qt=N;"otsu"===I&&(Se=function dp(N,I){let H,Z,ne,ve,Se,ze,b=oi([-1]),R=oi([0]),L=oi([0]);for(let Ye=0;Ye<N.size-1;Ye++){H=Zn(N,0,Ye+1),Z=Zn(N,Ye+1),Se=(0,Dr.h)((0,je.S)(H),I),ze=(0,Dr.h)((0,je.S)(Z),I);const At=(0,je.S)((0,un.d)(H,Ai(0,H.size)));ne=(0,Dr.h)(At,(0,je.S)(H));const Qt=(0,nr.h)(Z.shape,H.size),nn=(0,ee.I)(Ai(0,Z.size),Qt),Wn=(0,un.d)(Z,nn);ve=(0,Dr.h)((0,je.S)(Wn),(0,je.S)(Z));const xn=(0,Cn.l)(ne,ve),ir=(0,Cn.l)(ne,ve),gs=(0,un.d)(Se,ze);L=(0,un.d)((0,un.d)(gs,xn),ir);const ys=ln(L,R);R=Ss(ys,L,R),b=Ss(ys,oi([Ye]),b)}return b}(is((0,nt.p)(fe(Qt),"int32"),(0,Zu.X)([]),256),ve));const nn=b?Ms(Qt,Se):ln(Qt,Se);return(0,nt.p)((0,un.d)(nn,255),"int32")}}),py=(0,j.op)({transform_:function hp(N,I,b="nearest",R="constant",L=0,H){const Z=(0,F._1)(N,"image","transform","float32"),ne=(0,F._1)(I,"transforms","transform","float32");return A.hu(4===Z.rank,()=>`Error in transform: image must be rank 4,but got rank ${Z.rank}.`),A.hu(2===ne.rank&&(ne.shape[0]===Z.shape[0]||1===ne.shape[0])&&8===ne.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),A.hu(null==H||2===H.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${H}.`),te.BV.runKernel(Q.wx7,{image:Z,transforms:ne},{interpolation:b,fillMode:R,fillValue:L,outputShape:H})}}),my=(0,j.op)({bandPart_:function fp(N,I,b){(0,A.hu)(I%1==0,()=>`bandPart(): numLower must be an integer, got ${I}.`),(0,A.hu)(b%1==0,()=>`bandPart(): numUpper must be an integer, got ${b}.`);const R=(0,F._1)(N,"a","bandPart");(0,A.hu)(R.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${R.rank}.`);const L=R.shape,[H,Z]=R.shape.slice(-2);if(!(I<=H))throw new Error(`bandPart(): numLower (${I}) must not be greater than the number of rows (${H}).`);if(!(b<=Z))throw new Error(`bandPart(): numUpper (${b}) must not be greater than the number of columns (${Z}).`);I<0&&(I=H),b<0&&(b=Z);const ne=(0,Ve.X)(Ai(0,H,1,"int32"),[-1,1]),ve=Ai(0,Z,1,"int32"),Se=(0,Cn.l)(ne,ve),ze=yu(Ms(Se,(0,he.i)(+I,"int32")),zs(Se,(0,he.i)(-b,"int32"))),Ye=ri([H,Z],R.dtype);return(0,Ve.X)(Yu(ph((0,Ve.X)(R,[-1,H,Z])).map(At=>Ss(ze,At,Ye))),L)}}),i1=(0,j.op)({gramSchmidt_:function o1(N){let I;if(Array.isArray(N)){I=!1,(0,A.hu)(null!=N&&N.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const L=N[0].shape[0];for(let H=1;H<N.length;++H)(0,A.hu)(N[H].shape[0]===L,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${N[H].shape[0]} vs. ${L})`)}else I=!0,N=Ac(N,N.shape[0],0).map(L=>Nl(L,[0]));(0,A.hu)(N.length<=N[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${N.length}) exceeds number of dimensions (${N[0].shape[0]}).`);const b=[],R=N;for(let L=0;L<N.length;++L)b.push(te.BV.tidy(()=>{let H=R[L];if(L>0)for(let Z=0;Z<L;++Z){const ne=(0,un.d)((0,je.S)((0,un.d)(b[Z],H)),b[Z]);H=(0,Cn.l)(H,ne)}return(0,Dr.h)(H,Lt(H,"euclidean"))}));return I?Yu(b,0):b}});var Ch=M(9370);function a1(N,I=!1){return te.BV.tidy(()=>{(0,A.hu)(2===N.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${N.shape.length}D Tensor.`);const b=N.shape[0],R=N.shape[1];let L=ut(b),H=(0,Mn.d)(N);const Z=Qu([[1]],[1,1]);let ne=(0,Mn.d)(Z);const ve=b>=R?R:b;for(let Se=0;Se<ve;++Se){const ze=H,Ye=ne,At=L;[ne,H,L]=te.BV.tidy(()=>{const Qt=Zn(H,[Se,Se],[b-Se,1]),nn=Lt(Qt),Wn=Zn(H,[Se,Se],[1,1]),xn=Ss(ln(Wn,0),Qu([[-1]]),Qu([[1]])),ir=(0,Cn.l)(Wn,(0,un.d)(xn,nn)),gs=(0,Dr.h)(Qt,ir);ne=1===gs.shape[0]?(0,Mn.d)(Z):kn([Z,Zn(gs,[1,0],[gs.shape[0]-1,gs.shape[1]])],0);const ys=(0,Cr.W)((0,Dr.h)((0,dn.O)(xn,ir),nn)),Xr=Zn(H,[Se,0],[b-Se,R]),vs=(0,un.d)(ys,ne),ar=(0,gh.p)(ne);if(0===Se)H=(0,Cn.l)(Xr,(0,dn.O)(vs,(0,dn.O)(ar,Xr)));else{const Sr=(0,Cn.l)(Xr,(0,dn.O)(vs,(0,dn.O)(ar,Xr)));H=kn([Zn(H,[0,0],[Se,R]),Sr],0)}const ss=(0,gh.p)(vs),qr=Zn(L,[0,Se],[b,L.shape[1]-Se]);if(0===Se)L=(0,Cn.l)(qr,(0,dn.O)((0,dn.O)(qr,ne),ss));else{const Sr=(0,Cn.l)(qr,(0,dn.O)((0,dn.O)(qr,ne),ss));L=kn([Zn(L,[0,0],[b,Se]),Sr],1)}return[ne,H,L]}),(0,Ch.B9)([ze,Ye,At])}return!I&&b>R&&(L=Zn(L,[0,0],[b,R]),H=Zn(H,[0,0],[R,R])),[L,H]})}const Sh=(0,j.op)({qr_:function gy(N,I=!1){if((0,A.hu)(N.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${N.rank}`),2===N.rank)return a1(N,I);{const b=N.shape.slice(0,N.shape.length-2).reduce((ve,Se)=>ve*Se),R=ph((0,Ve.X)(N,[b,N.shape[N.shape.length-2],N.shape[N.shape.length-1]]),0),L=[],H=[];return R.forEach(ve=>{const[Se,ze]=a1(ve,I);L.push(Se),H.push(ze)}),[(0,Ve.X)(Yu(L,0),N.shape),(0,Ve.X)(Yu(H,0),N.shape)]}}});var ai=M(4761);const Qa=(0,j.op)({computeWeightedLoss_:function yy(N,I,b=ai.I.SUM_BY_NONZERO_WEIGHTS){const R=(0,F._1)(N,"losses","computeWeightedLoss");let L=null;null!=I&&(L=(0,F._1)(I,"weights","computeWeightedLoss"));const H=null==L?R:(0,un.d)(R,L);if(b===ai.I.NONE)return H;if(b===ai.I.SUM)return(0,je.S)(H);if(b===ai.I.MEAN){if(null==L)return Ha(H);{const Z=R.size/L.size,ne=(0,Dr.h)((0,je.S)(H),(0,je.S)(L));return Z>1?(0,Dr.h)(ne,(0,he.i)(Z)):ne}}if(b===ai.I.SUM_BY_NONZERO_WEIGHTS){if(null==L)return(0,Dr.h)((0,je.S)(H),(0,he.i)(R.size));{const Z=(0,un.d)(L,co(R.shape)),ne=(0,nt.p)((0,je.S)(Bo(Z,(0,he.i)(0))),"float32");return(0,Dr.h)((0,je.S)(H),ne)}}throw Error(`Unknown reduction: ${b}`)}}),xy=(0,j.op)({absoluteDifference_:function vy(N,I,b,R=ai.I.SUM_BY_NONZERO_WEIGHTS){const L=(0,F._1)(N,"labels","absoluteDifference"),H=(0,F._1)(I,"predictions","absoluteDifference");let Z=null;null!=b&&(Z=(0,F._1)(b,"weights","absoluteDifference")),(0,A.k5)(L.shape,H.shape,"Error in absoluteDifference: ");const ne=(0,we.W)((0,Cn.l)(L,H));return Qa(ne,Z,R)}}),pp=(0,j.op)({cosineDistance_:function u1(N,I,b,R,L=ai.I.SUM_BY_NONZERO_WEIGHTS){const H=(0,F._1)(N,"labels","cosineDistance"),Z=(0,F._1)(I,"predictions","cosineDistance");let ne=null;null!=R&&(ne=(0,F._1)(R,"weights","cosineDistance")),(0,A.k5)(H.shape,Z.shape,"Error in cosineDistance: ");const ve=(0,he.i)(1),Se=(0,Cn.l)(ve,(0,je.S)((0,un.d)(H,Z),b,!0));return Qa(Se,ne,L)}}),mp=(0,j.op)({hingeLoss_:function Eh(N,I,b,R=ai.I.SUM_BY_NONZERO_WEIGHTS){let L=(0,F._1)(N,"labels","hingeLoss");const H=(0,F._1)(I,"predictions","hingeLoss");let Z=null;null!=b&&(Z=(0,F._1)(b,"weights","hingeLoss")),(0,A.k5)(L.shape,H.shape,"Error in hingeLoss: ");const ne=(0,he.i)(1);L=(0,Cn.l)((0,un.d)((0,he.i)(2),L),ne);const ve=(0,Nc.U)((0,Cn.l)(ne,(0,un.d)(L,H)));return Qa(ve,Z,R)}}),yp=(0,j.op)({huberLoss_:function gp(N,I,b,R=1,L=ai.I.SUM_BY_NONZERO_WEIGHTS){const H=(0,F._1)(N,"labels","huberLoss"),Z=(0,F._1)(I,"predictions","huberLoss");let ne=null;null!=b&&(ne=(0,F._1)(b,"weights","huberLoss")),(0,A.k5)(H.shape,Z.shape,"Error in huberLoss: ");const ve=(0,he.i)(R),Se=(0,we.W)((0,Cn.l)(Z,H)),ze=Ni(Se,ve),Ye=(0,Cn.l)(Se,ze),At=(0,ee.I)((0,un.d)((0,he.i)(.5),(0,ct.h)(ze)),(0,un.d)(ve,Ye));return Qa(At,ne,L)}}),c1=(0,j.op)({logLoss_:function Co(N,I,b,R=1e-7,L=ai.I.SUM_BY_NONZERO_WEIGHTS){const H=(0,F._1)(N,"labels","logLoss"),Z=(0,F._1)(I,"predictions","logLoss");let ne=null;null!=b&&(ne=(0,F._1)(b,"weights","logLoss")),(0,A.k5)(H.shape,Z.shape,"Error in logLoss: ");const ve=(0,he.i)(1),Se=(0,he.i)(R),ze=(0,Cr.W)((0,un.d)(H,Xi((0,ee.I)(Z,Se)))),Ye=(0,un.d)((0,Cn.l)(ve,H),Xi((0,ee.I)((0,Cn.l)(ve,Z),Se))),At=(0,Cn.l)(ze,Ye);return Qa(At,ne,L)}}),d1=(0,j.op)({meanSquaredError_:function l1(N,I,b,R=ai.I.SUM_BY_NONZERO_WEIGHTS){const L=(0,F._1)(N,"labels","meanSquaredError"),H=(0,F._1)(I,"predictions","meanSquaredError");let Z=null;null!=b&&(Z=(0,F._1)(b,"weights","meanSquaredError")),(0,A.k5)(L.shape,H.shape,"Error in meanSquaredError: ");const ne=Tl(L,H);return Qa(ne,Z,R)}}),h1=(0,j.op)({sigmoidCrossEntropy_:function _h(N,I,b,R=0,L=ai.I.SUM_BY_NONZERO_WEIGHTS){let H=(0,F._1)(N,"multiClassLabels","sigmoidCrossEntropy");const Z=(0,F._1)(I,"logits","sigmoidCrossEntropy");let ne=null;if(null!=b&&(ne=(0,F._1)(b,"weights","sigmoidCrossEntropy")),(0,A.k5)(H.shape,Z.shape,"Error in sigmoidCrossEntropy: "),R>0){const Se=(0,he.i)(R),ze=(0,he.i)(1),Ye=(0,he.i)(.5);H=(0,ee.I)((0,un.d)(H,(0,Cn.l)(ze,Se)),(0,un.d)(Ye,Se))}const ve=function vp(N,I){const b=(0,F._1)(N,"labels","sigmoidCrossEntropyWithLogits"),R=(0,F._1)(I,"logits","sigmoidCrossEntropyWithLogits");(0,A.k5)(b.shape,R.shape,"Error in sigmoidCrossEntropyWithLogits: ");const L=(0,Nc.U)(R),H=(0,un.d)(R,b),Z=Jt(p((0,Cr.W)((0,we.W)(R))));return(0,ee.I)((0,Cn.l)(L,H),Z)}(H,Z);return Qa(ve,ne,L)}}),xp=(0,j.op)({softmaxCrossEntropy_:function p1(N,I,b,R=0,L=ai.I.SUM_BY_NONZERO_WEIGHTS){let H=(0,F._1)(N,"onehotLabels","softmaxCrossEntropy");const Z=(0,F._1)(I,"logits","softmaxCrossEntropy");let ne=null;if(null!=b&&(ne=(0,F._1)(b,"weights","softmaxCrossEntropy")),(0,A.k5)(H.shape,Z.shape,"Error in softmaxCrossEntropy: "),R>0){const Se=(0,he.i)(R),ze=(0,he.i)(1),Ye=(0,he.i)(H.shape[1]);H=(0,ee.I)((0,un.d)(H,(0,Cn.l)(ze,Se)),(0,Dr.h)(Se,Ye))}const ve=function f1(N,I,b=-1){if(-1===b&&(b=I.rank-1),b!==I.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${I.rank} and dim was ${b}`);return(0,_n.cb)((L,H,Z)=>{const ve=mu(H,[b],!0),Se=(0,Cn.l)((0,nt.p)(H,"float32"),ve);Z([L,Se]);const ze=(0,Cr.W)((0,un.d)(Se,L));return{value:(0,je.S)(ze,[b]),gradFunc:(Qt,nn)=>{const[Wn,xn]=nn,ir=(0,Fo.rv)(Qt.shape,[b]);return[(0,un.d)((0,Ve.X)(Qt,ir),(0,Cn.l)((0,nt.p)(Wn,"float32"),p(xn))),(0,un.d)((0,Ve.X)(Qt,ir),(0,Cn.l)(p(xn),(0,nt.p)(Wn,"float32")))]}}})(N,I)}(H,Z);return Qa(ve,ne,L)}}),g1=(0,j.op)({sparseFillEmptyRows_:function m1(N,I,b,R){const L=(0,F._1)(N,"indices","sparseFillEmptyRows","int32"),H=(0,F._1)(I,"values","sparseFillEmptyRows"),Z=(0,F._1)(b,"denseShape","sparseFillEmptyRows","int32"),ne=(0,F._1)(R,"defaultValue","sparseFillEmptyRows",H.dtype);if(2!==L.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${L.shape}`);if(1!==H.rank)throw new Error(`Values should be Tensor1D but received shape ${H.shape}`);if(1!==Z.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${Z.shape}`);if(0!==ne.rank)throw new Error(`Default value should be a scalar but received shape ${ne.shape}`);const Se=te.BV.runKernel(Q.O3z,{indices:L,values:H,denseShape:Z,defaultValue:ne});return{outputIndices:Se[0],outputValues:Se[1],emptyRowIndicator:Se[2],reverseIndexMap:Se[3]}}}),Ih=(0,j.op)({sparseReshape_:function So(N,I,b){const R=(0,F._1)(N,"inputIndices","sparseReshape","int32"),L=(0,F._1)(I,"inputShape","sparseReshape","int32"),H=(0,F._1)(b,"newShape","sparseReshape","int32");if(2!==R.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${R.shape}`);if(1!==L.rank)throw new Error(`Input shape should be Tensor1D but received shape ${L.shape}`);if(1!==H.rank)throw new Error(`New shape should be Tensor1D but received shape ${H.shape}`);const ne=te.BV.runKernel(Q.nhH,{inputIndices:R,inputShape:L,newShape:H});return{outputIndices:ne[0],outputShape:ne[1]}}}),Dh=(0,j.op)({sparseSegmentMean_:function bp(N,I,b){const R=(0,F._1)(N,"data","sparseSegmentMean"),L=(0,F._1)(I,"indices","sparseSegmentMean","int32"),H=(0,F._1)(b,"segmentIds","sparseSegmentMean","int32");if(R.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==L.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${L.shape}`);if(1!==H.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${H.shape}`);return te.BV.runKernel(Q.w3H,{data:R,indices:L,segmentIds:H})}}),Bc=(0,j.op)({sparseSegmentSum_:function no(N,I,b){const R=(0,F._1)(N,"data","sparseSegmentSum"),L=(0,F._1)(I,"indices","sparseSegmentSum","int32"),H=(0,F._1)(b,"segmentIds","sparseSegmentSum","int32");if(R.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==L.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${L.shape}`);if(1!==H.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${H.shape}`);return te.BV.runKernel(Q.ZjV,{data:R,indices:L,segmentIds:H})}}),Cp=(0,j.op)({stringNGrams_:function wp(N,I,b,R,L,H,Z,ne){const ve=(0,F._1)(N,"data","stringNGrams","string");if("string"!==ve.dtype)throw new Error("Data must be of datatype string");if(1!==ve.shape.length)throw new Error(`Data must be a vector, saw: ${ve.shape}`);const Se=(0,F._1)(I,"dataSplits","stringNGrams");if("int32"!==Se.dtype)throw new Error("Data splits must be of datatype int32");const At=te.BV.runKernel(Q._JP,{data:ve,dataSplits:Se},{separator:b,nGramWidths:R,leftPad:L,rightPad:H,padWidth:Z,preserveShortSequences:ne});return{nGrams:At[0],nGramsSplits:At[1]}}}),Sp=(0,j.op)({stringSplit_:function y1(N,I,b=!0){const R=(0,F._1)(N,"input","stringSplit","string"),L=(0,F._1)(I,"delimiter","stringSplit","string");if(1!==R.rank)throw new Error(`Input should be Tensor1D but received shape ${R.shape}`);if(0!==L.rank)throw new Error(`Delimiter should be a scalar but received shape ${L.shape}`);const ne=te.BV.runKernel(Q.s1s,{input:R,delimiter:L},{skipEmpty:b});return{indices:ne[0],values:ne[1],shape:ne[2]}}}),Ep=(0,j.op)({stringToHashBucketFast_:function v1(N,I){const b=(0,F._1)(N,"input","stringToHashBucketFast","string"),R={numBuckets:I};if(I<=0)throw new Error("Number of buckets must be at least 1");return te.BV.runKernel(Q.XkS,{input:b},R)}}),x1={fft:Ya,ifft:Il,rfft:Xf,irfft:Dl},_p={hammingWindow:Hg,hannWindow:wo,frame:Su,stft:up},b1={flipLeftRight:Xg,grayscaleToRGB:Yg,resizeNearestNeighbor:r1,resizeBilinear:t1,rotateWithOffset:Bl,cropAndResize:Gg,nonMaxSuppression:cp,nonMaxSuppressionAsync:function Zg(N,I,b){return Vl.apply(this,arguments)},nonMaxSuppressionWithScore:lp,nonMaxSuppressionWithScoreAsync:function Qg(N,I,b){return wh.apply(this,arguments)},nonMaxSuppressionPadded:Jg,nonMaxSuppressionPaddedAsync:function hy(N,I,b){return Wl.apply(this,arguments)},threshold:s1,transform:py},w1={bandPart:my,gramSchmidt:i1,qr:Sh},Th={absoluteDifference:xy,computeWeightedLoss:Qa,cosineDistance:pp,hingeLoss:mp,huberLoss:yp,logLoss:c1,meanSquaredError:d1,sigmoidCrossEntropy:h1,softmaxCrossEntropy:xp},Nh={sparseFillEmptyRows:g1,sparseReshape:Ih,sparseSegmentMean:Dh,sparseSegmentSum:Bc},C1={stringNGrams:Cp,stringSplit:Sp,stringToHashBucketFast:Ep}},9043:(gt,Xe,M)=>{"use strict";M.d(Xe,{s:()=>Ie});var _e=M(3738),we=M(1070),te=M(7904),Q=M(9608);const Ie=(0,M(6721).op)({pow_:function j(me,Y){let le=(0,Q._1)(me,"base","pow"),ee=(0,Q._1)(Y,"exp","pow");return[le,ee]=(0,te.makeTypesMatch)(le,ee),_e.BV.runKernel(we.pe_,{a:le,b:ee})}})},1426:(gt,Xe,M)=>{"use strict";M.d(Xe,{A:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({prelu_:function F(Ie,me){const Y=(0,te._1)(Ie,"x","prelu"),le=(0,te._1)(me,"alpha","prelu");return _e.BV.runKernel(we.o0g,{x:Y,alpha:le})}})},2174:(gt,Xe,M)=>{"use strict";function _e(we,te=!1){console.log(we.toString(te))}M.d(Xe,{S:()=>_e})},5732:(gt,Xe,M)=>{"use strict";M.d(Xe,{k:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({real_:function F(Ie){const Y={input:(0,te._1)(Ie,"input","real")};return _e.BV.runKernel(we.xJR,Y)}})},4563:(gt,Xe,M)=>{"use strict";M.d(Xe,{U:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({relu_:function F(Ie){const Y={x:(0,te._1)(Ie,"x","relu")};return _e.BV.runKernel(we.qkr,Y)}})},5049:(gt,Xe,M)=>{"use strict";M.d(Xe,{b:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({relu6_:function F(Ie){const Y={x:(0,te._1)(Ie,"x","relu6")};return _e.BV.runKernel(we.SbG,Y)}})},9416:(gt,Xe,M)=>{"use strict";M.d(Xe,{X:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({reshape_:function F(Ie,me){const le={x:(0,te._1)(Ie,"x","reshape","string_or_numeric")};return _e.BV.runKernel(we.HZH,le,{shape:me})}})},316:(gt,Xe,M)=>{"use strict";M.d(Xe,{i:()=>te});var _e=M(1396),we=M(3906);function te(Q,F){if(((0,_e.fU)(Q)&&"string"!==F||Array.isArray(Q))&&"complex64"!==F)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===F&&(0,_e.fU)(Q)&&!(Q instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,we.H)(Q,[],[],F)}},2808:(gt,Xe,M)=>{"use strict";M.r(Xe),M.d(Xe,{calculateShapes:()=>Q,validateInput:()=>te,validateUpdateShape:()=>we});var _e=M(1396);function we(F,j,Ie){const me=j.rank>1?j.shape[j.rank-1]:1,Y=j.rank>1?j.rank-1:1,le=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${Ie.shape}, indices.shape: ${j.shape}, shape: ${F}, sliceDim: ${me}, and batchDim: ${Y}.`;if(Ie.rank<Y)throw new Error(le+` update.rank < ${Y}. `);if(F.length<me+(Ie.rank-Y))throw new Error(le+` Output shape length < ${me+(Ie.rank-Y)}`);if(Ie.rank!==Y+F.length-me)throw new Error(le+" update.rank != "+(Y+F.length-me));for(let ee=0;ee<Y;++ee)if(Ie.shape[ee]!==j.shape[ee])throw new Error(le+` updates.shape[${ee}] (${Ie.shape[ee]}) != indices.shape[${ee}] (${j.shape[ee]}).`);for(let ee=0;ee<Ie.rank-Y;++ee)if(Ie.shape[ee+Y]!==F[ee+me])throw new Error(le+` updates.shape[${ee+Y}] (${Ie.shape[ee+Y]}) != shape[${ee+Y}] (${F[ee+Y]})`)}function te(F,j,Ie){if(j.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${j.rank}.`);if(F.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${F.rank}.`);if("int32"!==j.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${j.dtype}`);if(Ie.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${Ie}`);if(0===Ie.length){if(0===j.size)throw new Error(`Indices specified for empty output. indices shape: ${j.shape}`);if(0===F.size)throw new Error(`Updates specified for empty output. updates shape: ${F.shape}`)}we(Ie,j,F)}function Q(F,j,Ie){const me=j.shape.length,Y=me>1?j.shape[me-1]:1,le=Ie.length;let ee=1;for(let Ze=Y;Ze<le;++Ze)ee*=Ie[Ze];const A=Y<1?1:Y;return{sliceRank:Y,numUpdates:(0,_e.NA)(j.shape)/A,sliceSize:ee,strides:[...(0,_e.e3)(Ie.slice(0,Y)),1],outputSize:(0,_e.NA)(Ie)}}},6713:(gt,Xe,M)=>{"use strict";M.d(Xe,{X:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({sigmoid_:function F(Ie){const Y={x:(0,te._1)(Ie,"x","sigmoid","float32")};return _e.BV.runKernel(we.a5O,Y)}})},5562:(gt,Xe,M)=>{"use strict";M.d(Xe,{_:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({sqrt_:function F(Ie){const Y={x:(0,te._1)(Ie,"x","sqrt","float32")};return _e.BV.runKernel(we.FKq,Y)}})},4164:(gt,Xe,M)=>{"use strict";M.d(Xe,{h:()=>F});var _e=M(3738),we=M(9608);const F=(0,M(6721).op)({square_:function Q(j){const Ie=(0,we._1)(j,"x","square");return _e.BV.runKernel("Square",{x:Ie},{})}})},6166:(gt,Xe,M)=>{"use strict";M.d(Xe,{N:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({step_:function F(Ie,me=0){const le={x:(0,te._1)(Ie,"x","step")};return _e.BV.runKernel(we.h8e,le,{alpha:me})}})},8578:(gt,Xe,M)=>{"use strict";M.d(Xe,{l:()=>Ie});var _e=M(3738),we=M(1070),te=M(7904),Q=M(9608);const Ie=(0,M(6721).op)({sub_:function j(me,Y){let le=(0,Q._1)(me,"a","sub"),ee=(0,Q._1)(Y,"b","sub");return[le,ee]=(0,te.makeTypesMatch)(le,ee),_e.BV.runKernel(we.Tr8,{a:le,b:ee})}})},5214:(gt,Xe,M)=>{"use strict";M.d(Xe,{S:()=>Ie});var _e=M(3738),we=M(1070),te=M(9608),Q=M(9734);const Ie=(0,M(6721).op)({sum_:function j(me,Y=null,le=!1){let ee=(0,te._1)(me,"x","sum");return"bool"===ee.dtype&&(ee=(0,Q.p)(ee,"int32")),_e.BV.runKernel(we.GBy,{x:ee},{axis:Y,keepDims:le})}})},1973:(gt,Xe,M)=>{"use strict";M.d(Xe,{X:()=>te});var _e=M(9608),we=M(3906);function te(Q,F,j){const Ie=(0,_e.C)(Q,j);return(0,we.H)(Q,F,Ie,j)}},3157:(gt,Xe,M)=>{"use strict";M.d(Xe,{w:()=>Q});var _e=M(9608),we=M(1396),te=M(3906);function Q(F,j,Ie){if((0,we.Cq)(F),null!=j&&3!==j.length)throw new Error("tensor3d() requires shape to have three numbers");const me=(0,_e.C)(F,Ie);if(3!==me.length&&1!==me.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===me.length&&null==j)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,te.H)(F,j,me,Ie)}},3906:(gt,Xe,M)=>{"use strict";M.d(Xe,{H:()=>Q});var _e=M(3738),we=M(1396),te=M(8813);function Q(F,j,Ie,me){if(null==me&&(me=(0,we.D2)(F)),"complex64"===me)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!(0,we.fU)(F)&&!Array.isArray(F)&&"number"!=typeof F&&"boolean"!=typeof F&&"string"!=typeof F)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=j){(0,we.Mu)(j);const Y=(0,we.NA)(j),le=(0,we.NA)(Ie);(0,we.hu)(Y===le,()=>`Based on the provided shape, [${j}], the tensor should have ${Y} values but has ${le}`);for(let ee=0;ee<Ie.length;++ee){const de=ee!==Ie.length-1||Ie[ee]!==(0,we.NA)(j.slice(ee));(0,we.hu)(Ie[ee]===j[ee]||!de,()=>`Error creating a new Tensor. Inferred shape (${Ie}) does not match the provided shape (${j}). `)}}return!(0,we.fU)(F)&&!Array.isArray(F)&&(F=[F]),j=j||Ie,F="string"!==me?(0,te.toTypedArray)(F,me):(0,we.xH)(F,[],!0),_e.BV.makeTensor(F,j,me)}},9540:(gt,Xe,M)=>{"use strict";M.d(Xe,{p:()=>A});var _e=M(3738),we=M(9370),te=M(1070),Q=M(9608),F=M(1396),j=M(9907),Ie=M(5294),me=M(3304),Y=M(6721),le=M(5732);const A=(0,Y.op)({transpose_:function ee(de,Pe,xe){const Ze=(0,Q._1)(de,"x","transpose");if(null==Pe&&(Pe=Ze.shape.map((Vt,ke)=>ke).reverse()),F.hu(Ze.rank===Pe.length,()=>`Error in transpose: rank of input ${Ze.rank} must match length of perm ${Pe}.`),Pe.forEach(Vt=>{F.hu(Vt>=0&&Vt<Ze.rank,()=>`All entries in 'perm' must be between 0 and ${Ze.rank-1} but got ${Pe}`)}),Ze.rank<=1)return Ze.clone();const ot={x:Ze},St={perm:Pe};return"complex64"===Ze.dtype?(0,we.lu)(()=>{let Vt=(0,le.k)(Ze),ke=(0,Ie.a)(Ze);return Vt=_e.BV.runKernel(te.G3Y,{x:Vt},St),ke=_e.BV.runKernel(te.G3Y,{x:ke},St),xe&&(ke=(0,me.W)(ke)),(0,j.P)(Vt,ke)}):_e.BV.runKernel(te.G3Y,ot,St)}})},37:(gt,Xe,M)=>{"use strict";M.d(Xe,{P:()=>j});var _e=M(3738),we=M(1070),te=M(9608);const j=(0,M(6721).op)({zerosLike_:function F(Ie){const Y={x:(0,te._1)(Ie,"x","zerosLike")};return _e.BV.runKernel(we.RuY,Y)}})},708:(gt,Xe,M)=>{"use strict";M.d(Xe,{es:()=>Oe,YD:()=>Pe,_w:()=>$e,FZ:()=>ke,Vp:()=>Vt,Vi:()=>St});var _e=M(5861),we=M(6422),te=M(1396);const Q=20,F=3,j=7;function Ie(Ce,ye,$,se){const be=(0,te.e3)(ye),ce=function me(Ce,ye,$,se){const be=(0,te.NA)(ye),ce=se[se.length-1],x=new Array(ce).fill(0),He=ye.length,Me="complex64"===$?A(Ce):Ce;if(He>1)for(let We=0;We<be/ce;We++){const nt=We*ce;for(let et=0;et<ce;et++)x[et]=Math.max(x[et],Y(Me[nt+et],0,$).length)}return x}(Ce,ye,$,be),x=ye.length,He=ee(Ce,ye,$,be,ce),Me=["Tensor"];return se&&(Me.push(`  dtype: ${$}`),Me.push(`  rank: ${x}`),Me.push(`  shape: [${ye}]`),Me.push("  values:")),Me.push(He.map(We=>"    "+We).join("\n")),Me.join("\n")}function Y(Ce,ye,$){let se;return se=Array.isArray(Ce)?`${parseFloat(Ce[0].toFixed(j))} + ${parseFloat(Ce[1].toFixed(j))}j`:(0,te.HD)(Ce)?`'${Ce}'`:"bool"===$?le(Ce):parseFloat(Ce.toFixed(j)).toString(),(0,te.oj)(se,ye)}function le(Ce){return 0===Ce?"false":"true"}function ee(Ce,ye,$,se,be,ce=!0){const x="complex64"===$?2:1,He=ye[0],Me=ye.length;if(0===Me)return"complex64"===$?[Y(A(Ce)[0],0,$)]:"bool"===$?[le(Ce[0])]:[Ce[0].toString()];if(1===Me){if(He>Q){let Mn=Array.from(Ce.slice(0,F*x)),cr=Array.from(Ce.slice((He-F)*x,He*x));return"complex64"===$&&(Mn=A(Mn),cr=A(cr)),["["+Mn.map((kn,dn)=>Y(kn,be[dn],$)).join(", ")+", ..., "+cr.map((kn,dn)=>Y(kn,be[He-F+dn],$)).join(", ")+"]"]}return["["+("complex64"===$?A(Ce):Array.from(Ce)).map((yn,Mn)=>Y(yn,be[Mn],$)).join(", ")+"]"]}const We=ye.slice(1),nt=se.slice(1),et=se[0]*x,Ve=[];if(He>Q){for(let Zt=0;Zt<F;Zt++){const yn=Zt*et;Ve.push(...ee(Ce.slice(yn,yn+et),We,$,nt,be,!1))}Ve.push("...");for(let Zt=He-F;Zt<He;Zt++){const yn=Zt*et;Ve.push(...ee(Ce.slice(yn,yn+et),We,$,nt,be,Zt===He-1))}}else for(let Zt=0;Zt<He;Zt++){const yn=Zt*et;Ve.push(...ee(Ce.slice(yn,yn+et),We,$,nt,be,Zt===He-1))}const Ft=2===Me?",":"";Ve[0]="["+Ve[0]+Ft;for(let Zt=1;Zt<Ve.length-1;Zt++)Ve[Zt]=" "+Ve[Zt]+Ft;let Yt=",\n";for(let Zt=2;Zt<Me;Zt++)Yt+="\n";return Ve[Ve.length-1]=" "+Ve[Ve.length-1]+"]"+(ce?"":Yt),Ve}function A(Ce){const ye=[];for(let $=0;$<Ce.length;$+=2)ye.push([Ce[$],Ce[$+1]]);return ye}var de=M(8813);class Pe{constructor(ye,$,se){if(this.dtype=$,this.shape=ye.slice(),this.size=te.NA(ye),null!=se){const be=se.length;te.hu(be===this.size,()=>`Length of values '${be}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===$)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=se||te.rQ($,this.size),this.strides=(0,te.e3)(ye)}set(ye,...$){0===$.length&&($=[0]),te.hu($.length===this.rank,()=>`The number of provided coordinates (${$.length}) must match the rank (${this.rank})`);const se=this.locToIndex($);this.values[se]=ye}get(...ye){0===ye.length&&(ye=[0]);let $=0;for(const be of ye){if(be<0||be>=this.shape[$])throw new Error(`Requested out of range element at ${ye}.   Buffer shape=${this.shape}`);$++}let se=ye[ye.length-1];for(let be=0;be<ye.length-1;++be)se+=this.strides[be]*ye[be];return this.values[se]}locToIndex(ye){if(0===this.rank)return 0;if(1===this.rank)return ye[0];let $=ye[ye.length-1];for(let se=0;se<ye.length-1;++se)$+=this.strides[se]*ye[se];return $}indexToLoc(ye){if(0===this.rank)return[];if(1===this.rank)return[ye];const $=new Array(this.shape.length);for(let se=0;se<$.length-1;++se)$[se]=Math.floor(ye/this.strides[se]),ye-=$[se]*this.strides[se];return $[$.length-1]=ye,$}get rank(){return this.shape.length}toTensor(){return xe().makeTensor(this.values,this.shape,this.dtype)}}let xe=null,Ze=null,ot=null;function St(Ce){xe=Ce}function Vt(Ce){Ze=Ce}function ke(Ce){ot=Ce}class Oe{constructor(ye,$,se,be){this.kept=!1,this.isDisposedInternal=!1,this.shape=ye.slice(),this.dtype=$||"float32",this.size=te.NA(ye),this.strides=(0,te.e3)(ye),this.dataId=se,this.id=be,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var ye=this;return(0,_e.Z)(function*(){const $=yield ye.data();return Ze.buffer(ye.shape,ye.dtype,$)})()}bufferSync(){return Ze.buffer(this.shape,this.dtype,this.dataSync())}array(){var ye=this;return(0,_e.Z)(function*(){const $=yield ye.data();return(0,te.GX)(ye.shape,$,"complex64"===ye.dtype)})()}arraySync(){return(0,te.GX)(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var ye=this;return(0,_e.Z)(function*(){ye.throwIfDisposed();const $=xe().read(ye.dataId);if("string"===ye.dtype){const se=yield $;try{return se.map(be=>de.decodeString(be))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return $})()}dataToGPU(ye){return this.throwIfDisposed(),xe().readToGPU(this.dataId,ye)}dataSync(){this.throwIfDisposed();const ye=xe().readSync(this.dataId);if("string"===this.dtype)try{return ye.map($=>de.decodeString($))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return ye}bytes(){var ye=this;return(0,_e.Z)(function*(){ye.throwIfDisposed();const $=yield xe().read(ye.dataId);return"string"===ye.dtype?$:new Uint8Array($.buffer)})()}dispose(){this.isDisposed||(xe().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(ye=!1){return Ze.print(this,ye)}clone(){return this.throwIfDisposed(),Ze.clone(this)}toString(ye=!1){return Ie(this.dataSync(),this.shape,this.dtype,ye)}cast(ye){return this.throwIfDisposed(),Ze.cast(this,ye)}variable(ye=!0,$,se){return this.throwIfDisposed(),xe().makeVariable(this,ye,$,se)}}Object.defineProperty(Oe,Symbol.hasInstance,{value:Ce=>!!Ce&&null!=Ce.data&&null!=Ce.dataSync&&null!=Ce.throwIfDisposed}),function It(){(0,we.R)("Tensor",()=>Oe)}();class $e extends Oe{constructor(ye,$,se,be){super(ye.shape,ye.dtype,ye.dataId,be),this.trainable=$,this.name=se}assign(ye){if(ye.dtype!==this.dtype)throw new Error(`dtype of the new value (${ye.dtype}) and previous value (${this.dtype}) must match`);if(!te.cO(ye.shape,this.shape))throw new Error(`shape of the new value (${ye.shape}) and previous value (${this.shape}) must match`);xe().disposeTensor(this),this.dataId=ye.dataId,xe().incRef(this,null)}dispose(){xe().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty($e,Symbol.hasInstance,{value:Ce=>Ce instanceof Oe&&null!=Ce.assign&&Ce.assign instanceof Function})},7904:(gt,Xe,M)=>{"use strict";M.r(Xe),M.d(Xe,{assertTypesMatch:()=>F,getTensorsInContainer:()=>Ie,isTensorInList:()=>j,makeTypesMatch:()=>Q});var _e=M(708),we=M(7770),te=M(1396);function Q(le,ee){if(le.dtype===ee.dtype)return[le,ee];const A=(0,we.x8)(le.dtype,ee.dtype);return[le.cast(A),ee.cast(A)]}function F(le,ee){(0,te.hu)(le.dtype===ee.dtype,()=>`The dtypes of the first(${le.dtype}) and second(${ee.dtype}) input must match`)}function j(le,ee){return ee.some(A=>A.id===le.id)}function Ie(le){const ee=[];return me(le,ee,new Set),ee}function me(le,ee,A){if(null==le)return;if(le instanceof _e.es)return void ee.push(le);if(!function Y(le){return Array.isArray(le)||"object"==typeof le}(le))return;const de=le;for(const Pe in de){const xe=de[Pe];A.has(xe)||(A.add(xe),me(xe,ee,A))}}},9608:(gt,Xe,M)=>{"use strict";M.d(Xe,{C:()=>j,_1:()=>Y,sI:()=>le});var _e=M(3738),we=M(1777),te=M(708),Q=M(1396),F=M(8813);function j(ee,A){let de=ee;if((0,Q.fU)(ee))return"string"===A?[]:[ee.length];if(!Array.isArray(ee))return[];const Pe=[];for(;Array.isArray(de)||(0,Q.fU)(de)&&"string"!==A;)Pe.push(de.length),de=de[0];return Array.isArray(ee)&&(0,we.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Ie(ee,Pe,[]),Pe}function Ie(ee,A,de){if(de=de||[],!Array.isArray(ee)&&!(0,Q.fU)(ee))return void(0,Q.hu)(0===A.length,()=>`Element arr[${de.join("][")}] is a primitive, but should be an array/TypedArray of ${A[0]} elements`);(0,Q.hu)(A.length>0,()=>`Element arr[${de.join("][")}] should be a primitive, but is an array of ${ee.length} elements`),(0,Q.hu)(ee.length===A[0],()=>`Element arr[${de.join("][")}] should have ${A[0]} elements, but has ${ee.length} elements`);const Pe=A.slice(1);for(let xe=0;xe<ee.length;++xe)Ie(ee[xe],Pe,de.concat(xe))}function me(ee,A,de,Pe){if("string_or_numeric"!==ee){if(null==ee)throw new Error("Expected dtype cannot be null.");if("numeric"!==ee&&ee!==A||"numeric"===ee&&"string"===A)throw new Error(`Argument '${de}' passed to '${Pe}' must be ${ee} tensor, but got ${A} tensor`)}}function Y(ee,A,de,Pe="numeric"){if(ee instanceof te.es)return me(Pe,ee.dtype,A,de),ee;let xe=(0,Q.D2)(ee);if("string"!==xe&&["bool","int32","float32"].indexOf(Pe)>=0&&(xe=Pe),me(Pe,xe,A,de),null==ee||!(0,Q.fU)(ee)&&!Array.isArray(ee)&&"number"!=typeof ee&&"boolean"!=typeof ee&&"string"!=typeof ee)throw new Error(`Argument '${A}' passed to '${de}' must be a Tensor or TensorLike, but got '${null==ee?"null":ee.constructor.name}'`);const Ze=j(ee,xe);!(0,Q.fU)(ee)&&!Array.isArray(ee)&&(ee=[ee]);const St="string"!==xe?(0,F.toTypedArray)(ee,xe):(0,Q.xH)(ee,[],!0);return _e.BV.makeTensor(St,Ze,xe)}function le(ee,A,de,Pe="numeric"){if(!Array.isArray(ee))throw new Error(`Argument ${A} passed to ${de} must be a \`Tensor[]\` or \`TensorLike[]\``);return ee.map((Ze,ot)=>Y(Ze,`${A}[${ot}]`,de,Pe))}},7770:(gt,Xe,M)=>{"use strict";M.d(Xe,{x8:()=>Ie,yw:()=>_e,z4:()=>me});var _e=(()=>{return(Y=_e||(_e={})).R0="R0",Y.R1="R1",Y.R2="R2",Y.R3="R3",Y.R4="R4",Y.R5="R5",Y.R6="R6",_e;var Y})(),we=(()=>{return(Y=we||(we={})).float32="float32",Y.int32="int32",Y.bool="int32",Y.complex64="complex64",we;var Y})(),te=(()=>{return(Y=te||(te={})).float32="float32",Y.int32="int32",Y.bool="bool",Y.complex64="complex64",te;var Y})(),Q=(()=>{return(Y=Q||(Q={})).float32="float32",Y.int32="float32",Y.bool="float32",Y.complex64="complex64",Q;var Y})(),F=(()=>{return(Y=F||(F={})).float32="complex64",Y.int32="complex64",Y.bool="complex64",Y.complex64="complex64",F;var Y})();const j={float32:Q,int32:we,bool:te,complex64:F};function Ie(Y,le){if("string"===Y||"string"===le){if("string"===Y&&"string"===le)return"string";throw new Error(`Can not upcast ${Y} with ${le}`)}return j[Y][le]}function me(Y){return Ie(Y,"int32")}},8813:(gt,Xe,M)=>{"use strict";M.r(Xe),M.d(Xe,{arraysEqual:()=>we.cO,assert:()=>we.hu,assertNonNegativeIntegerDimensions:()=>we.Mu,assertNonNull:()=>we.Cq,assertShapesMatch:()=>we.k5,bytesFromStringArray:()=>we.Ub,bytesPerElement:()=>we.bT,checkConversionForErrors:()=>we.D5,clamp:()=>we.uZ,computeStrides:()=>we.e3,createScalarValue:()=>It,createShuffledIndices:()=>we.U$,decodeString:()=>be,distSquared:()=>we.E7,encodeString:()=>se,fetch:()=>$,fingerPrint64:()=>Oe,flatten:()=>we.xH,getArrayFromDType:()=>we.rQ,getTypedArrayFromDType:()=>we.WP,hasEncodingLoss:()=>we.QB,hexToLong:()=>j,indexToLoc:()=>we.NE,inferDtype:()=>we.D2,inferFromImplicitShape:()=>we.JZ,isBoolean:()=>we.jn,isFunction:()=>we.mf,isInt:()=>we.GN,isNumber:()=>we.hj,isPromise:()=>we.tI,isScalarShape:()=>we.N9,isString:()=>we.HD,isTypedArray:()=>we.fU,isValidDtype:()=>we.LP,locToIndex:()=>we.qy,makeOnesTypedArray:()=>we.p8,makeZerosNestedTypedArray:()=>we.l6,makeZerosTypedArray:()=>we.wT,nearestDivisor:()=>we.jP,nearestLargerEven:()=>we.nY,now:()=>ye,parseAxisParam:()=>we.EC,randUniform:()=>we.bj,repeatedTry:()=>we.WD,rightPad:()=>we.oj,shuffle:()=>we.TV,shuffleCombo:()=>we.d7,sizeFromShape:()=>we.NA,sizeToSquarishShape:()=>we.YP,squeezeShape:()=>we.bp,sum:()=>we.Sm,swap:()=>we.LF,tanh:()=>we.AE,toNestedArray:()=>we.GX,toTypedArray:()=>Ce});var _e=M(1777),we=M(1396),te=M(7658);const F=M.n(te)()||te;function j(ce){return F.fromString(ce,!0,16)}const Ie=j("c3a5c85c97cb3127"),me=j("b492b66fbe98f273"),Y=j("9ae16a3b2f90404f");function le(ce){return ce.xor(ce.shru(47))}function ee(ce,x,He){const Me=ce.slice(x,x+He);return F.fromBytes(Array.from(Me),!0,!0)}function A(ce,x){return ee(ce,x,8)}function de(ce,x){return ee(ce,x,4)}function Pe(ce,x){return 0===x?ce:ce.shru(x).or(ce.shl(64-x))}function xe(ce,x,He=j("9ddfea08eb382d69")){let Me=ce.xor(x).mul(He);Me=Me.xor(Me.shru(47));let We=x.xor(Me).mul(He);return We=We.xor(We.shru(47)),We=We.mul(He),We}function ot(ce,x,He,Me){return function Ze(ce,x,He,Me,We,nt){We=We.add(ce),nt=Pe(nt.add(We).add(Me),21);const et=We;return We=(We=We.add(x)).add(He),nt=nt.add(Pe(We,44)),[We.add(Me),nt.add(et)]}(A(ce,x),A(ce,x+8),A(ce,x+16),A(ce,x+24),He,Me)}function Oe(ce,x=ce.length){const He=F.fromNumber(81,!0);if(x<=32)return x<=16?function St(ce,x=ce.length){if(x>=8){const He=Y.add(2*x),Me=A(ce,0).add(Y),We=A(ce,x-8);return xe(Pe(We,37).mul(He).add(Me),Pe(Me,25).add(We).mul(He),He)}if(x>=4){const He=Y.add(2*x);return xe(de(ce,0).shl(3).add(x),de(ce,x-4),He)}if(x>0){const et=x+(ce[x-1]<<2);return le(Y.mul(ce[0]+(ce[x>>1]<<8)).xor(Ie.mul(et))).mul(Y)}return Y}(ce,x):function Vt(ce,x=ce.length){const He=Y.add(2*x),Me=A(ce,0).mul(me),We=A(ce,8),nt=A(ce,x-8).mul(He),et=A(ce,x-16).mul(Y);return xe(Pe(Me.add(We),43).add(Pe(nt,30)).add(et),Me.add(Pe(We.add(Y),18)).add(nt),He)}(ce,x);if(x<=64)return function ke(ce,x=ce.length){const He=Y.add(2*x),Me=A(ce,0).mul(Y),We=A(ce,8),nt=A(ce,x-8).mul(He),et=A(ce,x-16).mul(Y),Ve=Pe(Me.add(We),43).add(Pe(nt,30)).add(et),Ft=xe(Ve,Me.add(Pe(We.add(Y),18)).add(nt),He),Yt=A(ce,16).mul(He),Zt=A(ce,24),yn=Ve.add(A(ce,x-32)).mul(He),Mn=Ft.add(A(ce,x-24)).mul(He);return xe(Pe(Yt.add(Zt),43).add(Pe(yn,30)).add(Mn),Yt.add(Pe(Zt.add(Me),18)).add(yn),He)}(ce,x);let Me=He,We=He.mul(me).add(113),nt=le(We.mul(Y).add(113)).mul(Y),et=[F.UZERO,F.UZERO],Ve=[F.UZERO,F.UZERO];Me=Me.mul(Y).add(A(ce,0));let Ft=0;const Yt=64*(x-1>>6),Zt=Yt+(x-1&63)-63;do{Me=Pe(Me.add(We).add(et[0]).add(A(ce,Ft+8)),37).mul(me),We=Pe(We.add(et[1]).add(A(ce,Ft+48)),42).mul(me),Me=Me.xor(Ve[1]),We=We.add(et[0]).add(A(ce,Ft+40)),nt=Pe(nt.add(Ve[0]),33).mul(me),et=ot(ce,Ft,et[1].mul(me),Me.add(Ve[0])),Ve=ot(ce,Ft+32,nt.add(Ve[1]),We.add(A(ce,Ft+16))),[nt,Me]=[Me,nt],Ft+=64}while(Ft!==Yt);const yn=me.add(nt.and(255).shl(1));return Ft=Zt,Ve[0]=Ve[0].add(x-1&63),et[0]=et[0].add(Ve[0]),Ve[0]=Ve[0].add(et[0]),Me=Pe(Me.add(We).add(et[0]).add(A(ce,Ft+8)),37).mul(yn),We=Pe(We.add(et[1]).add(A(ce,Ft+48)),42).mul(yn),Me=Me.xor(Ve[1].mul(9)),We=We.add(et[0].mul(9).add(A(ce,Ft+40))),nt=Pe(nt.add(Ve[0]),33).mul(yn),et=ot(ce,Ft,et[1].mul(yn),Me.add(Ve[0])),Ve=ot(ce,Ft+32,nt.add(Ve[1]),We.add(A(ce,Ft+16))),[nt,Me]=[Me,nt],xe(xe(et[0],Ve[0],yn).add(le(We).mul(Ie)).add(nt),xe(et[1],Ve[1],yn).add(Me),yn)}function It(ce,x){return"string"===x?se(ce):Ce([ce],x)}function Ce(ce,x){if("string"===x)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(ce)&&(ce=we.xH(ce)),(0,_e.OB)().getBool("DEBUG")&&we.D5(ce,x),function $e(ce,x){return ce instanceof Float32Array&&"float32"===x||ce instanceof Int32Array&&"int32"===x||ce instanceof Uint8Array&&"bool"===x}(ce,x))return ce;if(null==x||"float32"===x||"complex64"===x)return new Float32Array(ce);if("int32"===x)return new Int32Array(ce);if("bool"===x){const He=new Uint8Array(ce.length);for(let Me=0;Me<He.length;++Me)0!==Math.round(ce[Me])&&(He[Me]=1);return He}throw new Error(`Unknown data type ${x}`)}function ye(){return(0,_e.OB)().platform.now()}function $(ce,x){return(0,_e.OB)().platform.fetch(ce,x)}function se(ce,x="utf-8"){return x=x||"utf-8",(0,_e.OB)().platform.encode(ce,x)}function be(ce,x="utf-8"){return x=x||"utf-8",(0,_e.OB)().platform.decode(ce,x)}},1396:(gt,Xe,M)=>{"use strict";function _e(Ne){let rt=Ne.length,lt=0;for(;rt>0;)lt=Math.random()*rt|0,rt--,F(Ne,rt,lt)}function we(Ne,rt){if(Ne.length!==rt.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${Ne.length}Second array length was ${rt.length}`);let lt=Ne.length,Nt=0;for(;lt>0;)Nt=Math.random()*lt|0,lt--,F(Ne,lt,Nt),F(rt,lt,Nt)}function te(Ne,rt,lt){return Math.max(Ne,Math.min(rt,lt))}function Q(Ne){return Ne%2==0?Ne:Ne+1}function F(Ne,rt,lt){const Nt=Ne[rt];Ne[rt]=Ne[lt],Ne[lt]=Nt}function j(Ne){let rt=0;for(let lt=0;lt<Ne.length;lt++)rt+=Ne[lt];return rt}function Ie(Ne,rt){const lt=Math.random();return rt*lt+(1-lt)*Ne}function me(Ne,rt){let lt=0;for(let Nt=0;Nt<Ne.length;Nt++){const wn=Number(Ne[Nt])-Number(rt[Nt]);lt+=wn*wn}return lt}function Y(Ne,rt){if(!Ne)throw new Error("string"==typeof rt?rt:rt())}function le(Ne,rt,lt=""){Y(xe(Ne,rt),()=>lt+` Shapes ${Ne} and ${rt} must match`)}function ee(Ne){Y(null!=Ne,()=>"The input to the tensor constructor must be a non-null value.")}function A(Ne,rt=[],lt=!1){if(null==rt&&(rt=[]),Array.isArray(Ne)||x(Ne)&&!lt)for(let Nt=0;Nt<Ne.length;++Nt)A(Ne[Nt],rt,lt);else rt.push(Ne);return rt}function de(Ne){if(0===Ne.length)return 1;let rt=Ne[0];for(let lt=1;lt<Ne.length;lt++)rt*=Ne[lt];return rt}function Pe(Ne){return 0===Ne.length}function xe(Ne,rt){if(Ne===rt)return!0;if(null==Ne||null==rt||Ne.length!==rt.length)return!1;for(let lt=0;lt<Ne.length;lt++)if(Ne[lt]!==rt[lt])return!1;return!0}function Ze(Ne){return Ne%1==0}function ot(Ne){if(null!=Math.tanh)return Math.tanh(Ne);if(Ne===1/0)return 1;if(Ne===-1/0)return-1;{const rt=Math.exp(2*Ne);return(rt-1)/(rt+1)}}function St(Ne){const rt=Math.ceil(Math.sqrt(Ne));return[rt,Math.ceil(Ne/rt)]}function Vt(Ne){const rt=new Uint32Array(Ne);for(let lt=0;lt<Ne;++lt)rt[lt]=lt;return _e(rt),rt}function ke(Ne,rt){return rt<=Ne.length?Ne:Ne+" ".repeat(rt-Ne.length)}function Oe(Ne,rt=(wn=>0),lt,Nt=setTimeout){return new Promise((wn,zn)=>{let Jn=0;const wr=()=>{if(Ne())return void wn();Jn++;const $r=rt(Jn);null!=lt&&Jn>=lt?zn():Nt(wr,$r)};wr()})}function It(Ne,rt){let lt=1,Nt=-1;for(let zn=0;zn<Ne.length;++zn)if(Ne[zn]>=0)lt*=Ne[zn];else if(-1===Ne[zn]){if(-1!==Nt)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${Nt} and dim ${zn}`);Nt=zn}else if(Ne[zn]<0)throw Error(`Shapes can not be < 0. Found ${Ne[zn]} at dim ${zn}`);if(-1===Nt){if(rt>0&&rt!==lt)throw Error(`Size(${rt}) must match the product of shape ${Ne}`);return Ne}if(0===lt)throw Error(`Cannot infer the missing size in [${Ne}] when there are 0 elements`);if(rt%lt!=0)throw Error(`The implicit shape can't be a fractional number. Got ${rt} / ${lt}`);const wn=Ne.slice();return wn[Nt]=rt/lt,wn}function $e(Ne,rt){const lt=rt.length;return Y((Ne=null==Ne?rt.map((Nt,wn)=>wn):[].concat(Ne)).every(Nt=>Nt>=-lt&&Nt<lt),()=>`All values in axis param must be in range [-${lt}, ${lt}) but got axis ${Ne}`),Y(Ne.every(Nt=>Ze(Nt)),()=>`All values in axis param must be integers but got axis ${Ne}`),Ne.map(Nt=>Nt<0?lt+Nt:Nt)}function Ce(Ne,rt){const lt=[],Nt=[],wn=null!=rt&&Array.isArray(rt)&&0===rt.length,zn=null==rt||wn?null:$e(rt,Ne).sort();let Jn=0;for(let wr=0;wr<Ne.length;++wr){if(null!=zn){if(zn[Jn]===wr&&1!==Ne[wr])throw new Error(`Can't squeeze axis ${wr} since its dim '${Ne[wr]}' is not 1`);(null==zn[Jn]||zn[Jn]>wr)&&1===Ne[wr]&&(lt.push(Ne[wr]),Nt.push(wr)),zn[Jn]<=wr&&Jn++}1!==Ne[wr]&&(lt.push(Ne[wr]),Nt.push(wr))}return{newShape:lt,keptDims:Nt}}function ye(Ne,rt){let lt=null;if(null==Ne||"float32"===Ne)lt=new Float32Array(rt);else if("int32"===Ne)lt=new Int32Array(rt);else{if("bool"!==Ne)throw new Error(`Unknown data type ${Ne}`);lt=new Uint8Array(rt)}return lt}function $(Ne,rt){let lt=null;if(null==Ne||"float32"===Ne)lt=new Float32Array(rt);else if("int32"===Ne)lt=new Int32Array(rt);else if("bool"===Ne)lt=new Uint8Array(rt);else{if("string"!==Ne)throw new Error(`Unknown data type ${Ne}`);lt=new Array(rt)}return lt}function se(Ne,rt){for(let lt=0;lt<Ne.length;lt++){const Nt=Ne[lt];if(isNaN(Nt)||!isFinite(Nt))throw Error(`A tensor of type ${rt} being uploaded contains ${Nt}.`)}}function be(Ne){return"bool"===Ne||"complex64"===Ne||"float32"===Ne||"int32"===Ne||"string"===Ne}function ce(Ne,rt){return!("complex64"===rt||"float32"===rt&&"complex64"!==Ne||"int32"===rt&&"float32"!==Ne&&"complex64"!==Ne||"bool"===rt&&"bool"===Ne)}function x(Ne){return Ne instanceof Float32Array||Ne instanceof Int32Array||Ne instanceof Uint8Array||Ne instanceof Uint8ClampedArray}function He(Ne){if("float32"===Ne||"int32"===Ne)return 4;if("complex64"===Ne)return 8;if("bool"===Ne)return 1;throw new Error(`Unknown dtype ${Ne}`)}function Me(Ne){if(null==Ne)return 0;let rt=0;return Ne.forEach(lt=>rt+=lt.length),rt}function We(Ne){return"string"==typeof Ne||Ne instanceof String}function nt(Ne){return"boolean"==typeof Ne}function et(Ne){return"number"==typeof Ne}function Ve(Ne){return Array.isArray(Ne)?Ve(Ne[0]):Ne instanceof Float32Array?"float32":Ne instanceof Int32Array||Ne instanceof Uint8Array||Ne instanceof Uint8ClampedArray?"int32":et(Ne)?"float32":We(Ne)?"string":nt(Ne)?"bool":"float32"}function Ft(Ne){return!!(Ne&&Ne.constructor&&Ne.call&&Ne.apply)}function Yt(Ne,rt){for(let lt=rt;lt<Ne;++lt)if(Ne%lt==0)return lt;return Ne}function Zt(Ne){const rt=Ne.length;if(rt<2)return[];const lt=new Array(rt-1);lt[rt-2]=Ne[rt-1];for(let Nt=rt-3;Nt>=0;--Nt)lt[Nt]=lt[Nt+1]*Ne[Nt+1];return lt}function yn(Ne,rt,lt,Nt=!1){const wn=new Array;if(1===rt.length){const zn=rt[0]*(Nt?2:1);for(let Jn=0;Jn<zn;Jn++)wn[Jn]=lt[Ne+Jn]}else{const zn=rt[0],Jn=rt.slice(1),wr=Jn.reduce(($r,_r)=>$r*_r)*(Nt?2:1);for(let $r=0;$r<zn;$r++)wn[$r]=yn(Ne+$r*wr,Jn,lt,Nt)}return wn}function Mn(Ne,rt,lt=!1){if(0===Ne.length)return rt[0];const Nt=Ne.reduce((wn,zn)=>wn*zn)*(lt?2:1);if(0===Nt)return[];if(Nt!==rt.length)throw new Error(`[${Ne}] does not match the input size ${rt.length}${lt?" for a complex tensor":""}.`);return yn(0,Ne,rt,lt)}function cr(Ne,rt){const lt=kn(Ne,rt);for(let Nt=0;Nt<lt.length;Nt++)lt[Nt]=1;return lt}function kn(Ne,rt){if(null==rt||"float32"===rt||"complex64"===rt)return new Float32Array(Ne);if("int32"===rt)return new Int32Array(Ne);if("bool"===rt)return new Uint8Array(Ne);throw new Error(`Unknown data type ${rt}`)}function dn(Ne,rt){const lt=Ne.reduce((Nt,wn)=>Nt*wn,1);if(null==rt||"float32"===rt)return Mn(Ne,new Float32Array(lt));if("int32"===rt)return Mn(Ne,new Int32Array(lt));if("bool"===rt)return Mn(Ne,new Uint8Array(lt));throw new Error(`Unknown data type ${rt}`)}function un(Ne){Ne.forEach(rt=>{Y(Number.isInteger(rt)&&rt>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${Ne}].`)})}function Fn(Ne,rt,lt){if(0===rt)return 0;if(1===rt)return Ne[0];let Nt=Ne[Ne.length-1];for(let wn=0;wn<Ne.length-1;++wn)Nt+=lt[wn]*Ne[wn];return Nt}function ds(Ne,rt,lt){if(0===rt)return[];if(1===rt)return[Ne];const Nt=new Array(rt);for(let wn=0;wn<Nt.length-1;++wn)Nt[wn]=Math.floor(Ne/lt[wn]),Ne-=Nt[wn]*lt[wn];return Nt[Nt.length-1]=Ne,Nt}function Zn(Ne){return Ne&&Ne.then&&"function"==typeof Ne.then}M.d(Xe,{AE:()=>ot,Cq:()=>ee,D2:()=>Ve,D5:()=>se,E7:()=>me,EC:()=>$e,GN:()=>Ze,GX:()=>Mn,HD:()=>We,JZ:()=>It,LF:()=>F,LP:()=>be,Mu:()=>un,N9:()=>Pe,NA:()=>de,NE:()=>ds,QB:()=>ce,Sm:()=>j,TV:()=>_e,U$:()=>Vt,Ub:()=>Me,WD:()=>Oe,WP:()=>ye,YP:()=>St,bT:()=>He,bj:()=>Ie,bp:()=>Ce,cO:()=>xe,d7:()=>we,e3:()=>Zt,fU:()=>x,hj:()=>et,hu:()=>Y,jP:()=>Yt,jn:()=>nt,k5:()=>le,l6:()=>dn,mf:()=>Ft,nY:()=>Q,oj:()=>ke,p8:()=>cr,qy:()=>Fn,rQ:()=>$,tI:()=>Zn,uZ:()=>te,wT:()=>kn,xH:()=>A})},7658:gt=>{gt.exports=M;var Xe=null;try{Xe=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function M(ye,$,se){this.low=0|ye,this.high=0|$,this.unsigned=!!se}function _e(ye){return!0===(ye&&ye.__isLong__)}Object.defineProperty(M.prototype,"__isLong__",{value:!0}),M.isLong=_e;var we={},te={};function Q(ye,$){var se,be,ce;return $?(ce=0<=(ye>>>=0)&&ye<256)&&(be=te[ye])?be:(se=j(ye,(0|ye)<0?-1:0,!0),ce&&(te[ye]=se),se):(ce=-128<=(ye|=0)&&ye<128)&&(be=we[ye])?be:(se=j(ye,ye<0?-1:0,!1),ce&&(we[ye]=se),se)}function F(ye,$){if(isNaN(ye))return $?ot:Ze;if($){if(ye<0)return ot;if(ye>=de)return It}else{if(ye<=-Pe)return $e;if(ye+1>=Pe)return Oe}return ye<0?F(-ye,$).neg():j(ye%A|0,ye/A|0,$)}function j(ye,$,se){return new M(ye,$,se)}M.fromInt=Q,M.fromNumber=F,M.fromBits=j;var Ie=Math.pow;function me(ye,$,se){if(0===ye.length)throw Error("empty string");if("NaN"===ye||"Infinity"===ye||"+Infinity"===ye||"-Infinity"===ye)return Ze;if("number"==typeof $?(se=$,$=!1):$=!!$,(se=se||10)<2||36<se)throw RangeError("radix");var be;if((be=ye.indexOf("-"))>0)throw Error("interior hyphen");if(0===be)return me(ye.substring(1),$,se).neg();for(var ce=F(Ie(se,8)),x=Ze,He=0;He<ye.length;He+=8){var Me=Math.min(8,ye.length-He),We=parseInt(ye.substring(He,He+Me),se);if(Me<8){var nt=F(Ie(se,Me));x=x.mul(nt).add(F(We))}else x=(x=x.mul(ce)).add(F(We))}return x.unsigned=$,x}function Y(ye,$){return"number"==typeof ye?F(ye,$):"string"==typeof ye?me(ye,$):j(ye.low,ye.high,"boolean"==typeof $?$:ye.unsigned)}M.fromString=me,M.fromValue=Y;var A=4294967296,de=A*A,Pe=de/2,xe=Q(1<<24),Ze=Q(0);M.ZERO=Ze;var ot=Q(0,!0);M.UZERO=ot;var St=Q(1);M.ONE=St;var Vt=Q(1,!0);M.UONE=Vt;var ke=Q(-1);M.NEG_ONE=ke;var Oe=j(-1,2147483647,!1);M.MAX_VALUE=Oe;var It=j(-1,-1,!0);M.MAX_UNSIGNED_VALUE=It;var $e=j(0,-2147483648,!1);M.MIN_VALUE=$e;var Ce=M.prototype;Ce.toInt=function(){return this.unsigned?this.low>>>0:this.low},Ce.toNumber=function(){return this.unsigned?(this.high>>>0)*A+(this.low>>>0):this.high*A+(this.low>>>0)},Ce.toString=function($){if(($=$||10)<2||36<$)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq($e)){var se=F($),be=this.div(se),ce=be.mul(se).sub(this);return be.toString($)+ce.toInt().toString($)}return"-"+this.neg().toString($)}for(var x=F(Ie($,6),this.unsigned),He=this,Me="";;){var We=He.div(x),et=(He.sub(We.mul(x)).toInt()>>>0).toString($);if((He=We).isZero())return et+Me;for(;et.length<6;)et="0"+et;Me=""+et+Me}},Ce.getHighBits=function(){return this.high},Ce.getHighBitsUnsigned=function(){return this.high>>>0},Ce.getLowBits=function(){return this.low},Ce.getLowBitsUnsigned=function(){return this.low>>>0},Ce.getNumBitsAbs=function(){if(this.isNegative())return this.eq($e)?64:this.neg().getNumBitsAbs();for(var $=0!=this.high?this.high:this.low,se=31;se>0&&!($&1<<se);se--);return 0!=this.high?se+33:se+1},Ce.isZero=function(){return 0===this.high&&0===this.low},Ce.eqz=Ce.isZero,Ce.isNegative=function(){return!this.unsigned&&this.high<0},Ce.isPositive=function(){return this.unsigned||this.high>=0},Ce.isOdd=function(){return 1==(1&this.low)},Ce.isEven=function(){return 0==(1&this.low)},Ce.equals=function($){return _e($)||($=Y($)),(this.unsigned===$.unsigned||this.high>>>31!=1||$.high>>>31!=1)&&this.high===$.high&&this.low===$.low},Ce.eq=Ce.equals,Ce.notEquals=function($){return!this.eq($)},Ce.neq=Ce.notEquals,Ce.ne=Ce.notEquals,Ce.lessThan=function($){return this.comp($)<0},Ce.lt=Ce.lessThan,Ce.lessThanOrEqual=function($){return this.comp($)<=0},Ce.lte=Ce.lessThanOrEqual,Ce.le=Ce.lessThanOrEqual,Ce.greaterThan=function($){return this.comp($)>0},Ce.gt=Ce.greaterThan,Ce.greaterThanOrEqual=function($){return this.comp($)>=0},Ce.gte=Ce.greaterThanOrEqual,Ce.ge=Ce.greaterThanOrEqual,Ce.compare=function($){if(_e($)||($=Y($)),this.eq($))return 0;var se=this.isNegative(),be=$.isNegative();return se&&!be?-1:!se&&be?1:this.unsigned?$.high>>>0>this.high>>>0||$.high===this.high&&$.low>>>0>this.low>>>0?-1:1:this.sub($).isNegative()?-1:1},Ce.comp=Ce.compare,Ce.negate=function(){return!this.unsigned&&this.eq($e)?$e:this.not().add(St)},Ce.neg=Ce.negate,Ce.add=function($){_e($)||($=Y($));var et=0,Ve=0,Ft=0,Yt=0;return Ft+=(Yt+=(65535&this.low)+(65535&$.low))>>>16,Ve+=(Ft+=(this.low>>>16)+($.low>>>16))>>>16,et+=(Ve+=(65535&this.high)+(65535&$.high))>>>16,et+=(this.high>>>16)+($.high>>>16),j((Ft&=65535)<<16|(Yt&=65535),(et&=65535)<<16|(Ve&=65535),this.unsigned)},Ce.subtract=function($){return _e($)||($=Y($)),this.add($.neg())},Ce.sub=Ce.subtract,Ce.multiply=function($){if(this.isZero())return Ze;if(_e($)||($=Y($)),Xe)return j(Xe.mul(this.low,this.high,$.low,$.high),Xe.get_high(),this.unsigned);if($.isZero())return Ze;if(this.eq($e))return $.isOdd()?$e:Ze;if($.eq($e))return this.isOdd()?$e:Ze;if(this.isNegative())return $.isNegative()?this.neg().mul($.neg()):this.neg().mul($).neg();if($.isNegative())return this.mul($.neg()).neg();if(this.lt(xe)&&$.lt(xe))return F(this.toNumber()*$.toNumber(),this.unsigned);var ce=65535&this.high,x=this.low>>>16,He=65535&this.low,We=65535&$.high,nt=$.low>>>16,et=65535&$.low,Ve=0,Ft=0,Yt=0,Zt=0;return Yt+=(Zt+=He*et)>>>16,Ft+=(Yt+=x*et)>>>16,Yt&=65535,Ft+=(Yt+=He*nt)>>>16,Ve+=(Ft+=ce*et)>>>16,Ft&=65535,Ve+=(Ft+=x*nt)>>>16,Ft&=65535,Ve+=(Ft+=He*We)>>>16,Ve+=(this.high>>>16)*et+ce*nt+x*We+He*($.high>>>16),j((Yt&=65535)<<16|(Zt&=65535),(Ve&=65535)<<16|(Ft&=65535),this.unsigned)},Ce.mul=Ce.multiply,Ce.divide=function($){if(_e($)||($=Y($)),$.isZero())throw Error("division by zero");var be,ce,x;if(Xe)return this.unsigned||-2147483648!==this.high||-1!==$.low||-1!==$.high?j((this.unsigned?Xe.div_u:Xe.div_s)(this.low,this.high,$.low,$.high),Xe.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?ot:Ze;if(this.unsigned){if($.unsigned||($=$.toUnsigned()),$.gt(this))return ot;if($.gt(this.shru(1)))return Vt;x=ot}else{if(this.eq($e))return $.eq(St)||$.eq(ke)?$e:$.eq($e)?St:(be=this.shr(1).div($).shl(1)).eq(Ze)?$.isNegative()?St:ke:(ce=this.sub($.mul(be)),x=be.add(ce.div($)));if($.eq($e))return this.unsigned?ot:Ze;if(this.isNegative())return $.isNegative()?this.neg().div($.neg()):this.neg().div($).neg();if($.isNegative())return this.div($.neg()).neg();x=Ze}for(ce=this;ce.gte($);){be=Math.max(1,Math.floor(ce.toNumber()/$.toNumber()));for(var Me=Math.ceil(Math.log(be)/Math.LN2),We=Me<=48?1:Ie(2,Me-48),nt=F(be),et=nt.mul($);et.isNegative()||et.gt(ce);)et=(nt=F(be-=We,this.unsigned)).mul($);nt.isZero()&&(nt=St),x=x.add(nt),ce=ce.sub(et)}return x},Ce.div=Ce.divide,Ce.modulo=function($){return _e($)||($=Y($)),Xe?j((this.unsigned?Xe.rem_u:Xe.rem_s)(this.low,this.high,$.low,$.high),Xe.get_high(),this.unsigned):this.sub(this.div($).mul($))},Ce.mod=Ce.modulo,Ce.rem=Ce.modulo,Ce.not=function(){return j(~this.low,~this.high,this.unsigned)},Ce.and=function($){return _e($)||($=Y($)),j(this.low&$.low,this.high&$.high,this.unsigned)},Ce.or=function($){return _e($)||($=Y($)),j(this.low|$.low,this.high|$.high,this.unsigned)},Ce.xor=function($){return _e($)||($=Y($)),j(this.low^$.low,this.high^$.high,this.unsigned)},Ce.shiftLeft=function($){return _e($)&&($=$.toInt()),0==($&=63)?this:$<32?j(this.low<<$,this.high<<$|this.low>>>32-$,this.unsigned):j(0,this.low<<$-32,this.unsigned)},Ce.shl=Ce.shiftLeft,Ce.shiftRight=function($){return _e($)&&($=$.toInt()),0==($&=63)?this:$<32?j(this.low>>>$|this.high<<32-$,this.high>>$,this.unsigned):j(this.high>>$-32,this.high>=0?0:-1,this.unsigned)},Ce.shr=Ce.shiftRight,Ce.shiftRightUnsigned=function($){if(_e($)&&($=$.toInt()),0==($&=63))return this;var se=this.high;return $<32?j(this.low>>>$|se<<32-$,se>>>$,this.unsigned):j(32===$?se:se>>>$-32,0,this.unsigned)},Ce.shru=Ce.shiftRightUnsigned,Ce.shr_u=Ce.shiftRightUnsigned,Ce.toSigned=function(){return this.unsigned?j(this.low,this.high,!1):this},Ce.toUnsigned=function(){return this.unsigned?this:j(this.low,this.high,!0)},Ce.toBytes=function($){return $?this.toBytesLE():this.toBytesBE()},Ce.toBytesLE=function(){var $=this.high,se=this.low;return[255&se,se>>>8&255,se>>>16&255,se>>>24,255&$,$>>>8&255,$>>>16&255,$>>>24]},Ce.toBytesBE=function(){var $=this.high,se=this.low;return[$>>>24,$>>>16&255,$>>>8&255,255&$,se>>>24,se>>>16&255,se>>>8&255,255&se]},M.fromBytes=function($,se,be){return be?M.fromBytesLE($,se):M.fromBytesBE($,se)},M.fromBytesLE=function($,se){return new M($[0]|$[1]<<8|$[2]<<16|$[3]<<24,$[4]|$[5]<<8|$[6]<<16|$[7]<<24,se)},M.fromBytesBE=function($,se){return new M($[4]<<24|$[5]<<16|$[6]<<8|$[7],$[0]<<24|$[1]<<16|$[2]<<8|$[3],se)}},340:(gt,Xe,M)=>{var _e=M(9471),we=M(2992),te=M(7657),Q=M(5583),F=M(1929),j=M(8083),Ie=M(3818);Ie.alea=_e,Ie.xor128=we,Ie.xorwow=te,Ie.xorshift7=Q,Ie.xor4096=F,Ie.tychei=j,gt.exports=Ie},9471:function(gt,Xe,M){var _e;!function(we,te,Q){function F(Y){var le=this,ee=function me(){var Y=4022871197;return function(ee){ee=String(ee);for(var A=0;A<ee.length;A++){var de=.02519603282416938*(Y+=ee.charCodeAt(A));de-=Y=de>>>0,Y=(de*=Y)>>>0,Y+=4294967296*(de-=Y)}return 2.3283064365386963e-10*(Y>>>0)}}();le.next=function(){var A=2091639*le.s0+2.3283064365386963e-10*le.c;return le.s0=le.s1,le.s1=le.s2,le.s2=A-(le.c=0|A)},le.c=1,le.s0=ee(" "),le.s1=ee(" "),le.s2=ee(" "),le.s0-=ee(Y),le.s0<0&&(le.s0+=1),le.s1-=ee(Y),le.s1<0&&(le.s1+=1),le.s2-=ee(Y),le.s2<0&&(le.s2+=1),ee=null}function j(Y,le){return le.c=Y.c,le.s0=Y.s0,le.s1=Y.s1,le.s2=Y.s2,le}function Ie(Y,le){var ee=new F(Y),A=le&&le.state,de=ee.next;return de.int32=function(){return 4294967296*ee.next()|0},de.double=function(){return de()+11102230246251565e-32*(2097152*de()|0)},de.quick=de,A&&("object"==typeof A&&j(A,ee),de.state=function(){return j(ee,{})}),de}te&&te.exports?te.exports=Ie:M.amdD&&M.amdO?void 0!==(_e=function(){return Ie}.call(Xe,M,Xe,te))&&(te.exports=_e):this.alea=Ie}(0,gt=M.nmd(gt))},8083:function(gt,Xe,M){var _e;!function(we,te,Q){function F(me){var Y=this,le="";Y.next=function(){var A=Y.b,de=Y.c,Pe=Y.d,xe=Y.a;return A=A<<25^A>>>7^de,de=de-Pe|0,Pe=Pe<<24^Pe>>>8^xe,xe=xe-A|0,Y.b=A=A<<20^A>>>12^de,Y.c=de=de-Pe|0,Y.d=Pe<<16^de>>>16^xe,Y.a=xe-A|0},Y.a=0,Y.b=0,Y.c=-1640531527,Y.d=1367130551,me===Math.floor(me)?(Y.a=me/4294967296|0,Y.b=0|me):le+=me;for(var ee=0;ee<le.length+20;ee++)Y.b^=0|le.charCodeAt(ee),Y.next()}function j(me,Y){return Y.a=me.a,Y.b=me.b,Y.c=me.c,Y.d=me.d,Y}function Ie(me,Y){var le=new F(me),ee=Y&&Y.state,A=function(){return(le.next()>>>0)/4294967296};return A.double=function(){do{var xe=((le.next()>>>11)+(le.next()>>>0)/4294967296)/(1<<21)}while(0===xe);return xe},A.int32=le.next,A.quick=A,ee&&("object"==typeof ee&&j(ee,le),A.state=function(){return j(le,{})}),A}te&&te.exports?te.exports=Ie:M.amdD&&M.amdO?void 0!==(_e=function(){return Ie}.call(Xe,M,Xe,te))&&(te.exports=_e):this.tychei=Ie}(0,gt=M.nmd(gt))},2992:function(gt,Xe,M){var _e;!function(we,te,Q){function F(me){var Y=this,le="";Y.x=0,Y.y=0,Y.z=0,Y.w=0,Y.next=function(){var A=Y.x^Y.x<<11;return Y.x=Y.y,Y.y=Y.z,Y.z=Y.w,Y.w^=Y.w>>>19^A^A>>>8},me===(0|me)?Y.x=me:le+=me;for(var ee=0;ee<le.length+64;ee++)Y.x^=0|le.charCodeAt(ee),Y.next()}function j(me,Y){return Y.x=me.x,Y.y=me.y,Y.z=me.z,Y.w=me.w,Y}function Ie(me,Y){var le=new F(me),ee=Y&&Y.state,A=function(){return(le.next()>>>0)/4294967296};return A.double=function(){do{var xe=((le.next()>>>11)+(le.next()>>>0)/4294967296)/(1<<21)}while(0===xe);return xe},A.int32=le.next,A.quick=A,ee&&("object"==typeof ee&&j(ee,le),A.state=function(){return j(le,{})}),A}te&&te.exports?te.exports=Ie:M.amdD&&M.amdO?void 0!==(_e=function(){return Ie}.call(Xe,M,Xe,te))&&(te.exports=_e):this.xor128=Ie}(0,gt=M.nmd(gt))},1929:function(gt,Xe,M){var _e;!function(we,te,Q){function F(me){var Y=this;Y.next=function(){var Pe,xe,ee=Y.w,A=Y.X,de=Y.i;return Y.w=ee=ee+1640531527|0,xe=A[de+34&127],Pe=A[de=de+1&127],xe^=xe<<13,Pe^=Pe<<17,xe=A[de]=(xe^=xe>>>15)^(Pe^=Pe>>>12),Y.i=de,xe+(ee^ee>>>16)|0},function le(ee,A){var de,Pe,xe,Ze,ot,St=[],Vt=128;for(A===(0|A)?(Pe=A,A=null):(A+="\0",Pe=0,Vt=Math.max(Vt,A.length)),xe=0,Ze=-32;Ze<Vt;++Ze)A&&(Pe^=A.charCodeAt((Ze+32)%A.length)),0===Ze&&(ot=Pe),Pe^=Pe<<10,Pe^=Pe>>>15,Pe^=Pe<<4,Pe^=Pe>>>13,Ze>=0&&(xe=0==(de=St[127&Ze]^=Pe+(ot=ot+1640531527|0))?xe+1:0);for(xe>=128&&(St[127&(A&&A.length||0)]=-1),xe=127,Ze=512;Ze>0;--Ze)Pe=St[xe+34&127],de=St[xe=xe+1&127],Pe^=Pe<<13,de^=de<<17,St[xe]=(Pe^=Pe>>>15)^(de^=de>>>12);ee.w=ot,ee.X=St,ee.i=xe}(Y,me)}function j(me,Y){return Y.i=me.i,Y.w=me.w,Y.X=me.X.slice(),Y}function Ie(me,Y){null==me&&(me=+new Date);var le=new F(me),ee=Y&&Y.state,A=function(){return(le.next()>>>0)/4294967296};return A.double=function(){do{var xe=((le.next()>>>11)+(le.next()>>>0)/4294967296)/(1<<21)}while(0===xe);return xe},A.int32=le.next,A.quick=A,ee&&(ee.X&&j(ee,le),A.state=function(){return j(le,{})}),A}te&&te.exports?te.exports=Ie:M.amdD&&M.amdO?void 0!==(_e=function(){return Ie}.call(Xe,M,Xe,te))&&(te.exports=_e):this.xor4096=Ie}(0,gt=M.nmd(gt))},5583:function(gt,Xe,M){var _e;!function(we,te,Q){function F(me){var Y=this;Y.next=function(){var de,Pe,ee=Y.x,A=Y.i;return de=ee[A],Pe=(de^=de>>>7)^de<<24,Pe^=(de=ee[A+1&7])^de>>>10,Pe^=(de=ee[A+3&7])^de>>>3,Pe^=(de=ee[A+4&7])^de<<7,de=ee[A+7&7],ee[A]=Pe^=(de^=de<<13)^de<<9,Y.i=A+1&7,Pe},function le(ee,A){var de,xe=[];if(A===(0|A))xe[0]=A;else for(A=""+A,de=0;de<A.length;++de)xe[7&de]=xe[7&de]<<15^A.charCodeAt(de)+xe[de+1&7]<<13;for(;xe.length<8;)xe.push(0);for(de=0;de<8&&0===xe[de];++de);for(8==de&&(xe[7]=-1),ee.x=xe,ee.i=0,de=256;de>0;--de)ee.next()}(Y,me)}function j(me,Y){return Y.x=me.x.slice(),Y.i=me.i,Y}function Ie(me,Y){null==me&&(me=+new Date);var le=new F(me),ee=Y&&Y.state,A=function(){return(le.next()>>>0)/4294967296};return A.double=function(){do{var xe=((le.next()>>>11)+(le.next()>>>0)/4294967296)/(1<<21)}while(0===xe);return xe},A.int32=le.next,A.quick=A,ee&&(ee.x&&j(ee,le),A.state=function(){return j(le,{})}),A}te&&te.exports?te.exports=Ie:M.amdD&&M.amdO?void 0!==(_e=function(){return Ie}.call(Xe,M,Xe,te))&&(te.exports=_e):this.xorshift7=Ie}(0,gt=M.nmd(gt))},7657:function(gt,Xe,M){var _e;!function(we,te,Q){function F(me){var Y=this,le="";Y.next=function(){var A=Y.x^Y.x>>>2;return Y.x=Y.y,Y.y=Y.z,Y.z=Y.w,Y.w=Y.v,(Y.d=Y.d+362437|0)+(Y.v=Y.v^Y.v<<4^A^A<<1)|0},Y.x=0,Y.y=0,Y.z=0,Y.w=0,Y.v=0,me===(0|me)?Y.x=me:le+=me;for(var ee=0;ee<le.length+64;ee++)Y.x^=0|le.charCodeAt(ee),ee==le.length&&(Y.d=Y.x<<10^Y.x>>>4),Y.next()}function j(me,Y){return Y.x=me.x,Y.y=me.y,Y.z=me.z,Y.w=me.w,Y.v=me.v,Y.d=me.d,Y}function Ie(me,Y){var le=new F(me),ee=Y&&Y.state,A=function(){return(le.next()>>>0)/4294967296};return A.double=function(){do{var xe=((le.next()>>>11)+(le.next()>>>0)/4294967296)/(1<<21)}while(0===xe);return xe},A.int32=le.next,A.quick=A,ee&&("object"==typeof ee&&j(ee,le),A.state=function(){return j(le,{})}),A}te&&te.exports?te.exports=Ie:M.amdD&&M.amdO?void 0!==(_e=function(){return Ie}.call(Xe,M,Xe,te))&&(te.exports=_e):this.xorwow=Ie}(0,gt=M.nmd(gt))},3818:function(gt,Xe,M){var _e;!function(we,te,Q){var de,F=256,j=6,me="random",Y=Q.pow(F,j),le=Q.pow(2,52),ee=2*le,A=F-1;function Pe(Oe,It,$e){var Ce=[],ye=St(ot((It=1==It?{entropy:!0}:It||{}).entropy?[Oe,ke(te)]:Oe??function Vt(){try{var Oe;return de&&(Oe=de.randomBytes)?Oe=Oe(F):(Oe=new Uint8Array(F),(we.crypto||we.msCrypto).getRandomValues(Oe)),ke(Oe)}catch{var It=we.navigator,$e=It&&It.plugins;return[+new Date,we,$e,we.screen,ke(te)]}}(),3),Ce),$=new xe(Ce),se=function(){for(var be=$.g(j),ce=Y,x=0;be<le;)be=(be+x)*F,ce*=F,x=$.g(1);for(;be>=ee;)be/=2,ce/=2,x>>>=1;return(be+x)/ce};return se.int32=function(){return 0|$.g(4)},se.quick=function(){return $.g(4)/4294967296},se.double=se,St(ke($.S),te),(It.pass||$e||function(be,ce,x,He){return He&&(He.S&&Ze(He,$),be.state=function(){return Ze($,{})}),x?(Q[me]=be,ce):be})(se,ye,"global"in It?It.global:this==Q,It.state)}function xe(Oe){var It,$e=Oe.length,Ce=this,ye=0,$=Ce.i=Ce.j=0,se=Ce.S=[];for($e||(Oe=[$e++]);ye<F;)se[ye]=ye++;for(ye=0;ye<F;ye++)se[ye]=se[$=A&$+Oe[ye%$e]+(It=se[ye])],se[$]=It;(Ce.g=function(be){for(var ce,x=0,He=Ce.i,Me=Ce.j,We=Ce.S;be--;)ce=We[He=A&He+1],x=x*F+We[A&(We[He]=We[Me=A&Me+ce])+(We[Me]=ce)];return Ce.i=He,Ce.j=Me,x})(F)}function Ze(Oe,It){return It.i=Oe.i,It.j=Oe.j,It.S=Oe.S.slice(),It}function ot(Oe,It){var ye,$e=[],Ce=typeof Oe;if(It&&"object"==Ce)for(ye in Oe)try{$e.push(ot(Oe[ye],It-1))}catch{}return $e.length?$e:"string"==Ce?Oe:Oe+"\0"}function St(Oe,It){for(var Ce,$e=Oe+"",ye=0;ye<$e.length;)It[A&ye]=A&(Ce^=19*It[A&ye])+$e.charCodeAt(ye++);return ke(It)}function ke(Oe){return String.fromCharCode.apply(0,Oe)}if(St(Q.random(),te),gt.exports){gt.exports=Pe;try{de=M(5042)}catch{}}else void 0!==(_e=function(){return Pe}.call(Xe,M,Xe,gt))&&(gt.exports=_e)}(typeof self<"u"?self:this,[],Math)},5410:()=>{},8628:()=>{},5042:()=>{},7156:gt=>{function Xe(_e,we,te,Q,F,j,Ie){try{var me=_e[j](Ie),Y=me.value}catch(le){return void te(le)}me.done?we(Y):Promise.resolve(Y).then(Q,F)}gt.exports=function M(_e){return function(){var we=this,te=arguments;return new Promise(function(Q,F){var j=_e.apply(we,te);function Ie(Y){Xe(j,Q,F,Ie,me,"next",Y)}function me(Y){Xe(j,Q,F,Ie,me,"throw",Y)}Ie(void 0)})}},gt.exports.__esModule=!0,gt.exports.default=gt.exports},5861:(gt,Xe,M)=>{"use strict";function _e(te,Q,F,j,Ie,me,Y){try{var le=te[me](Y),ee=le.value}catch(A){return void F(A)}le.done?Q(ee):Promise.resolve(ee).then(j,Ie)}function we(te){return function(){var Q=this,F=arguments;return new Promise(function(j,Ie){var me=te.apply(Q,F);function Y(ee){_e(me,j,Ie,Y,le,"next",ee)}function le(ee){_e(me,j,Ie,Y,le,"throw",ee)}Y(void 0)})}}M.d(Xe,{Z:()=>we})}},gt=>{gt(gt.s=303)}]);